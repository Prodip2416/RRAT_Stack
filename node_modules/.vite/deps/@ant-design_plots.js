import {
  AABB,
  Axis,
  Band,
  CSS,
  Canvas,
  Category,
  ChartLoading,
  Circle,
  Constant,
  Continuous,
  CustomElement,
  CustomEvent,
  DisplayObject,
  Ellipse,
  ErrorBoundary,
  Group,
  HTML,
  Identity,
  Image as Image2,
  Layout,
  Line,
  Linear,
  Log,
  Marker,
  Ordinal,
  Path,
  Plugin,
  Point,
  Polygon,
  Polyline,
  Pow,
  PropertySyntax,
  Quantile,
  Quantize,
  Rect,
  Renderer,
  Scrollbar,
  Sequential,
  Shape,
  Slider,
  Sqrt,
  Text,
  Threshold,
  Time,
  Tooltip,
  __spreadArrays,
  center_default,
  convertToPath,
  createInterpolateValue,
  createNode,
  debounce_default,
  deep_mix_default,
  esm_default,
  filter_default,
  find_default,
  get_default,
  isArray,
  isFunction,
  isNumber,
  isString,
  is_equal_default,
  is_plain_object_default,
  is_undefined_default,
  keys_default,
  last,
  link_default,
  lower_first_default,
  manyBody_default,
  mat3_exports,
  mat4_exports,
  measureTextWidth,
  mix,
  omit_default,
  parseColor,
  pick_default,
  reduce_default,
  require_lodash,
  simulation_default,
  size,
  throttle_default,
  upper_first_default,
  vec3_exports,
  vec4_exports,
  x_default,
  y_default
} from "./chunk-7LS7LWMU.js";
import "./chunk-DBH36C42.js";
import "./chunk-Y7JFD6RV.js";
import "./chunk-ASBICB23.js";
import {
  require_react
} from "./chunk-7FSMUTYF.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-ULBN3QDT.js";

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports, module) {
    "use strict";
    var self = module.exports;
    module.exports.isNumber = function(x2) {
      return typeof x2 === "number";
    };
    module.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, arr[i]);
      }
      return curr;
    };
    module.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, arr[i]);
      }
      return curr;
    };
    module.exports.findMinMulti = function(arr) {
      var curr = self.findMin(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, self.findMin(arr[i]));
      }
      return curr;
    };
    module.exports.findMaxMulti = function(arr) {
      var curr = self.findMax(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, self.findMax(arr[i]));
      }
      return curr;
    };
    module.exports.inside = function(min6, max6, x2) {
      return min6 <= x2 && x2 <= max6;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports, module) {
    "use strict";
    var DEFAULT_SIZE = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self = module.exports;
    var helper = require_helper();
    function kernel(x2) {
      return 1 - Math.abs(x2);
    }
    module.exports.getUnifiedMinMax = function(arr, options) {
      return self.getUnifiedMinMaxMulti([arr], options);
    };
    module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var min6 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max6 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range3 = max6 - min6;
      var step = range3 / (size3 - 1);
      if (relaxMin) {
        min6 = min6 - 2 * width * step;
      }
      if (relaxMax) {
        max6 = max6 + 2 * width * step;
      }
      return {
        min: min6,
        max: max6
      };
    };
    module.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self.getUnifiedMinMax(arr, {
        size: size3,
        width,
        min: options.min,
        max: options.max
      });
      var min6 = normalizedMinMax.min;
      var max6 = normalizedMinMax.max;
      var range3 = max6 - min6;
      var step = range3 / (size3 - 1);
      if (range3 === 0) {
        return [{ x: min6, y: 1 }];
      }
      var buckets = [];
      for (var i = 0; i < size3; i++) {
        buckets.push({
          x: min6 + i * step,
          y: 0
        });
      }
      var xToBucket = function(x2) {
        return Math.floor((x2 - min6) / step);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c4 = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x2) {
        var bucket = xToBucket(x2);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight2 * (leftBlockCount - 1) * c4;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight2 * 1 * c4;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight2 * 2 * c4;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight2 * 1 * c4;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i = -width; i <= width; i++) {
        accumulator += kernel2(i / width);
        partialAreas[i] = accumulator;
      }
      return partialAreas;
    }
    module.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last5 = 0;
      for (var i = 0; i < pdf2.length; i++) {
        last5 = i;
        accumulator += pdf2[i].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last5].x;
    };
    module.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln = Math.log(obj.y);
        if (isFinite(ln)) {
          entropy += obj.y * ln;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AREA_CLASS_NAME: () => AREA_CLASS_NAME,
  Academy: () => Academy,
  Bin: () => Bin,
  BinX: () => BinX,
  COMPONENT_CLASS_NAME: () => COMPONENT_CLASS_NAME,
  Chart: () => Chart2,
  ChartEvent: () => ChartEvent,
  Classic: () => Classic,
  ClassicDark: () => ClassicDark,
  Dark: () => Dark,
  DiffY: () => DiffY,
  DodgeX: () => DodgeX,
  ELEMENT_CLASS_NAME: () => ELEMENT_CLASS_NAME,
  Filter: () => Filter,
  FlexX: () => FlexX,
  Group: () => Group2,
  GroupColor: () => GroupColor,
  GroupX: () => GroupX,
  GroupY: () => GroupY,
  Jitter: () => Jitter,
  JitterX: () => JitterX,
  JitterY: () => JitterY,
  LABEL_CLASS_NAME: () => LABEL_CLASS_NAME,
  LABEL_LAYER_CLASS_NAME: () => LABEL_LAYER_CLASS_NAME,
  Light: () => Light,
  LinearAxis: () => LinearAxis,
  MAIN_LAYER_CLASS_NAME: () => MAIN_LAYER_CLASS_NAME,
  MASK_CLASS_NAME: () => MASK_CLASS_NAME,
  MaybeDefaultX: () => MaybeDefaultX,
  MaybeDefaultY: () => MaybeDefaultY,
  MaybeFunctionAttribute: () => MaybeFunctionAttribute,
  MaybeGradient: () => MaybeGradient,
  MaybeIdentityX: () => MaybeIdentityX,
  MaybeIdentityY: () => MaybeIdentityY,
  MaybeKey: () => MaybeKey,
  MaybeSeries: () => MaybeSeries,
  MaybeSize: () => MaybeSize,
  MaybeStackY: () => MaybeStackY,
  MaybeTitle: () => MaybeTitle,
  MaybeTooltip: () => MaybeTooltip,
  MaybeTuple: () => MaybeTuple,
  MaybeTupleX: () => MaybeTupleX,
  MaybeTupleY: () => MaybeTupleY,
  MaybeVisualPosition: () => MaybeVisualPosition,
  MaybeZeroPadding: () => MaybeZeroPadding,
  MaybeZeroX: () => MaybeZeroX,
  MaybeZeroY: () => MaybeZeroY,
  MaybeZeroY1: () => MaybeZeroY1,
  MaybeZeroZ: () => MaybeZeroZ,
  NormalizeY: () => NormalizeY,
  PLOT_CLASS_NAME: () => PLOT_CLASS_NAME,
  Pack: () => Pack,
  Runtime: () => Runtime,
  Sample: () => Sample,
  Select: () => Select,
  SelectX: () => SelectX,
  SelectY: () => SelectY,
  Selection: () => Selection,
  SortColor: () => SortColor,
  SortX: () => SortX,
  SortY: () => SortY,
  StackEnter: () => StackEnter,
  StackY: () => StackY,
  SymmetryY: () => SymmetryY,
  VIEW_CLASS_NAME: () => VIEW_CLASS_NAME,
  corelib: () => corelib,
  extend: () => extend4,
  geolib: () => geolib,
  graphlib: () => graphlib,
  plotlib: () => plotlib,
  register: () => register,
  render: () => render,
  renderToMountedElement: () => renderToMountedElement,
  select: () => select,
  stdlib: () => stdlib
});

// node_modules/@antv/g2/esm/coordinate/cartesian.js
var Cartesian = () => [["cartesian"]];
Cartesian.props = {};

// node_modules/@antv/g2/esm/utils/angle.js
function convertAngles(startAngle, endAngle) {
  startAngle = startAngle % (2 * Math.PI);
  endAngle = endAngle % (2 * Math.PI);
  if (startAngle < 0) {
    startAngle = 2 * Math.PI + startAngle;
  }
  if (endAngle < 0) {
    endAngle = 2 * Math.PI + endAngle;
  }
  if (startAngle >= endAngle) {
    endAngle = endAngle + 2 * Math.PI;
  }
  return {
    startAngle,
    endAngle
  };
}

// node_modules/@antv/g2/esm/coordinate/polar.js
var getPolarOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  const polarOption = Object.assign(Object.assign({}, defaultOptions), options);
  return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
};
var Polar = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
  return [
    ["translate", 0, 0.5],
    ["reflect.y"],
    ["translate", 0, -0.5],
    ["polar", startAngle, endAngle, innerRadius, outerRadius]
  ];
};
Polar.props = {};

// node_modules/@antv/g2/esm/coordinate/helix.js
var Helix = ({ startAngle = 0, endAngle = Math.PI * 6, innerRadius = 0, outerRadius = 1 }) => [
  ["translate", 0.5, 0.5],
  ["reflect.y"],
  ["translate", -0.5, -0.5],
  ["helix", startAngle, endAngle, innerRadius, outerRadius]
];
Helix.props = {};

// node_modules/@antv/g2/esm/coordinate/transpose.js
var Transpose = () => [
  ["transpose"],
  ["translate", 0.5, 0.5],
  ["reflect.x"],
  ["translate", -0.5, -0.5]
];
Transpose.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/theta.js
var getThetaOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Theta = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
  return [
    ...Transpose(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Theta.props = {};

// node_modules/@antv/g2/esm/coordinate/radial.js
var getRadialOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Radial = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
  return [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect"],
    ["translate", -0.5, -0.5],
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radial.props = {};

// node_modules/@antv/g2/esm/coordinate/parallel.js
var Parallel = () => [["parallel", 0, 1, 0, 1]];
Parallel.props = {};

// node_modules/@antv/g2/esm/coordinate/fisheye.js
var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
Fisheye.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/radar.js
var Radar = (options) => {
  const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
  return [
    ...Parallel(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radar.props = {};

// node_modules/@antv/g2/esm/encode/constant.js
var Constant2 = ({ value: value2 }) => {
  return (data) => data.map(() => value2);
};
Constant2.props = {};

// node_modules/@antv/g2/esm/encode/transform.js
var Transform = ({ value: value2 }) => {
  return (data) => data.map(value2);
};
Transform.props = {};

// node_modules/@antv/g2/esm/encode/field.js
var Field = ({ value: value2 }) => {
  return (data) => data.map((d2) => d2[value2]);
};
Field.props = {};

// node_modules/@antv/g2/esm/encode/column.js
var Column = ({ value: value2 }) => {
  return () => value2;
};
Column.props = {};

// node_modules/@antv/g2/esm/transform/utils/helper.js
function column(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3 };
}
function inferredColumn(value2, field3) {
  const c4 = column(value2, field3);
  return Object.assign(Object.assign({}, c4), { inferred: true });
}
function visualColumn(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3, visual: true };
}
function nonConstantColumn(value2, field3) {
  const c4 = column(value2, field3);
  return Object.assign(Object.assign({}, c4), { constant: false });
}
function constant(I, value2) {
  const array2 = [];
  for (const i of I)
    array2[i] = value2;
  return array2;
}
function columnOf(encode, key) {
  const channel = encode[key];
  if (!channel)
    return [null, null];
  const { value: value2, field: field3 = null } = channel;
  return [value2, field3];
}
function maybeColumnOf(encode, ...K2) {
  for (const key of K2) {
    if (typeof key === "string") {
      const [KV, fv] = columnOf(encode, key);
      if (KV !== null)
        return [KV, fv];
    } else {
      return [key, null];
    }
  }
  return [null, null];
}
function isObject(d2) {
  if (d2 instanceof Date)
    return false;
  return typeof d2 === "object";
}

// node_modules/@antv/g2/esm/transform/maybeZeroY1.js
var MaybeZeroY1 = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y1: inferredColumn(constant(I, 0)) }
      })
    ];
  };
};
MaybeZeroY1.props = {};

// node_modules/d3-array/src/ascending.js
function ascending(a3, b) {
  return a3 == null || b == null ? NaN : a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a3, b) {
  return a3 == null || b == null ? NaN : b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f(d2), x2);
    delta = (d2, x2) => f(d2) - x2;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left2(a3, x2, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a3[mid2], x2) < 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a3, x2, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a3[mid2], x2) <= 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a3, x2, lo = 0, hi = a3.length) {
    const i = left2(a3, x2, lo, hi - 1);
    return i > lo && delta(a3[i - 1], x2) > -delta(a3[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values3, valueof2) {
  if (valueof2 === void 0) {
    for (let value2 of values3) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values3, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values3.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values3.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values3, width, height);
      blurh(blurx, values3, temp, width, height);
      blurh(blurx, temp, values3, width, height);
      blurv(blury, values3, temp, width, height);
      blurv(blury, temp, values3, width, height);
      blurv(blury, values3, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values3, temp, width, height);
      blurh(blurx, temp, values3, width, height);
      blurh(blurx, values3, temp, width, height);
    } else if (blury) {
      blurv(blury, values3, temp, width, height);
      blurv(blury, temp, values3, width, height);
      blurv(blury, values3, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y2 = 0, n = w * h; y2 < n; ) {
    blur3(T, S, y2, y2 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x2 = 0, n = w * h; x2 < w; ++x2) {
    blur3(T, S, x2, x2 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop + 0, step);
    blur3(T, S, start + 1, stop + 1, step);
    blur3(T, S, start + 2, stop + 2, step);
    blur3(T, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum4 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius * S[start];
    const s2 = step * radius;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s2)];
      T[i] = sum4 / w;
      sum4 -= S[Math.max(start, i - s2)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values3, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values3) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  }
  return count4;
}

// node_modules/d3-array/src/variance.js
function variance(values3, valueof2) {
  let count4 = 0;
  let delta;
  let mean3 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values3) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  }
  if (count4 > 1) return sum4 / (count4 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values3, valueof2) {
  const v = variance(values3, valueof2);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values3, valueof2) {
  let min6;
  let max6;
  if (valueof2 === void 0) {
    for (const value2 of values3) {
      if (value2 != null) {
        if (min6 === void 0) {
          if (value2 >= value2) min6 = max6 = value2;
        } else {
          if (min6 > value2) min6 = value2;
          if (max6 < value2) max6 = value2;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null) {
        if (min6 === void 0) {
          if (value2 >= value2) min6 = max6 = value2;
        } else {
          if (min6 > value2) min6 = value2;
          if (max6 < value2) max6 = value2;
        }
      }
    }
  }
  return [min6, max6];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x2) {
    const p2 = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y2 = p2[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
      if (lo) p2[i++] = lo;
      x2 = hi;
    }
    p2[i] = x2;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p2 = this._partials;
    let n = this._n, x2, y2, lo, hi = 0;
    if (n > 0) {
      hi = p2[--n];
      while (n > 0) {
        x2 = hi;
        y2 = p2[--n];
        hi = x2 + y2;
        lo = y2 - (hi - x2);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p2[n - 1] < 0 || lo > 0 && p2[n - 1] > 0)) {
        y2 = lo * 2;
        x2 = hi + y2;
        if (y2 == x2 - hi) hi = x2;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity(x2) {
  return x2;
}

// node_modules/d3-array/src/group.js
function group(values3, ...keys) {
  return nest(values3, identity, identity, keys);
}
function groups(values3, ...keys) {
  return nest(values3, Array.from, identity, keys);
}
function rollup(values3, reduce3, ...keys) {
  return nest(values3, identity, reduce3, keys);
}
function rollups(values3, reduce3, ...keys) {
  return nest(values3, Array.from, reduce3, keys);
}
function nest(values3, map5, reduce3, keys) {
  return function regroup(values4, i) {
    if (i >= keys.length) return reduce3(values4);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index2 = -1;
    for (const value2 of values4) {
      const key = keyof2(value2, ++index2, values4);
      const group2 = groups2.get(key);
      if (group2) group2.push(value2);
      else groups2.set(key, [value2]);
    }
    for (const [key, values5] of groups2) {
      groups2.set(key, regroup(values5, i));
    }
    return map5(groups2);
  }(values3, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values3, ...F) {
  if (typeof values3[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values3 = Array.from(values3);
  let [f] = F;
  if (f && f.length !== 2 || F.length > 1) {
    const index2 = Uint32Array.from(values3, (d2, i) => i);
    if (F.length > 1) {
      F = F.map((f2) => values3.map(f2));
      index2.sort((i, j) => {
        for (const f2 of F) {
          const c4 = ascendingDefined(f2[i], f2[j]);
          if (c4) return c4;
        }
      });
    } else {
      f = values3.map(f);
      index2.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return permute(values3, index2);
  }
  return values3.sort(compareDefined(f));
}
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a3, b) => {
    const x2 = compare(a3, b);
    if (x2 || x2 === 0) return x2;
    return (compare(b, b) === 0) - (compare(a3, a3) === 0);
  };
}
function ascendingDefined(a3, b) {
  return (a3 == null || !(a3 >= a3)) - (b == null || !(b >= b)) || (a3 < b ? -1 : a3 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values3, reduce3, key) {
  return (reduce3.length !== 2 ? sort(rollup(values3, reduce3, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values3, key), ([ak, av], [bk, bv]) => reduce3(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant2(x2) {
  return () => x2;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count4) {
  const step = (stop - start) / Math.max(0, count4), power = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start, stop, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  if (!(count4 > 0)) return [];
  if (start === stop) return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count4) : tickSpec(start, stop, count4);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  return tickSpec(start, stop, count4)[2];
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count4) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count4);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values3) {
  return Math.max(1, Math.ceil(Math.log(count(values3)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value2 = identity, domain = extent, threshold = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i, n = data.length, x2, step, values3 = new Array(n);
    for (i = 0; i < n; ++i) {
      values3[i] = value2(data[i], i, data);
    }
    var xz = domain(values3), x05 = xz[0], x12 = xz[1], tz = threshold(values3, x05, x12);
    if (!Array.isArray(tz)) {
      const max6 = x12, tn = +tz;
      if (domain === extent) [x05, x12] = nice(x05, x12, tn);
      tz = ticks(x05, x12, tn);
      if (tz[0] <= x05) step = tickIncrement(x05, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max6 >= x12 && domain === extent) {
          const step2 = tickIncrement(x05, x12, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x12 = (Math.floor(x12 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m2 = tz.length, a3 = 0, b = m2;
    while (tz[a3] <= x05) ++a3;
    while (tz[b - 1] > x12) --b;
    if (a3 || b < m2) tz = tz.slice(a3, b), m2 = b - a3;
    var bins = new Array(m2 + 1), bin2;
    for (i = 0; i <= m2; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x05;
      bin2.x1 = i < m2 ? tz[i] : x12;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values3[i]) != null && x05 <= x2 && x2 <= x12) {
            bins[Math.min(m2, Math.floor((x2 - x05) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values3[i]) != null && x05 <= x2 && x2 <= x12) {
            const j = Math.floor((x05 - x2) * step);
            bins[Math.min(m2, j + (tz[j] <= x2))].push(data[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x2 = values3[i]) != null && x05 <= x2 && x2 <= x12) {
          bins[bisect_default(tz, x2, 0, m2)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant2(_), histogram) : value2;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant2([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : constant2(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max(values3, valueof2) {
  let max6;
  if (valueof2 === void 0) {
    for (const value2 of values3) {
      if (value2 != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  }
  return max6;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values3, valueof2) {
  let max6;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values3) {
      ++index2;
      if (value2 != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2, maxIndex2 = index2;
      }
    }
  } else {
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min(values3, valueof2) {
  let min6;
  if (valueof2 === void 0) {
    for (const value2 of values3) {
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  }
  return min6;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values3, valueof2) {
  let min6;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values3) {
      ++index2;
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2, minIndex2 = index2;
      }
    }
  } else {
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m2 = k2 - left2 + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m2 * s2 / n + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n - m2) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0) swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left2], t) === 0) swap(array2, left2, j);
    else ++j, swap(array2, j, right2);
    if (j <= k2) left2 = j + 1;
    if (k2 <= j) right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values3, compare = ascending) {
  let max6;
  let defined3 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values3) {
      const value2 = compare(element);
      if (defined3 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max6 = element;
        maxValue = value2;
        defined3 = true;
      }
    }
  } else {
    for (const value2 of values3) {
      if (defined3 ? compare(value2, max6) > 0 : compare(value2, value2) === 0) {
        max6 = value2;
        defined3 = true;
      }
    }
  }
  return max6;
}

// node_modules/d3-array/src/quantile.js
function quantile(values3, p2, valueof2) {
  values3 = Float64Array.from(numbers(values3, valueof2));
  if (!(n = values3.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n < 2) return min(values3);
  if (p2 >= 1) return max(values3);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max(quickselect(values3, i0).subarray(0, i0 + 1)), value1 = min(values3.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values3, p2, valueof2 = number) {
  if (isNaN(p2 = +p2)) return;
  numbers2 = Float64Array.from(values3, (_, i2) => number(valueof2(values3[i2], i2, values3)));
  if (p2 <= 0) return minIndex(numbers2);
  if (p2 >= 1) return maxIndex(numbers2);
  var numbers2, index2 = Uint32Array.from(values3, (_, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p2);
  quickselect(index2, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
  i = greatest(index2.subarray(0, i + 1), (i2) => numbers2[i2]);
  return i >= 0 ? i : -1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values3, min6, max6) {
  const c4 = count(values3), d2 = deviation(values3);
  return c4 && d2 ? Math.ceil((max6 - min6) * Math.cbrt(c4) / (3.49 * d2)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values3, valueof2) {
  let count4 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values3) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if ((value2 = valueof2(value2, ++index2, values3)) != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  }
  if (count4) return sum4 / count4;
}

// node_modules/d3-array/src/median.js
function median(values3, valueof2) {
  return quantile(values3, 0.5, valueof2);
}
function medianIndex(values3, valueof2) {
  return quantileIndex(values3, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start + i * step;
  }
  return range3;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i = random() * m2-- | 0, t = array2[m2 + i0];
      array2[m2 + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values3, valueof2) {
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values3) {
      if (value2 = +value2) {
        sum4 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values3) {
      if (value2 = +valueof2(value2, ++index2, values3)) {
        sum4 += value2;
      }
    }
  }
  return sum4;
}

// node_modules/@antv/g2/esm/utils/helper.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function identity2(x2) {
  return x2;
}
function compose(fns) {
  return fns.reduce((composed, fn) => (x2, ...args) => fn(composed(x2, ...args), ...args), identity2);
}
function composeAsync(fns) {
  return fns.reduce((composed, fn) => (x2) => __awaiter(this, void 0, void 0, function* () {
    const value2 = yield composed(x2);
    return fn(value2);
  }), identity2);
}
function capitalizeFirst(str) {
  return str.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
function error(message = "") {
  throw new Error(message);
}
function copyAttributes(target, source) {
  const { attributes } = source;
  const exclude2 = /* @__PURE__ */ new Set(["id", "className"]);
  for (const [key, value2] of Object.entries(attributes)) {
    if (!exclude2.has(key)) {
      target.attr(key, value2);
    }
  }
}
function defined(x2) {
  return x2 !== void 0 && x2 !== null && !Number.isNaN(x2);
}
function useMemo(compute2) {
  const map5 = /* @__PURE__ */ new Map();
  return (key) => {
    if (map5.has(key))
      return map5.get(key);
    const value2 = compute2(key);
    map5.set(key, value2);
    return value2;
  };
}
function appendTransform(node, transform) {
  const { transform: preTransform } = node.style;
  const unset = (d2) => d2 === "none" || d2 === void 0;
  const prefix = unset(preTransform) ? "" : preTransform;
  node.style.transform = `${prefix} ${transform}`.trimStart();
}
function subObject(obj, prefix) {
  return maybeSubObject(obj, prefix) || {};
}
function maybeSubObject(obj, prefix) {
  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
  return entries.length === 0 ? null : Object.fromEntries(entries);
}
function filterPrefixObject(obj, prefix) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p2) => key.startsWith(p2))));
}
function omitPrefixObject(obj, ...prefixes2) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
}
function maybePercentage(x2, size3) {
  if (x2 === void 0)
    return null;
  if (typeof x2 === "number")
    return x2;
  const px = +x2.replace("%", "");
  return Number.isNaN(px) ? null : px / 100 * size3;
}
function isStrictObject(d2) {
  return typeof d2 === "object" && !(d2 instanceof Date) && d2 !== null && !Array.isArray(d2);
}
function isUnset(value2) {
  return value2 === null || value2 === false;
}
function deepAssign(dist2, src, maxLevel = 5, level = 0) {
  if (level >= maxLevel)
    return;
  for (const key of Object.keys(src)) {
    const value2 = src[key];
    if (!is_plain_object_default(value2) || !is_plain_object_default(dist2[key])) {
      dist2[key] = value2;
    } else {
      deepAssign(dist2[key], value2, maxLevel, level + 1);
    }
  }
  return dist2;
}

// node_modules/@antv/g2/esm/utils/array.js
function mapObject(object, callbackfn) {
  return Object.entries(object).reduce((obj, [key, value2]) => {
    obj[key] = callbackfn(value2, key, object);
    return obj;
  }, {});
}
function indexOf(array2) {
  return array2.map((_, i) => i);
}
function firstOf(array2) {
  return array2[0];
}
function lastOf(array2) {
  return array2[array2.length - 1];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function divide(array2, callbackfn) {
  const result = [[], []];
  array2.forEach((item) => {
    result[callbackfn(item) ? 0 : 1].push(item);
  });
  return result;
}
function comb(array2, len = array2.length) {
  if (len === 1)
    return array2.map((item) => [item]);
  const result = [];
  for (let i = 0; i < array2.length; i++) {
    const rest = array2.slice(i + 1);
    const restComb = comb(rest, len - 1);
    restComb.forEach((comb2) => {
      result.push([array2[i], ...comb2]);
    });
  }
  return result;
}
function combine(array2) {
  if (array2.length === 1)
    return [array2];
  const result = [];
  for (let i = 1; i <= array2.length; i++) {
    result.push(...comb(array2, i));
  }
  return result;
}

// node_modules/@antv/g2/esm/transform/utils/order.js
function createGroups(groupBy2, I, mark2) {
  const { encode } = mark2;
  if (groupBy2 === null)
    return [I];
  const G = normalizeGroupBy(groupBy2).map((k2) => {
    var _a;
    return [k2, (_a = columnOf(encode, k2)) === null || _a === void 0 ? void 0 : _a[0]];
  }).filter(([, column2]) => defined(column2));
  const key = (i) => G.map(([, V]) => V[i]).join("-");
  return Array.from(group(I, key).values());
}
function normalizeComparator(order) {
  if (Array.isArray(order))
    return createFieldsOrder(order);
  if (typeof order === "function")
    return createFunctionOrder(order);
  if (order === "series")
    return createSeriesOrder;
  if (order === "value")
    return createValueOrder;
  if (order === "sum")
    return createSumOrder;
  if (order === "maxIndex")
    return createMaxIndexOrder;
  return null;
}
function applyOrder(groups2, comparator) {
  for (const group2 of groups2) {
    group2.sort(comparator);
  }
}
function domainOf(value2, scale3) {
  return (scale3 === null || scale3 === void 0 ? void 0 : scale3.domain) || Array.from(new Set(value2));
}
function normalizeGroupBy(groupBy2) {
  if (Array.isArray(groupBy2))
    return groupBy2;
  return [groupBy2];
}
function createSeriesOrder(data, Y, S) {
  return ascendingComparator((i) => S[i]);
}
function createFunctionOrder(order) {
  return (data, Y, S) => {
    return ascendingComparator((i) => order(data[i]));
  };
}
function createFieldsOrder(order) {
  return (data, Y, S) => {
    return (i, j) => order.reduce((eq, f) => eq !== 0 ? eq : ascending(data[i][f], data[j][f]), 0);
  };
}
function createValueOrder(data, Y, S) {
  return ascendingComparator((i) => Y[i]);
}
function createSumOrder(data, Y, S) {
  const I = indexOf(data);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesSum = new Map(groups2.map(([k2, GI]) => [k2, GI.reduce((s2, i) => s2 + +Y[i])]));
  return ascendingComparator((i) => seriesSum.get(S[i]));
}
function createMaxIndexOrder(data, Y, S) {
  const I = indexOf(data);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesMaxIndex = new Map(groups2.map(([k2, GI]) => [k2, maxIndex(GI, (i) => Y[i])]));
  return ascendingComparator((i) => seriesMaxIndex.get(S[i]));
}
function ascendingComparator(order) {
  return (i, j) => ascending(order(i), order(j));
}

// node_modules/@antv/g2/esm/transform/stackY.js
var StackY = (options = {}) => {
  const { groupBy: groupBy2 = "x", orderBy = null, reverse: reverse2 = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
  return (I, mark2) => {
    var _a;
    const { data, encode, style = {} } = mark2;
    const [Y, fy] = columnOf(encode, "y");
    const [Y12, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy2, I, mark2);
    const createComparator = (_a = normalizeComparator(orderBy)) !== null && _a !== void 0 ? _a : () => null;
    const comparator = createComparator(data, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newY = new Array(I.length);
    const newY1 = new Array(I.length);
    const TY = new Array(I.length);
    const F = [];
    const L = [];
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      const start = Y12 ? +Y12[G[0]] : 0;
      const PG = [];
      const NG = [];
      for (const i2 of G) {
        const y2 = TY[i2] = +Y[i2] - start;
        if (y2 < 0)
          NG.push(i2);
        else if (y2 >= 0)
          PG.push(i2);
      }
      const FG = PG.length > 0 ? PG : NG;
      const LG = NG.length > 0 ? NG : PG;
      let i = PG.length - 1;
      let j = 0;
      while (i > 0 && Y[FG[i]] === 0)
        i--;
      while (j < LG.length - 1 && Y[LG[j]] === 0)
        j++;
      F.push(FG[i]);
      L.push(LG[j]);
      let ny = start;
      for (const i2 of NG.reverse()) {
        const y2 = TY[i2];
        ny = newY[i2] = (newY1[i2] = ny) + y2;
      }
      let py = start;
      for (const i2 of PG) {
        const y2 = TY[i2];
        if (y2 > 0)
          py = newY[i2] = (newY1[i2] = py) + y2;
        else
          newY[i2] = newY1[i2] = py;
      }
    }
    const FS = new Set(F);
    const LS = new Set(L);
    const V = fromY === "y" ? newY : newY1;
    const V1 = fromY1 === "y" ? newY : newY1;
    let newEncode;
    if (mark2.type === "point") {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy)
      };
    } else {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy),
        y1: column(V1, fy1)
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.assign({}, newEncode),
        style: Object.assign({ first: (_, i) => FS.has(i), last: (_, i) => LS.has(i) }, style)
      })
    ];
  };
};
StackY.props = {};

// node_modules/@antv/g2/esm/transform/maybeStackY.js
function exclude(transform) {
  const { type } = transform;
  const excludes = ["stackY", "dodgeX", "groupX"];
  return typeof type === "string" && excludes.includes(type);
}
var MaybeStackY = (options) => {
  return (I, mark2, context) => {
    const { encode, transform = [] } = mark2;
    if (transform.some(exclude))
      return [I, mark2];
    const { x: x2, y: y2 } = encode;
    if (x2 === void 0 || y2 === void 0)
      return [I, mark2];
    const { series } = options;
    const groupBy2 = series ? ["x", "series"] : "x";
    return StackY({ groupBy: groupBy2 })(I, mark2, context);
  };
};
MaybeStackY.props = {};

// node_modules/@antv/g2/esm/utils/dateFormat.js
function fillZero(digit) {
  if (Math.abs(digit) > 10)
    return String(digit);
  return digit.toString().padStart(2, "0");
}
function dynamicFormatDateTime(date) {
  const year = date.getFullYear();
  const month = fillZero(date.getMonth() + 1);
  const day = fillZero(date.getDate());
  const yyyyMMDD = `${year}-${month}-${day}`;
  const hour = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  if (hour || minutes || seconds)
    return `${yyyyMMDD} ${fillZero(hour)}:${fillZero(minutes)}:${fillZero(seconds)}`;
  return yyyyMMDD;
}

// node_modules/@antv/g2/esm/transform/maybeTitle.js
var MaybeTitle = (options = {}) => {
  const { channel = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { title } = tooltip2;
    if (title !== void 0)
      return [I, mark2];
    const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T2]) => T2).map((d2) => d2[0]);
    if (titles.length === 0)
      return [I, mark2];
    const T = [];
    for (const i of I) {
      T[i] = {
        value: titles.map((t) => t[i] instanceof Date ? dynamicFormatDateTime(t[i]) : t[i]).join(", ")
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        tooltip: {
          title: T
        }
      })
    ];
  };
};
MaybeTitle.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroX.js
var MaybeZeroX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x2 } = encode;
    if (x2 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { x: inferredColumn(constant(I, 0)) },
        scale: { x: { guide: null } }
      })
    ];
  };
};
MaybeZeroX.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroY.js
var MaybeZeroY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y2 } = encode;
    if (y2 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y: inferredColumn(constant(I, 0)) },
        scale: { y: { guide: null } }
      })
    ];
  };
};
MaybeZeroY.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroZ.js
var MaybeZeroZ = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { z } = encode;
    if (z !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { z: inferredColumn(constant(I, 0)) },
        scale: { z: { guide: null } }
      })
    ];
  };
};
MaybeZeroZ.props = {};

// node_modules/@antv/g2/esm/transform/maybeSize.js
var MaybeSize = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { size: size3 } = encode;
    if (size3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, { encode: { size: visualColumn(constant(I, 3)) } })
    ];
  };
};
MaybeSize.props = {};

// node_modules/@antv/g2/esm/transform/maybeKey.js
var __rest = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var MaybeKey = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { key } = encode, rest = __rest(encode, ["key"]);
    if (key !== void 0)
      return [I, mark2];
    const values3 = Object.values(rest).map(({ value: value2 }) => value2);
    const K2 = I.map((i) => values3.filter(Array.isArray).map((V) => V[i]).join("-"));
    return [I, deep_mix_default({}, mark2, { encode: { key: column(K2) } })];
  };
};
MaybeKey.props = {};

// node_modules/@antv/g2/esm/transform/maybeSeries.js
var MaybeSeries = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { series, color: color2 } = encode;
    if (series !== void 0 || color2 === void 0)
      return [I, mark2];
    const [C2, fc] = columnOf(encode, "color");
    return [I, deep_mix_default({}, mark2, { encode: { series: column(C2, fc) } })];
  };
};
MaybeSeries.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleY.js
var MaybeTupleY = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { y: column(data) } })];
  };
};
MaybeTupleY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleX.js
var MaybeTupleX = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { x: column(data) } })];
  };
};
MaybeTupleX.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityY.js
var MaybeIdentityY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12)
      return [I, mark2];
    const [Y] = columnOf(encode, "y");
    return [I, deep_mix_default({}, mark2, { encode: { y1: column([...Y]) } })];
  };
};
MaybeIdentityY.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityX.js
var MaybeIdentityX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x1: x12 } = encode;
    if (x12)
      return [I, mark2];
    const [X] = columnOf(encode, "x");
    return [I, deep_mix_default({}, mark2, { encode: { x1: column([...X]) } })];
  };
};
MaybeIdentityX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultX.js
var MaybeDefaultX = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (Array.isArray(data) && (data.every(Array.isArray) || !data.some(isObject))) {
      const extractX = (data2, index2) => Array.isArray(data2[0]) ? data2.map((item) => item[index2]) : [data2[index2]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            x: column(extractX(data, 0)),
            x1: column(extractX(data, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultY.js
var MaybeDefaultY = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (Array.isArray(data) && (data.every(Array.isArray) || !data.some(isObject))) {
      const extractY = (data2, index2) => Array.isArray(data2[0]) ? data2.map((item) => item[index2]) : [data2[index2]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            y: column(extractY(data, 0)),
            y1: column(extractY(data, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTooltip.js
var MaybeTooltip = (options) => {
  const { channel } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { items = [] } = tooltip2;
    if (!items || items.length > 0)
      return [I, mark2];
    const channels = Array.isArray(channel) ? channel : [channel];
    const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
      const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
      if (inferred)
        return null;
      if (aggregate && value2)
        return { channel: key };
      if (field3)
        return { field: field3 };
      if (value2)
        return { channel: key };
      return null;
    }).filter((d2) => d2 !== null));
    return [I, deep_mix_default({}, mark2, { tooltip: { items: newItems } })];
  };
};
MaybeTooltip.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
var MaybeZeroPadding = () => {
  return (I, mark2) => {
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark2)
    ];
  };
};
MaybeZeroPadding.props = {};

// node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
var __rest2 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var MaybeVisualPosition = () => {
  return (I, mark2) => {
    const { data, style = {} } = mark2, restMark = __rest2(mark2, ["data", "style"]);
    const { x: x05, y: y05 } = style, rest = __rest2(style, ["x", "y"]);
    if (x05 == void 0 || y05 == void 0)
      return [I, mark2];
    const x2 = x05 || 0;
    const y2 = y05 || 0;
    return [
      [0],
      deep_mix_default({}, restMark, {
        data: [0],
        cartesian: true,
        encode: {
          x: column([x2]),
          y: column([y2])
        },
        scale: {
          x: { type: "identity", independent: true, guide: null },
          y: { type: "identity", independent: true, guide: null }
          // hide axis
        },
        style: rest
      })
    ];
  };
};
MaybeVisualPosition.props = {};

// node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
var MaybeFunctionAttribute = () => {
  return (I, mark2) => {
    const { style = {} } = mark2;
    return [
      I,
      deep_mix_default({}, mark2, {
        style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k2, v]) => [k2, () => v])))
      })
    ];
  };
};
MaybeFunctionAttribute.props = {};

// node_modules/@antv/g2/esm/transform/maybeTuple.js
var MaybeTuple = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    const position = Array.isArray(data[0]) ? data : [data];
    const X = position.map((d2) => d2[0]);
    const Y = position.map((d2) => d2[1]);
    return [I, deep_mix_default({}, mark2, { encode: { x: column(X), y: column(Y) } })];
  };
};
MaybeTuple.props = {};

// node_modules/@antv/g2/esm/transform/maybeGradient.js
var MaybeGradient = () => {
  return (I, mark2) => {
    const { style = {}, encode } = mark2;
    const { series } = encode;
    const { gradient } = style;
    if (!gradient || series)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          series: visualColumn(constant(I, void 0))
        }
      })
    ];
  };
};
MaybeGradient.props = {};

// node_modules/@antv/g2/esm/transform/dodgeX.js
var __rest3 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DodgeX = (options = {}) => {
  const { groupBy: groupBy2 = "x", reverse: reverse2 = false, orderBy, padding } = options, rest = __rest3(options, ["groupBy", "reverse", "orderBy", "padding"]);
  return (I, mark2) => {
    const { data, encode, scale: scale3 } = mark2;
    const { series: scaleSeries } = scale3;
    const [Y] = columnOf(encode, "y");
    const [S] = maybeColumnOf(encode, "series", "color");
    const domainSeries = domainOf(S, scaleSeries);
    const newMark = deep_mix_default({}, mark2, {
      scale: {
        series: {
          domain: domainSeries,
          paddingInner: padding
        }
      }
    });
    const groups2 = createGroups(groupBy2, I, mark2);
    const createComparator = normalizeComparator(orderBy);
    if (!createComparator) {
      return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
    }
    const comparator = createComparator(data, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newS = new Array(I.length);
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      for (let i = 0; i < G.length; i++) {
        newS[G[i]] = domainSeries[i];
      }
    }
    return [
      I,
      deep_mix_default(newMark, {
        encode: {
          series: column(orderBy ? newS : S)
        }
      })
    ];
  };
};
DodgeX.props = {};

// node_modules/@antv/g2/esm/transform/stackEnter.js
var StackEnter = (options) => {
  const { groupBy: groupBy2 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse: reverse2 = false, duration } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const by = Array.isArray(groupBy2) ? groupBy2 : [groupBy2];
    const groupEntries = by.map((k2) => [k2, columnOf(encode, k2)[0]]);
    if (groupEntries.length === 0)
      return [I, mark2];
    let groups2 = [I];
    for (const [, V] of groupEntries) {
      const newGroups = [];
      for (const I2 of groups2) {
        const G = Array.from(group(I2, (i) => V[i]).values());
        newGroups.push(...G);
      }
      groups2 = newGroups;
    }
    if (orderBy) {
      const [V] = columnOf(encode, orderBy);
      if (V)
        groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
      if (reverse2)
        groups2.reverse();
    }
    const t = (duration || 3e3) / groups2.length;
    const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
    const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
    const newEnterDelay = new Array(I.length);
    for (let i = 0, pd = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const maxDuration = max(I2, (i2) => +ED2[i2]);
      for (const j of I2)
        newEnterDelay[j] = +EDL[j] + pd;
      pd += maxDuration;
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          enterDuration: visualColumn(ED2),
          enterDelay: visualColumn(newEnterDelay)
        }
      })
    ];
  };
};
StackEnter.props = {};

// node_modules/@antv/g2/esm/transform/normalizeY.js
var __rest4 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function normalizeBasis(basis2) {
  if (typeof basis2 === "function")
    return basis2;
  const registry = {
    min: (I, Y) => min(I, (i) => Y[+i]),
    max: (I, Y) => max(I, (i) => Y[+i]),
    first: (I, Y) => Y[I[0]],
    last: (I, Y) => Y[I[I.length - 1]],
    mean: (I, Y) => mean(I, (i) => Y[+i]),
    median: (I, Y) => median(I, (i) => Y[+i]),
    sum: (I, Y) => sum(I, (i) => Y[+i]),
    deviation: (I, Y) => deviation(I, (i) => Y[+i])
  };
  return registry[basis2] || max;
}
var NormalizeY = (options = {}) => {
  const { groupBy: groupBy2 = "x", basis: basis2 = "max" } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    const { x: x2 } = encode, rest = __rest4(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const [, Y] = Yn2.find(([k2]) => k2 === "y");
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy2, I, mark2);
    const basisFunction = normalizeBasis(basis2);
    for (const I2 of groups2) {
      const basisValue = basisFunction(I2, Y);
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] / basisValue;
        }
      }
    }
    const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
    return [
      I,
      deep_mix_default({}, mark2, Object.assign({ encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])])) }, !specifiedTooltip && encode.y0 && {
        tooltip: { items: [{ channel: "y0" }] }
      }))
    ];
  };
};
NormalizeY.props = {};

// node_modules/@antv/g2/esm/transform/jitter.js
function rangeOf(value2, scaleOptions, padding) {
  if (value2 === null)
    return [-0.5, 0.5];
  const domain = domainOf(value2, scaleOptions);
  const scale3 = new Band({ domain, range: [0, 1], padding });
  const step = scale3.getBandWidth();
  return [-step / 2, step / 2];
}
function interpolate(t, a3, b) {
  return a3 * (1 - t) + b * t;
}
var Jitter = (options = {}) => {
  const { padding = 0, paddingX = padding, paddingY = padding, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale3 } = mark2;
    const { x: scaleX, y: scaleY } = scale3;
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    const rangeX = rangeOf(X, scaleX, paddingX);
    const rangeY = rangeOf(Y, scaleY, paddingY);
    const DY = I.map(() => interpolate(random(), ...rangeY));
    const DX = I.map(() => interpolate(random(), ...rangeX));
    return [
      I,
      deep_mix_default({
        scale: {
          x: { padding: 0.5 },
          y: { padding: 0.5 }
        }
      }, mark2, {
        encode: { dy: column(DY), dx: column(DX) }
      })
    ];
  };
};
Jitter.props = {};

// node_modules/@antv/g2/esm/transform/jitterX.js
var JitterX = (options = {}) => {
  const { padding = 0, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale3 } = mark2;
    const { x: scaleX } = scale3;
    const [X] = columnOf(encode, "x");
    const rangeX = rangeOf(X, scaleX, padding);
    const DX = I.map(() => interpolate(random(), ...rangeX));
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark2, {
        encode: { dx: column(DX) }
      })
    ];
  };
};
JitterX.props = {};

// node_modules/@antv/g2/esm/transform/jitterY.js
var JitterY = (options = {}) => {
  const { padding = 0, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale3 } = mark2;
    const { y: scaleY } = scale3;
    const [Y] = columnOf(encode, "y");
    const rangeY = rangeOf(Y, scaleY, padding);
    const DY = I.map(() => interpolate(random(), ...rangeY));
    return [
      I,
      deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark2, {
        encode: { dy: column(DY) }
      })
    ];
  };
};
JitterY.props = {};

// node_modules/@antv/g2/esm/transform/symmetryY.js
var __rest5 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SymmetryY = (options = {}) => {
  const { groupBy: groupBy2 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x2 } = encode, rest = __rest5(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy2, I, mark2);
    const MY = new Array(groups2.length);
    for (let i = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const Y = I2.flatMap((i2) => Yn2.map(([, V]) => +V[i2]));
      const [minY, maxY2] = extent(Y);
      MY[i] = (minY + maxY2) / 2;
    }
    const maxMiddleY = Math.max(...MY);
    for (let m2 = 0; m2 < groups2.length; m2++) {
      const offset = maxMiddleY - MY[m2];
      const I2 = groups2[m2];
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] + offset;
        }
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])]))
      })
    ];
  };
};
SymmetryY.props = {};

// node_modules/@antv/g2/esm/transform/diffY.js
var DiffY = (options = {}) => {
  const { groupBy: groupBy2 = "x", series = true } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const [Y] = columnOf(encode, "y");
    const [_, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy2, I, mark2);
    const newY1 = new Array(I.length);
    for (const G of groups2) {
      const YG = G.map((i) => +Y[i]);
      for (let idx = 0; idx < G.length; idx++) {
        const i = G[idx];
        const max6 = Math.max(...YG.filter((_2, _i) => _i !== idx));
        newY1[i] = +Y[i] > max6 ? max6 : Y[i];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y1: column(newY1, fy1)
        }
      })
    ];
  };
};
DiffY.props = {};

// node_modules/@antv/g2/esm/transform/select.js
function first(I, V) {
  return [I[0]];
}
function last2(I, V) {
  const i = I.length - 1;
  return [I[i]];
}
function max2(I, V) {
  const i = maxIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function min2(I, V) {
  const i = minIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function normalizeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  const registry = { first, last: last2, max: max2, min: min2 };
  return registry[selector] || first;
}
var Select = (options = {}) => {
  const { groupBy: groupBy2 = "series", channel, selector } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy2, I, mark2);
    const [V] = columnOf(encode, channel);
    const selectFunction = normalizeSelector(selector);
    return [groups2.flatMap((GI) => selectFunction(GI, V)), mark2];
  };
};
Select.props = {};

// node_modules/@antv/g2/esm/transform/selectX.js
var __rest6 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SelectX = (options = {}) => {
  const { selector } = options, rest = __rest6(options, ["selector"]);
  return Select(Object.assign({ channel: "x", selector }, rest));
};
SelectX.props = {};

// node_modules/@antv/g2/esm/transform/selectY.js
var __rest7 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SelectY = (options = {}) => {
  const { selector } = options, rest = __rest7(options, ["selector"]);
  return Select(Object.assign({ channel: "y", selector }, rest));
};
SelectY.props = {};

// node_modules/@antv/g2/esm/transform/groupN.js
var __rest8 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function builtinFormatter(summary) {
  return (d2) => d2 === null ? summary : `${summary} of ${d2}`;
}
function normalizeReducer(reducer) {
  if (typeof reducer === "function")
    return [reducer, null];
  const registry = { mean: mean2, max: max3, count: count2, first: first2, last: last3, sum: sum2, min: min3, median: median2 };
  const reducerFunction = registry[reducer];
  if (!reducerFunction)
    throw new Error(`Unknown reducer: ${reducer}.`);
  return reducerFunction();
}
function mean2() {
  const reducer = (I, V) => mean(I, (i) => +V[i]);
  const formatter = builtinFormatter("mean");
  return [reducer, formatter];
}
function median2() {
  const reducer = (I, V) => median(I, (i) => +V[i]);
  const formatter = builtinFormatter("median");
  return [reducer, formatter];
}
function max3() {
  const reducer = (I, V) => max(I, (i) => +V[i]);
  const formatter = builtinFormatter("max");
  return [reducer, formatter];
}
function min3() {
  const reducer = (I, V) => min(I, (i) => +V[i]);
  const formatter = builtinFormatter("min");
  return [reducer, formatter];
}
function count2() {
  const reducer = (I, V) => I.length;
  const formatter = builtinFormatter("count");
  return [reducer, formatter];
}
function sum2() {
  const reducer = (I, V) => sum(I, (i) => +V[i]);
  const formatter = builtinFormatter("sum");
  return [reducer, formatter];
}
function first2() {
  const reducer = (I, V) => V[I[0]];
  const formatter = builtinFormatter("first");
  return [reducer, formatter];
}
function last3() {
  const reducer = (I, V) => V[I[I.length - 1]];
  const formatter = builtinFormatter("last");
  return [reducer, formatter];
}
var GroupN = (options = {}) => {
  const { groupBy: groupBy2 } = options, rest = __rest8(options, ["groupBy"]);
  return (I, mark2) => {
    const { data, encode } = mark2;
    const groups2 = groupBy2(I, mark2);
    if (!groups2)
      return [I, mark2];
    const maybeFrom = (field3, reducer) => {
      if (field3)
        return field3;
      const { from } = reducer;
      if (!from)
        return field3;
      const [, field1] = columnOf(encode, from);
      return field1;
    };
    const outputs = Object.entries(rest).map(([channel, reducer]) => {
      const [reducerFunction, formatter] = normalizeReducer(reducer);
      const [V, field3] = columnOf(encode, channel);
      const field1 = maybeFrom(field3, reducer);
      const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data));
      return [
        channel,
        Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter === null || formatter === void 0 ? void 0 : formatter(field1)) || field1)), { aggregate: true })
      ];
    });
    const reducedColumns = Object.keys(encode).map((key) => {
      const [V, fv] = columnOf(encode, key);
      const GV = groups2.map((I2) => V[I2[0]]);
      return [key, column(GV, fv)];
    });
    const GD = groups2.map((I2) => data[I2[0]]);
    const GI = indexOf(groups2);
    return [
      GI,
      deep_mix_default({}, mark2, {
        data: GD,
        encode: Object.fromEntries([...reducedColumns, ...outputs])
      })
    ];
  };
};
GroupN.props = {};

// node_modules/@antv/g2/esm/transform/group.js
var __rest9 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Group2 = (options = {}) => {
  const { channels = ["x", "y"] } = options, rest = __rest9(options, ["channels"]);
  const groupBy2 = (I, mark2) => createGroups(channels, I, mark2);
  return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy2 }));
};
Group2.props = {};

// node_modules/@antv/g2/esm/transform/groupX.js
var GroupX = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
};
GroupX.props = {};

// node_modules/@antv/g2/esm/transform/groupY.js
var GroupY = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
};
GroupY.props = {};

// node_modules/@antv/g2/esm/transform/groupColor.js
var GroupColor = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["color"] }));
};
GroupColor.props = {};

// node_modules/@antv/g2/esm/transform/sort.js
var __rest10 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createReducer(channel, options, encode) {
  const { by = channel, reducer = "max" } = options;
  const [V] = columnOf(encode, by);
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "max")
    return (GI) => max(GI, (i) => +V[i]);
  if (reducer === "min")
    return (GI) => min(GI, (i) => +V[i]);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  if (reducer === "median")
    return (GI) => median(GI, (i) => +V[i]);
  if (reducer === "mean")
    return (GI) => mean(GI, (i) => +V[i]);
  if (reducer === "first")
    return (GI) => V[GI[0]];
  if (reducer === "last")
    return (GI) => V[GI[GI.length - 1]];
  throw new Error(`Unknown reducer: ${reducer}`);
}
function sortQuantitative(I, mark2, options) {
  const { reverse: reverse2, channel } = options;
  const { encode } = mark2;
  const [V] = columnOf(encode, channel);
  const sortedI = sort(I, (i) => V[i]);
  if (reverse2)
    sortedI.reverse();
  return [sortedI, mark2];
}
function filterIndex(I, values3, specifiedDomain) {
  if (!Array.isArray(specifiedDomain))
    return I;
  const domain = new Set(specifiedDomain);
  return I.filter((i) => domain.has(values3[i]));
}
function sortOrdinal(I, mark2, options) {
  var _a;
  const { reverse: reverse2, slice: slice3, channel } = options, rest = __rest10(options, ["reverse", "slice", "channel"]);
  const { encode, scale: scale3 = {} } = mark2;
  const domain = (_a = scale3[channel]) === null || _a === void 0 ? void 0 : _a.domain;
  const [T] = columnOf(encode, channel);
  const normalizeReducer2 = createReducer(channel, rest, encode);
  const SI = filterIndex(I, T, domain);
  const sortedDomain = groupSort(SI, normalizeReducer2, (i) => T[i]);
  if (reverse2)
    sortedDomain.reverse();
  const s2 = typeof slice3 === "number" ? [0, slice3] : slice3;
  const slicedDomain = slice3 ? sortedDomain.slice(...s2) : sortedDomain;
  return [
    I,
    deep_mix_default(mark2, {
      scale: {
        [channel]: {
          domain: slicedDomain
        }
      }
    })
  ];
}
var Sort = (options = {}) => {
  const { reverse: reverse2 = false, slice: slice3, channel, ordinal = true } = options, rest = __rest10(options, ["reverse", "slice", "channel", "ordinal"]);
  return (I, mark2) => {
    if (!ordinal) {
      return sortQuantitative(I, mark2, Object.assign({
        reverse: reverse2,
        slice: slice3,
        channel
      }, rest));
    }
    return sortOrdinal(I, mark2, Object.assign({ reverse: reverse2, slice: slice3, channel }, rest));
  };
};
Sort.props = {};

// node_modules/@antv/g2/esm/transform/sortX.js
var SortX = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
};
SortX.props = {};

// node_modules/@antv/g2/esm/transform/sortColor.js
var SortColor = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
};
SortColor.props = {};

// node_modules/@antv/g2/esm/transform/sortY.js
var SortY = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
};
SortY.props = {};

// node_modules/@antv/g2/esm/transform/flexX.js
function valueOf(data, field3) {
  if (typeof field3 === "string")
    return data.map((d2) => d2[field3]);
  return data.map(field3);
}
function createReducer2(reducer, V) {
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  throw new Error(`Unknown reducer: ${reducer}`);
}
var FlexX = (options = {}) => {
  const { field: field3, channel = "y", reducer = "sum" } = options;
  return (I, mark2) => {
    const { data, encode } = mark2;
    const [x2] = columnOf(encode, "x");
    const V = field3 ? valueOf(data, field3) : columnOf(encode, channel)[0];
    const reducerFunction = createReducer2(reducer, V);
    const flex = rollups(I, reducerFunction, (i) => x2[i]).map((d2) => d2[1]);
    return [I, deep_mix_default({}, mark2, { scale: { x: { flex } } })];
  };
};
FlexX.props = {};

// node_modules/@antv/g2/esm/utils/vector.js
function sub([x12, y12], [x2, y2]) {
  return [x12 - x2, y12 - y2];
}
function add([x12, y12], [x2, y2]) {
  return [x12 + x2, y12 + y2];
}
function dist([x05, y05], [x12, y12]) {
  return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
}
function angle([x2, y2]) {
  return Math.atan2(y2, x2);
}
function angleWithQuadrant([x2, y2]) {
  return angle([x2, y2]) + Math.PI / 2;
}
function angleBetween(v0, v1) {
  const a0 = angle(v0);
  const a1 = angle(v1);
  if (a0 < a1)
    return a1 - a0;
  return Math.PI * 2 - (a0 - a1);
}
function calcBBox(points) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY2 = -Infinity;
  for (const [x2, y2] of points) {
    minX = Math.min(x2, minX);
    maxX = Math.max(x2, maxX);
    minY = Math.min(y2, minY);
    maxY2 = Math.max(y2, maxY2);
  }
  const width = maxX - minX;
  const height = maxY2 - minY;
  return [minX, minY, width, height];
}
function mid([x12, y12], [x2, y2]) {
  return [(x12 + x2) / 2, (y12 + y2) / 2];
}

// node_modules/@antv/g2/esm/transform/pack.js
function pack(options) {
  const { padding = 0, direction = "col" } = options;
  return (P, count4, layout) => {
    const pcount = P.length;
    if (pcount === 0)
      return [];
    const { innerWidth, innerHeight } = layout;
    const aspect = innerHeight / innerWidth;
    let col = Math.ceil(Math.sqrt(count4 / aspect));
    let size3 = innerWidth / col;
    let row = Math.ceil(count4 / col);
    let h0 = row * size3;
    while (h0 > innerHeight) {
      col = col + 1;
      size3 = innerWidth / col;
      row = Math.ceil(count4 / col);
      h0 = row * size3;
    }
    const space = innerHeight - row * size3;
    const intervalY = row <= 1 ? 0 : space / (row - 1);
    const [offsetX, offsetY] = row <= 1 ? [
      (innerWidth - pcount * size3) / (pcount - 1),
      (innerHeight - size3) / 2
    ] : [0, 0];
    return P.map((points, m2) => {
      const [x2, y2, width, height] = calcBBox(points);
      const i = direction === "col" ? m2 % col : Math.floor(m2 / row);
      const j = direction === "col" ? Math.floor(m2 / col) : m2 % row;
      const newX = i * size3;
      const newY = (row - j - 1) * size3 + space;
      const sx = (size3 - padding) / width;
      const sy = (size3 - padding) / height;
      const tx = newX - x2 + offsetX * i + 1 / 2 * padding;
      const ty = newY - y2 - intervalY * j - offsetY + 1 / 2 * padding;
      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
    });
  };
}
var Pack = (options) => {
  return (I, mark2) => {
    return [I, deep_mix_default({}, mark2, { modifier: pack(options), axis: false })];
  };
};
Pack.props = {};

// node_modules/@antv/g2/esm/transform/bin.js
var __rest11 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var THRESHOLD = "thresholds";
function thresholdAuto(values3) {
  const [min6, max6] = extent(values3);
  return Math.min(200, thresholdScott(values3, min6, max6));
}
var Bin = (options = {}) => {
  const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest11(options, ["groupChannels", "binChannels"]);
  const channelIndexKey = {};
  const groupBy2 = (I, mark2) => {
    const { encode } = mark2;
    const binValues = binChannels.map((channel) => {
      const [V] = columnOf(encode, channel);
      return V;
    });
    const thresholds = subObject(rest, THRESHOLD);
    const DI = I.filter((i) => binValues.every((V) => defined(V[i])));
    const groupKeys = [
      // For discrete channels, use value as group key.
      ...groupChannels.map((d2) => {
        const [V] = columnOf(encode, d2);
        return V;
      }).filter(defined).map((V) => (i) => V[i]),
      // For quantitative channels, use extent of bin as group key.
      ...binChannels.map((d2, i) => {
        const V = binValues[i];
        const t = thresholds[d2] || thresholdAuto(V);
        const bins = bin().thresholds(t).value((i2) => +V[i2])(DI);
        const indexKey = new Map(bins.flatMap((bin2) => {
          const { x0: x05, x1: x12 } = bin2;
          const key2 = `${x05},${x12}`;
          return bin2.map((i2) => [i2, key2]);
        }));
        channelIndexKey[d2] = indexKey;
        return (i2) => indexKey.get(i2);
      })
    ];
    const key = (i) => groupKeys.map((key2) => key2(i)).join("-");
    return Array.from(group(DI, key).values());
  };
  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k2]) => !k2.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
    const start = ([i]) => +channelIndexKey[channel].get(i).split(",")[0];
    const end = ([i]) => +channelIndexKey[channel].get(i).split(",")[1];
    end.from = channel;
    return [
      [channel, start],
      [`${channel}1`, end]
    ];
  }))), { groupBy: groupBy2 }));
};
Bin.props = {};

// node_modules/@antv/g2/esm/transform/binX.js
var BinX = (options = {}) => {
  const { thresholds } = options;
  return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
};
BinX.props = {};

// node_modules/@antv/g2/esm/transform/utils/lttb.js
function lttb(I, X, Y, thresholds) {
  const length = I.length;
  if (thresholds >= length || thresholds === 0) {
    return I;
  }
  const x2 = (i) => X[I[i]] * 1;
  const y2 = (i) => Y[I[i]] * 1;
  const sampled = [];
  const every2 = (length - 2) / (thresholds - 2);
  let a3 = 0;
  let maxArea;
  let area2;
  let nextA;
  sampled.push(a3);
  for (let i = 0; i < thresholds - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let start = Math.floor((i + 1) * every2) + 1;
    let end = Math.floor((i + 2) * every2) + 1;
    end = Math.min(end, length);
    const size3 = end - start;
    for (; start < end; start++) {
      avgX += x2(start);
      avgY += y2(start);
    }
    avgX /= size3;
    avgY /= size3;
    let frameStart = Math.floor((i + 0) * every2) + 1;
    const frameEnd = Math.floor((i + 1) * every2) + 1;
    const pointA = [x2(a3), y2(a3)];
    maxArea = area2 = -1;
    for (; frameStart < frameEnd; frameStart++) {
      area2 = Math.abs((pointA[0] - avgX) * (x2(frameStart) - pointA[1]) - (pointA[0] - y2(frameStart)) * (avgY - pointA[0])) * 0.5;
      if (area2 > maxArea) {
        maxArea = area2;
        nextA = frameStart;
      }
    }
    sampled.push(nextA);
    a3 = nextA;
  }
  sampled.push(length - 1);
  return sampled.map((a4) => I[a4]);
}

// node_modules/@antv/g2/esm/transform/sample.js
function normalizeSample(strategy) {
  if (typeof strategy === "function")
    return strategy;
  if (strategy === "lttb")
    return lttb;
  const strategies = {
    first: (f) => [f[0]],
    last: (f) => [f[f.length - 1]],
    min: (f, X, Y) => [
      f[minIndex(f, (i) => Y[i])]
    ],
    max: (f, X, Y) => [
      f[maxIndex(f, (i) => Y[i])]
    ],
    median: (f, X, Y) => [
      f[medianIndex(f, (i) => Y[i])]
    ]
  };
  const sampleFunction = strategies[strategy] || strategies.median;
  return (I, X, Y, thresholds) => {
    const frameSize = Math.max(1, Math.floor(I.length / thresholds));
    const frames = getFrames(I, frameSize);
    return frames.flatMap((frame) => sampleFunction(frame, X, Y));
  };
}
function getFrames(I, frameSize) {
  const size3 = I.length;
  const frames = [];
  let i = 0;
  while (i < size3) {
    frames.push(I.slice(i, i += frameSize));
  }
  return frames;
}
var Sample = (options = {}) => {
  const { strategy = "median", thresholds = 2e3, groupBy: groupBy2 = ["series", "color"] } = options;
  const sampleFunction = normalizeSample(strategy);
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy2, I, mark2);
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    return [
      groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
      mark2
    ];
  };
};
Sample.props = {};

// node_modules/@antv/g2/esm/transform/filter.js
function normalizeValue(value2) {
  if (typeof value2 === "object")
    return [value2.value, value2.ordinal];
  else
    return [value2, true];
}
function filterWhenNoElements(mark2) {
  var _a;
  const { encode } = mark2;
  const noElementMark = Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), { y: Object.assign(Object.assign({}, mark2.encode.y), { value: [] }) }) });
  const targetField = (_a = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a === void 0 ? void 0 : _a.field;
  if (!encode || !targetField) {
    return noElementMark;
  }
  let filterObject;
  for (const [key, v] of Object.entries(encode)) {
    if ((key === "x" || key === "y") && v.field === targetField) {
      filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
    }
  }
  if (!filterObject) {
    return noElementMark;
  }
  return Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), filterObject) });
}
var Filter = (options = {}) => {
  return (I, mark2) => {
    const { encode, data } = mark2;
    const filters = Object.entries(options).map(([key, v]) => {
      const [V] = columnOf(encode, key);
      if (!V)
        return null;
      const [value2, ordinal = true] = normalizeValue(v);
      if (typeof value2 === "function")
        return (i) => value2(V[i]);
      if (ordinal) {
        const expectedValues = Array.isArray(value2) ? value2 : [value2];
        if (expectedValues.length === 0)
          return null;
        return (i) => expectedValues.includes(V[i]);
      } else {
        const [start, end] = value2;
        return (i) => V[i] >= start && V[i] <= end;
      }
    }).filter(defined);
    const totalFilter = (i) => filters.every((f) => f(i));
    const FI = I.filter(totalFilter);
    const newIndex = FI.map((_, i) => i);
    if (filters.length === 0) {
      const targetMark = filterWhenNoElements(mark2);
      return [I, targetMark];
    }
    const newEncodes = Object.entries(encode).map(([key, encode2]) => {
      return [
        key,
        Object.assign(Object.assign({}, encode2), { value: newIndex.map((i) => encode2.value[FI[i]]).filter((v) => v !== void 0) })
      ];
    });
    return [
      newIndex,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newEncodes),
        // Filter data for tooltip item.
        data: FI.map((i) => data[i])
      })
    ];
  };
};
Filter.props = {};

// node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant4() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max4 = Math.max;
var min4 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path2 = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x12, y12, x2, y2) {
    this._append`Q${+x12},${+y12},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    this._append`C${+x12},${+y12},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x05 = this._x1, y05 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x2 - x05, y20 = y2 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x05 = x2 + dx, y05 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw2},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw2},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path2();
}
path.prototype = Path2.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape23) {
  let digits = 3;
  shape23.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape23;
  };
  return () => new Path2(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d2) {
  return d2.innerRadius;
}
function arcOuterRadius(d2) {
  return d2.outerRadius;
}
function arcStartAngle(d2) {
  return d2.startAngle;
}
function arcEndAngle(d2) {
  return d2.endAngle;
}
function arcPadAngle(d2) {
  return d2 && d2.padAngle;
}
function intersect(x05, y05, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y05 - y2) - y32 * (x05 - x2)) / t;
  return [x05 + t * x10, y05 + t * y10];
}
function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
  var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max4(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d2, cy0 = (-D2 * dx - dy * d3) / d2, cx1 = (D2 * dy + dx * d3) / d2, cy1 = (-D2 * dx + dy * d3) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min4(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min4(rc, (r0 - lc) / (kc - 1));
            rc1 = min4(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc) context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc) context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a3) * r, sin(a3) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear2(context);
}

// node_modules/d3-shape/src/point.js
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined3 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line3);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default(y2);
  function line3(data) {
    var i, n = (data = array_default(data)).length, d2, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined3(d2 = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d2, i, data), +y2(d2, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line3.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), line3) : x2;
  };
  line3.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), line3) : y2;
  };
  line3.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default(!!_), line3) : defined3;
  };
  line3.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line3) : curve;
  };
  line3.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line3) : context;
  };
  return line3;
}

// node_modules/d3-shape/src/area.js
function area_default(x05, y05, y12) {
  var x12 = null, defined3 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area2(data) {
    var i, j, k2, n = (data = array_default(data)).length, d2, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined3(d2 = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x05(d2, i, data), y0z[i] = +y05(d2, i, data);
        output.point(x12 ? +x12(d2, i, data) : x0z[i], y12 ? +y12(d2, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined3).curve(curve).context(context);
  }
  area2.x = function(_) {
    return arguments.length ? (x05 = typeof _ === "function" ? _ : constant_default(+_), x12 = null, area2) : x05;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x05 = typeof _ === "function" ? _ : constant_default(+_), area2) : x05;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area2) : x12;
  };
  area2.y = function(_) {
    return arguments.length ? (y05 = typeof _ === "function" ? _ : constant_default(+_), y12 = null, area2) : y05;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y05 = typeof _ === "function" ? _ : constant_default(+_), area2) : y05;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default(!!_), area2) : defined3;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a3, r) {
    this._curve.point(r * Math.sin(a3), r * -Math.cos(a3));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial2(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c4 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c4(curveRadial(_)) : c4()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a3 = area_default().curve(curveRadialLinear), c4 = a3.curve, x05 = a3.lineX0, x12 = a3.lineX1, y05 = a3.lineY0, y12 = a3.lineY1;
  a3.angle = a3.x, delete a3.x;
  a3.startAngle = a3.x0, delete a3.x0;
  a3.endAngle = a3.x1, delete a3.x1;
  a3.radius = a3.y, delete a3.y;
  a3.innerRadius = a3.y0, delete a3.y0;
  a3.outerRadius = a3.y1, delete a3.y1;
  a3.lineStartAngle = function() {
    return lineRadial(x05());
  }, delete a3.lineX0;
  a3.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a3.lineX1;
  a3.lineInnerRadius = function() {
    return lineRadial(y05());
  }, delete a3.lineY0;
  a3.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a3.lineY1;
  a3.curve = function(_) {
    return arguments.length ? c4(curveRadial(_)) : c4()._curve;
  };
  return a3;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x2) / 6, y05 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x05 = x2[0], y05 = y2[0], dx = x2[j] - x05, dy = y2[j] - y05, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x05 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y05 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t02, t12) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point4(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m2, a3 = new Array(n), b = new Array(n), r = new Array(n);
  a3[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a3[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a3[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m2 = a3[i] / b[i - 1], b[i] -= m2, r[i] -= m2 * r[i - 1];
  a3[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a3[i] = (r[i] - a3[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a3[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a3[i + 1];
  return [a3, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/@antv/g2/esm/utils/coordinate.js
function isTranspose(coordinate) {
  const { transformations } = coordinate.getOptions();
  const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
  return transposes.length % 2 !== 0;
}
function isPolar(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "polar");
}
function isRadial(coordinate) {
  const { transformations } = coordinate.getOptions();
  return (
    // distinguish radial from theta.
    transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
  );
}
function isHelix(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "helix");
}
function isParallel(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "parallel");
}
function isFisheye(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "fisheye");
}
function isRadar(coordinate) {
  return isParallel(coordinate) && isPolar(coordinate);
}
function isCircular(coordinate) {
  return isHelix(coordinate) || isPolar(coordinate);
}
function isTheta(coordinate) {
  return isPolar(coordinate) && isTranspose(coordinate);
}
function getRadius(coordinate) {
  if (isCircular(coordinate)) {
    const [width, height] = coordinate.getSize();
    const polar2 = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
    if (polar2)
      return Math.max(width, height) / 2 * polar2[4];
  }
  return 0;
}
function radiusOf(coordinate) {
  const { transformations } = coordinate.getOptions();
  const [, , , innerRadius, outerRadius] = transformations.find((d2) => d2[0] === "polar");
  return [+innerRadius, +outerRadius];
}
function angleOf(coordinate, isRadius = true) {
  const { transformations } = coordinate.getOptions();
  const [, startAngle, endAngle] = transformations.find((d2) => d2[0] === "polar");
  return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
}
function getTransformOptions(coordinate, type) {
  const { transformations } = coordinate.getOptions();
  const [, ...args] = transformations.find((d2) => d2[0] === type);
  return args;
}

// node_modules/@antv/g2/esm/utils/selection.js
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
var Selection = class _Selection {
  constructor(elements = null, data = null, parent = null, document2 = null, selections = [
    null,
    null,
    null,
    null,
    null
  ], transitions = [], updateElements = []) {
    this._elements = Array.from(elements);
    this._data = data;
    this._parent = parent;
    this._document = document2;
    this._enter = selections[0];
    this._update = selections[1];
    this._exit = selections[2];
    this._merge = selections[3];
    this._split = selections[4];
    this._transitions = transitions;
    this._facetElements = updateElements;
  }
  selectAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(elements, null, this._elements[0], this._document);
  }
  selectFacetAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
  }
  /**
   * @todo Replace with querySelector which has bug now.
   */
  select(selector) {
    const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
    return new _Selection([element], null, element, this._document);
  }
  append(node) {
    const callback = typeof node === "function" ? node : () => this.createElement(node);
    const elements = [];
    if (this._data !== null) {
      for (let i = 0; i < this._data.length; i++) {
        const d2 = this._data[i];
        const [datum, from] = Array.isArray(d2) ? d2 : [d2, null];
        const newElement = callback(datum, i);
        newElement.__data__ = datum;
        if (from !== null)
          newElement.__fromElements__ = from;
        this._parent.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, this._parent, this._document);
    } else {
      for (let i = 0; i < this._elements.length; i++) {
        const element = this._elements[i];
        const datum = element.__data__;
        const newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, elements[0], this._document);
    }
  }
  maybeAppend(id2, node, className2) {
    const element = this._elements[0];
    const child = element.getElementById(id2);
    if (child) {
      return new _Selection([child], null, this._parent, this._document);
    }
    const newChild = typeof node === "string" ? this.createElement(node) : node();
    newChild.id = id2;
    if (className2)
      newChild.className = className2;
    element.appendChild(newChild);
    return new _Selection([newChild], null, this._parent, this._document);
  }
  /**
   * Bind data to elements, and produce three selection:
   * Enter: Selection with empty elements and data to be bind to elements.
   * Update: Selection with elements to be updated.
   * Exit: Selection with elements to be removed.
   */
  data(data, id2 = (d2) => d2, groupId = () => null) {
    const enter = [];
    const update = [];
    const exit = new Set(this._elements);
    const merge2 = [];
    const split = /* @__PURE__ */ new Set();
    const keyElement = new Map(this._elements.map((d2, i) => [id2(d2.__data__, i), d2]));
    const keyUpdateElement = new Map(this._facetElements.map((d2, i) => [id2(d2.__data__, i), d2]));
    const groupKeyElements = group(this._elements, (d2) => groupId(d2.__data__));
    for (let i = 0; i < data.length; i++) {
      const datum = data[i];
      const key = id2(datum, i);
      const groupKey = groupId(datum, i);
      if (keyElement.has(key)) {
        const element = keyElement.get(key);
        element.__data__ = datum;
        element.__facet__ = false;
        update.push(element);
        exit.delete(element);
        keyElement.delete(key);
      } else if (keyUpdateElement.has(key)) {
        const element = keyUpdateElement.get(key);
        element.__data__ = datum;
        element.__facet__ = true;
        update.push(element);
        keyUpdateElement.delete(key);
      } else if (groupKeyElements.has(key)) {
        const group2 = groupKeyElements.get(key);
        merge2.push([datum, group2]);
        for (const element of group2)
          exit.delete(element);
        groupKeyElements.delete(key);
      } else if (keyElement.has(groupKey)) {
        const element = keyElement.get(groupKey);
        if (element.__toData__)
          element.__toData__.push(datum);
        else
          element.__toData__ = [datum];
        split.add(element);
        exit.delete(element);
      } else {
        enter.push(datum);
      }
    }
    const S = [
      new _Selection([], enter, this._parent, this._document),
      new _Selection(update, null, this._parent, this._document),
      new _Selection(exit, null, this._parent, this._document),
      new _Selection([], merge2, this._parent, this._document),
      new _Selection(split, null, this._parent, this._document)
    ];
    return new _Selection(this._elements, null, this._parent, this._document, S);
  }
  merge(other) {
    const elements = [...this._elements, ...other._elements];
    const transitions = [...this._transitions, ...other._transitions];
    return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
  }
  createElement(type) {
    if (this._document) {
      return this._document.createElement(type, {});
    }
    const Ctor = _Selection.registry[type];
    if (Ctor)
      return new Ctor();
    return error(`Unknown node type: ${type}`);
  }
  /**
   * Apply callback for each selection(enter, update, exit)
   * and merge them into one selection.
   */
  join(enter = (d2) => d2, update = (d2) => d2, exit = (d2) => d2.remove(), merge2 = (d2) => d2, split = (d2) => d2.remove()) {
    const newEnter = enter(this._enter);
    const newUpdate = update(this._update);
    const newExit = exit(this._exit);
    const newMerge = merge2(this._merge);
    const newSplit = split(this._split);
    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
  }
  remove() {
    for (let i = 0; i < this._elements.length; i++) {
      const transition = this._transitions[i];
      if (transition) {
        const T = Array.isArray(transition) ? transition : [transition];
        Promise.all(T.map((d2) => d2.finished)).then(() => {
          const element = this._elements[i];
          element.remove();
        });
      } else {
        const element = this._elements[i];
        element.remove();
      }
    }
    return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
  }
  each(callback) {
    for (let i = 0; i < this._elements.length; i++) {
      const element = this._elements[i];
      const datum = element.__data__;
      callback(datum, i, element);
    }
    return this;
  }
  attr(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d2, i, element) {
      if (value2 !== void 0)
        element[key] = callback(d2, i, element);
    });
  }
  style(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d2, i, element) {
      if (value2 !== void 0)
        element.style[key] = callback(d2, i, element);
    });
  }
  transition(value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    const { _transitions: T } = this;
    return this.each(function(d2, i, element) {
      T[i] = callback(d2, i, element);
    });
  }
  on(event, handler) {
    this.each(function(d2, i, element) {
      element.addEventListener(event, handler);
    });
    return this;
  }
  call(callback, ...args) {
    callback(this, ...args);
    return this;
  }
  node() {
    return this._elements[0];
  }
  nodes() {
    return this._elements;
  }
  transitions() {
    return this._transitions;
  }
  parent() {
    return this._parent;
  }
};
Selection.registry = {
  g: Group,
  rect: Rect,
  circle: Circle,
  path: Path,
  text: Text,
  ellipse: Ellipse,
  image: Image2,
  line: Line,
  polygon: Polygon,
  polyline: Polyline,
  html: HTML
};

// node_modules/@antv/g2/esm/utils/number.js
function clamp(v, lower2, upper2) {
  return Math.max(lower2, Math.min(v, upper2));
}
function prettyNumber(n, precision = 10) {
  if (typeof n !== "number")
    return n;
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(precision));
}

// node_modules/@antv/g2/esm/shape/utils.js
function applyStyle(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
function appendPolygon(path2, points) {
  points.forEach((p2, idx) => idx === 0 ? path2.moveTo(p2[0], p2[1]) : path2.lineTo(p2[0], p2[1]));
  path2.closePath();
  return path2;
}
function arrowPoints(from, to, options) {
  const { arrowSize } = options;
  const size3 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist(from, to) : arrowSize;
  const arrowAngle = Math.PI / 6;
  const angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  const arrowAngle1 = Math.PI / 2 - angle2 - arrowAngle;
  const arrow1 = [
    to[0] - size3 * Math.sin(arrowAngle1),
    to[1] - size3 * Math.cos(arrowAngle1)
  ];
  const arrowAngle2 = angle2 - arrowAngle;
  const arrow2 = [
    to[0] - size3 * Math.cos(arrowAngle2),
    to[1] - size3 * Math.sin(arrowAngle2)
  ];
  return [arrow1, arrow2];
}
function appendArc(path2, from, to, center2, radius) {
  const startAngle = angle(sub(center2, from)) + Math.PI;
  const endAngle = angle(sub(center2, to)) + Math.PI;
  path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
  return path2;
}
function computeGradient(C2, X, Y, from = "y", mode2 = "between", tpShape = false) {
  const getTheta = (from2, tpShape2) => {
    if (from2 === "y" || from2 === true) {
      if (tpShape2) {
        return 180;
      } else {
        return 90;
      }
    } else {
      if (tpShape2) {
        return 90;
      } else {
        return 0;
      }
    }
  };
  const P = from === "y" || from === true ? Y : X;
  const theta = getTheta(from, tpShape);
  const I = indexOf(P);
  const [min6, max6] = extent(I, (i) => P[i]);
  const p2 = new Linear({
    domain: [min6, max6],
    range: [0, 100]
  });
  const percentage = (i) => isNumber(P[i]) && !Number.isNaN(P[i]) ? p2.map(P[i]) : 0;
  const gradientMode = {
    // Interpolate the colors for this segment.
    between: (i) => `${C2[i]} ${percentage(i)}%`,
    // Use the color of the start point as the color for this segment.
    start: (i) => i === 0 ? `${C2[i]} ${percentage(i)}%` : `${C2[i - 1]} ${percentage(i)}%, ${C2[i]} ${percentage(i)}%`,
    // Use the color of the end point as the color for this segment.
    end: (i) => i === C2.length - 1 ? `${C2[i]} ${percentage(i)}%` : `${C2[i]} ${percentage(i)}%, ${C2[i + 1]} ${percentage(i)}%`
  };
  const gradient = I.sort((a3, b) => percentage(a3) - percentage(b)).map(gradientMode[mode2] || gradientMode["between"]).join(",");
  return `linear-gradient(${theta}deg, ${gradient})`;
}
function reorder(points) {
  const [p0, p1, p2, p3] = points;
  return [p3, p0, p1, p2];
}
function getArcObject(coordinate, points, Y) {
  const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
  const [y2, y12] = Y;
  const center2 = coordinate.getCenter();
  const a1 = angleWithQuadrant(sub(p0, center2));
  const a22 = angleWithQuadrant(sub(p1, center2));
  const a3 = a22 === a1 && y2 !== y12 ? a22 + Math.PI * 2 : a22;
  return {
    startAngle: a1,
    endAngle: a3 - a1 >= 0 ? a3 : Math.PI * 2 + a3,
    innerRadius: dist(p3, center2),
    outerRadius: dist(p0, center2)
  };
}
function toOpacityKey(options) {
  const { colorAttribute, opacityAttribute = colorAttribute } = options;
  return `${opacityAttribute}Opacity`;
}
function getTransform(coordinate, value2) {
  if (!isPolar(coordinate))
    return "";
  const center2 = coordinate.getCenter();
  const { transform: suffix } = value2;
  return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
}
function getOrigin(points) {
  if (points.length === 1)
    return points[0];
  const [[x05, y05, z0 = 0], [x2, y2, z2 = 0]] = points;
  return [(x05 + x2) / 2, (y05 + y2) / 2, (z0 + z2) / 2];
}

// node_modules/@antv/g2/esm/shape/interval/color.js
var __rest12 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function rect(document2, points, value2, coordinate, style = {}) {
  const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest12(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
  if (!isPolar(coordinate) && !isHelix(coordinate)) {
    const tpShape = !!isTranspose(coordinate);
    const [p0, , p2] = tpShape ? reorder(points) : points;
    const [x2, y3] = p0;
    const [width, height] = sub(p2, p0);
    const absX = width > 0 ? x2 : x2 + width;
    const absY = height > 0 ? y3 : y3 + height;
    const absWidth = Math.abs(width);
    const absHeight = Math.abs(height);
    const finalX = absX + insetLeft;
    const finalY = absY + insetTop;
    const finalWidth = absWidth - (insetLeft + insetRight);
    const finalHeight = absHeight - (insetTop + insetBottom);
    const clampWidth = tpShape ? clamp(finalWidth, minHeight, Infinity) : clamp(finalWidth, minWidth, maxWidth);
    const clampHeight = tpShape ? clamp(finalHeight, minWidth, maxWidth) : clamp(finalHeight, minHeight, Infinity);
    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
    return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]).call(applyStyle, rest).node();
  }
  const { y: y2, y1: y12 } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y2, y12]);
  const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
  return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
}
var Color = (options, context) => {
  const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last5 = true } = options, style = __rest12(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults4, restDefaults = __rest12(defaults4, ["color", "radius"]);
    const defaultLineWidth = restDefaults.lineWidth || 1;
    const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest12(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
    const { color: color2 = defaultColor, opacity } = value2;
    const standardDirRadius = [
      first3 ? radiusTopLeft : innerRadiusTopLeft,
      first3 ? radiusTopRight : innerRadiusTopRight,
      last5 ? radiusBottomRight : innerRadiusBottomRight,
      last5 ? radiusBottomLeft : innerRadiusBottomLeft
    ];
    const standardDir = [
      "radiusTopLeft",
      "radiusTopRight",
      "radiusBottomRight",
      "radiusBottomLeft"
    ];
    if (isTranspose(coordinate)) {
      standardDir.push(standardDir.shift());
    }
    const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d2, i) => [d2, standardDirRadius[i]]))), {
      inset,
      insetLeft,
      insetRight,
      insetBottom,
      insetTop,
      minWidth,
      maxWidth,
      minHeight
    });
    return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color2).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color2 : stroke2).call(applyStyle, rest).node();
  };
};
Color.props = {
  defaultEnterAnimation: "scaleInY",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/interval/rect.js
var Rect2 = (options, context) => {
  return Color(Object.assign({ colorAttribute: "fill" }, options), context);
};
Rect2.props = Object.assign(Object.assign({}, Color.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/interval/hollow.js
var Hollow = (options, context) => {
  return Color(Object.assign({ colorAttribute: "stroke" }, options), context);
};
Hollow.props = Object.assign(Object.assign({}, Color.props), { defaultMarker: "hollowSquare" });

// node_modules/@antv/g2/esm/shape/interval/funnel.js
var __rest13 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getFunnelPoints(points, nextPoints, coordinate) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
    const newP22 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
  const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];
  return [p0, newP1, newP2, p3];
}
var Funnel = (options, context) => {
  const { adjustPoints = getFunnelPoints } = options, style = __rest13(options, ["adjustPoints"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4, point2d) => {
    const { index: index2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest13(defaults4, ["color"]);
    const nextPoints = point2d[index2 + 1];
    const funnelPoints = adjustPoints(points, nextPoints, coordinate);
    const tpShape = !!isTranspose(coordinate);
    const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
    const { color: color2 = defaultColor, opacity } = value2;
    const b = line_default().curve(linearClosed_default)([p0, p1, p2, p3]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color2).style("fillOpacity", opacity).call(applyStyle, style).node();
  };
};
Funnel.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/shape/interval/pyramid.js
function getPyramidPoints(points, nextPoints, coordinate) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [
      nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,
      p1[1]
    ];
    const newP22 = [
      nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,
      p2[1]
    ];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [
    p1[0],
    nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2
  ];
  const newP2 = [
    p2[0],
    nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2
  ];
  return [p0, newP1, newP2, p3];
}
var Pyramid = (options, context) => {
  return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
};
Pyramid.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/utils/createElement.js
function createElement(descriptor) {
  const render2 = typeof descriptor === "function" ? descriptor : descriptor.render;
  return class extends CustomElement {
    connectedCallback() {
      this.draw();
    }
    attributeChangedCallback() {
      this.draw();
    }
    draw() {
      render2(this);
    }
  };
}

// node_modules/@antv/g2/esm/shape/line/curve.js
var __rest14 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DoublePath = createElement((g) => {
  const { d1, d2, style1, style2 } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
  select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d2).call(applyStyle, style2);
});
function segmentation(points, defined3) {
  const definedPoints = [];
  const segments = [];
  let m2 = false;
  let dp = null;
  for (const p2 of points) {
    if (!defined3(p2[0]) || !defined3(p2[1]))
      m2 = true;
    else {
      definedPoints.push(p2);
      if (m2) {
        m2 = false;
        segments.push([dp, p2]);
      }
      dp = p2;
    }
  }
  return [definedPoints, segments];
}
var Curve = (options, context) => {
  const {
    curve,
    gradient = false,
    // The color for each segment.
    gradientColor = "between",
    defined: defined3 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null,
    connect: connectNulls = false
  } = options, style = __rest14(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor, lineWidth: defaultSize } = defaults4, rest = __rest14(defaults4, ["color", "lineWidth"]);
    const { color: color2 = defaultColor, size: size3 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const transform = getTransform(coordinate, value2);
    const tpShape = isTranspose(coordinate);
    const stroke2 = gradient && sc ? computeGradient(sc, sx, sy, gradient, gradientColor, tpShape) : color2;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size3 && { lineWidth: size3 }), transform && { transform }), style);
    let linePath;
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      linePath = (points) => lineRadial_default().angle((_, idx) => angleWithQuadrant(sub(points[idx], center2))).radius((_, idx) => dist(points[idx], center2)).defined(([x2, y2]) => defined3(x2) && defined3(y2)).curve(curve)(points);
    } else {
      linePath = line_default().x((d2) => d2[0]).y((d2) => d2[1]).defined(([x2, y2]) => defined3(x2) && defined3(y2)).curve(curve);
    }
    const [DP, MS] = segmentation(P, defined3);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    if (!missing || connectNulls && !Object.keys(connectStyle).length) {
      return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
    }
    if (missing && !connectNulls) {
      return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
    }
    const connectPath = (segments) => segments.map(linePath).join(",");
    return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
  };
};
Curve.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/line/line.js
var Line2 = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve(Object.assign({ curve }, options), context)(...params);
  };
};
Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/shape/line/smooth.js
var __rest15 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth = (options, context) => {
  const rest = __rest15(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/line/hv.js
var HV = (options, context) => {
  return Curve(Object.assign({ curve: stepAfter }, options), context);
};
HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/line/vh.js
var VH = (options, context) => {
  return Curve(Object.assign({ curve: stepBefore }, options), context);
};
VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/line/hvh.js
var HVH = (options, context) => {
  return Curve(Object.assign({ curve: step_default }, options), context);
};
HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/line/trail.js
var __rest16 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function stroke(path2, p0, p1, s0, s1) {
  const v = sub(p1, p0);
  const a3 = angle(v);
  const a1 = a3 + Math.PI / 2;
  const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
  const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
  const r3 = [s1 / 2 * Math.cos(a3), s1 / 2 * Math.sin(a3)];
  const r4 = [s0 / 2 * Math.cos(a3), s0 / 2 * Math.sin(a3)];
  const x05 = add(p0, r1);
  const x12 = add(p1, r2);
  const x2 = add(x12, r3);
  const x3 = add(p1, r3);
  const x4 = sub(x3, r2);
  const x5 = sub(p1, r2);
  const x6 = sub(p0, r1);
  const x7 = sub(x6, r4);
  const x8 = sub(p0, r4);
  const x9 = sub(x05, r4);
  path2.moveTo(...x05);
  path2.lineTo(...x12);
  path2.arcTo(...x2, ...x3, s1 / 2);
  path2.arcTo(...x4, ...x5, s1 / 2);
  path2.lineTo(...x6);
  path2.arcTo(...x7, ...x8, s0 / 2);
  path2.arcTo(...x9, ...x05, s0 / 2);
  path2.closePath();
}
var Trail = (options, context) => {
  const { document: document2 } = context;
  return (P, value2, defaults4) => {
    const { seriesSize, color: color2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest16(defaults4, ["color"]);
    const path2 = path();
    for (let i = 0; i < P.length - 1; i++) {
      const p0 = P[i];
      const p1 = P[i + 1];
      const s0 = seriesSize[i];
      const s1 = seriesSize[i + 1];
      if ([...p0, ...p1].every(defined))
        stroke(path2, p0, p1, s0, s1);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color2 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
  };
};
Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/utils/marker.js
var __rest17 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var point5 = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2],
    ["A", r, r, 0, 1, 0, x2 + r, y2],
    ["A", r, r, 0, 1, 0, x2 - r, y2],
    ["Z"]
  ];
};
point5.style = ["fill"];
var hollowPoint = point5.bind(void 0);
hollowPoint.style = ["stroke", "lineWidth"];
var square = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2 - r],
    ["L", x2 + r, y2 - r],
    ["L", x2 + r, y2 + r],
    ["L", x2 - r, y2 + r],
    ["Z"]
  ];
};
square.style = ["fill"];
var rect2 = square.bind(void 0);
rect2.style = ["fill"];
var hollowSquare = square.bind(void 0);
hollowSquare.style = ["stroke", "lineWidth"];
var diamond = (x2, y2, r) => {
  const hr = r * 0.618;
  return [
    ["M", x2 - hr, y2],
    ["L", x2, y2 - r],
    ["L", x2 + hr, y2],
    ["L", x2, y2 + r],
    ["Z"]
  ];
};
diamond.style = ["fill"];
var hollowDiamond = diamond.bind(void 0);
hollowDiamond.style = ["stroke", "lineWidth"];
var triangle = (x2, y2, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x2 - r, y2 + diffY],
    ["L", x2, y2 - diffY],
    ["L", x2 + r, y2 + diffY],
    ["Z"]
  ];
};
triangle.style = ["fill"];
var hollowTriangle = triangle.bind(void 0);
hollowTriangle.style = ["stroke", "lineWidth"];
var triangleDown = (x2, y2, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x2 - r, y2 - diffY],
    ["L", x2 + r, y2 - diffY],
    ["L", x2, y2 + diffY],
    ["Z"]
  ];
};
triangleDown.style = ["fill"];
var hollowTriangleDown = triangleDown.bind(void 0);
hollowTriangleDown.style = ["stroke", "lineWidth"];
var hexagon = (x2, y2, r) => {
  const diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x2, y2 - r],
    ["L", x2 + diffX, y2 - r / 2],
    ["L", x2 + diffX, y2 + r / 2],
    ["L", x2, y2 + r],
    ["L", x2 - diffX, y2 + r / 2],
    ["L", x2 - diffX, y2 - r / 2],
    ["Z"]
  ];
};
hexagon.style = ["fill"];
var hollowHexagon = hexagon.bind(void 0);
hollowHexagon.style = ["stroke", "lineWidth"];
var bowtie = (x2, y2, r) => {
  const diffY = r - 1.5;
  return [
    ["M", x2 - r, y2 - diffY],
    ["L", x2 + r, y2 + diffY],
    ["L", x2 + r, y2 - diffY],
    ["L", x2 - r, y2 + diffY],
    ["Z"]
  ];
};
bowtie.style = ["fill"];
var hollowBowtie = bowtie.bind(void 0);
hollowBowtie.style = ["stroke", "lineWidth"];
var line = (x2, y2, r) => {
  return [
    ["M", x2, y2 + r],
    ["L", x2, y2 - r]
  ];
};
line.style = ["stroke", "lineWidth"];
var cross2 = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2 - r],
    ["L", x2 + r, y2 + r],
    ["M", x2 + r, y2 - r],
    ["L", x2 - r, y2 + r]
  ];
};
cross2.style = ["stroke", "lineWidth"];
var tick = (x2, y2, r) => {
  return [
    ["M", x2 - r / 2, y2 - r],
    ["L", x2 + r / 2, y2 - r],
    ["M", x2, y2 - r],
    ["L", x2, y2 + r],
    ["M", x2 - r / 2, y2 + r],
    ["L", x2 + r / 2, y2 + r]
  ];
};
tick.style = ["stroke", "lineWidth"];
var plus = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2],
    ["L", x2 + r, y2],
    ["M", x2, y2 - r],
    ["L", x2, y2 + r]
  ];
};
plus.style = ["stroke", "lineWidth"];
var hyphen = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2],
    ["L", x2 + r, y2]
  ];
};
hyphen.style = ["stroke", "lineWidth"];
var dot = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2],
    ["L", x2 + r, y2]
  ];
};
dot.style = ["stroke", "lineWidth"];
var dash = dot.bind(void 0);
dash.style = ["stroke", "lineWidth"];
var smooth = (x2, y2, r) => {
  return [
    ["M", x2 - r, y2],
    ["A", r / 2, r / 2, 0, 1, 1, x2, y2],
    ["A", r / 2, r / 2, 0, 1, 0, x2 + r, y2]
  ];
};
smooth.style = ["stroke", "lineWidth"];
var hv = (x2, y2, r) => {
  return [
    ["M", x2 - r - 1, y2 - 2.5],
    ["L", x2, y2 - 2.5],
    ["L", x2, y2 + 2.5],
    ["L", x2 + r + 1, y2 + 2.5]
  ];
};
hv.style = ["stroke", "lineWidth"];
var vh = (x2, y2, r) => {
  return [
    ["M", x2 - r - 1, y2 + 2.5],
    ["L", x2, y2 + 2.5],
    ["L", x2, y2 - 2.5],
    ["L", x2 + r + 1, y2 - 2.5]
  ];
};
vh.style = ["stroke", "lineWidth"];
var hvh = (x2, y2, r) => {
  return [
    ["M", x2 - (r + 1), y2 + 2.5],
    ["L", x2 - r / 2, y2 + 2.5],
    ["L", x2 - r / 2, y2 - 2.5],
    ["L", x2 + r / 2, y2 - 2.5],
    ["L", x2 + r / 2, y2 + 2.5],
    ["L", x2 + r + 1, y2 + 2.5]
  ];
};
hvh.style = ["stroke", "lineWidth"];
var vhv = (x2, y2, r) => {
  return [
    ["M", x2 - 5, y2 + 2.5],
    ["L", x2 - 5, y2],
    ["L", x2, y2],
    ["L", x2, y2 - 3],
    ["L", x2, y2 + 3],
    ["L", x2 + 6.5, y2 + 3]
  ];
};
vhv.style = ["stroke", "lineWidth"];
var Symbols = /* @__PURE__ */ new Map([
  ["bowtie", bowtie],
  ["cross", cross2],
  ["dash", dash],
  ["diamond", diamond],
  ["dot", dot],
  ["hexagon", hexagon],
  ["hollowBowtie", hollowBowtie],
  ["hollowDiamond", hollowDiamond],
  ["hollowHexagon", hollowHexagon],
  ["hollowPoint", hollowPoint],
  ["hollowSquare", hollowSquare],
  ["hollowTriangle", hollowTriangle],
  ["hollowTriangleDown", hollowTriangleDown],
  ["hv", hv],
  ["hvh", hvh],
  ["hyphen", hyphen],
  ["line", line],
  ["plus", plus],
  ["point", point5],
  ["rect", rect2],
  ["smooth", smooth],
  ["square", square],
  ["tick", tick],
  ["triangleDown", triangleDown],
  ["triangle", triangle],
  ["vh", vh],
  ["vhv", vhv]
]);
function useMarker(type, _a) {
  var { d: d2, fill, lineWidth, path: path2, stroke: stroke2, color: color2 } = _a, style = __rest17(_a, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
  const symbol = Symbols.get(type) || Symbols.get("point");
  return (...args) => {
    const path3 = new Path({
      style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color2 || stroke2 : "", fill: symbol.style.includes("fill") ? color2 || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
    });
    return path3;
  };
}
function registerSymbol(type, marker) {
  Symbols.set(type, marker);
}

// node_modules/@antv/g2/esm/shape/point/color.js
var __rest18 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getRadius2(mode2, points, value2, coordinate) {
  if (points.length === 1)
    return void 0;
  const { size: size3 } = value2;
  if (mode2 === "fixed")
    return size3;
  if (mode2 === "normal" || isFisheye(coordinate)) {
    const [[x05, y05], [x2, y2]] = points;
    const a3 = Math.abs((x2 - x05) / 2);
    const b = Math.abs((y2 - y05) / 2);
    return Math.max(0, (a3 + b) / 2);
  }
  return size3;
}
var Color2 = (options, context) => {
  const { colorAttribute, symbol, mode: mode2 = "auto" } = options, style = __rest18(options, ["colorAttribute", "symbol", "mode"]);
  const path2 = Symbols.get(symbol) || Symbols.get("point");
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color2 = defaultColor, transform, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r || style.r || defaults4.r;
    return select(document2.createElement("path", {})).call(applyStyle, defaults4).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
  };
};
Color2.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
var HollowBowtie = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
};
HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
var HollowDiamond = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
};
HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
var HollowHexagon = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
};
HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollow.js
var HollowPoint = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
};
HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowSquare.js
var HollowSquare = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
};
HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
var HollowTriangle = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
};
HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
var HollowTriangleDown = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
};
HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/circle.js
var __rest19 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var BaseCircle = (options, context) => {
  const { colorAttribute, mode: mode2 = "auto" } = options, style = __rest19(options, ["colorAttribute", "mode"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color2 = defaultColor, transform, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r || style.r || defaults4.r;
    return select(document2.createElement("circle", {})).call(applyStyle, defaults4).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx} ${cy}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
  };
};
var Circle2 = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
};
Circle2.props = {
  defaultMarker: "circle",
  defaultEnterAnimation: "fadeIn",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowCircle.js
var HollowCircle = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
};
HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

// node_modules/@antv/g2/esm/shape/point/bowtie.js
var Bowtie = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
};
Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/cross.js
var Cross = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
};
Cross.props = Object.assign({ defaultMarker: "cross" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/diamond.js
var Diamond = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
};
Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hexagon.js
var Hexagon = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
};
Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hyphen.js
var Hyphen = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
};
Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/line.js
var Line3 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
};
Line3.props = Object.assign({ defaultMarker: "line" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/plus.js
var Plus = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
};
Plus.props = Object.assign({ defaultMarker: "plus" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/point.js
var Point2 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
};
Point2.props = Object.assign({ defaultMarker: "point" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/square.js
var Square = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
};
Square.props = Object.assign({ defaultMarker: "square" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/tick.js
var Tick = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
};
Tick.props = Object.assign({ defaultMarker: "tick" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/triangle.js
var Triangle = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
};
Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/triangleDown.js
var TriangleDown = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
};
TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color2.props);

// node_modules/@antv/g2/esm/shape/vector/vector.js
var __rest20 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Vector = (options, context) => {
  const { arrow = true, arrowSize = "40%" } = options, style = __rest20(options, ["arrow", "arrowSize"]);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest20(defaults4, ["defaultColor"]);
    const { color: color2 = defaultColor, transform } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(...from);
    path2.lineTo(...to);
    if (arrow) {
      const [arrow1, arrow2] = arrowPoints(from, to, { arrowSize });
      path2.moveTo(...arrow1);
      path2.lineTo(...to);
      path2.lineTo(...arrow2);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
  };
};
Vector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/advance.js
var __rest21 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getConnectorPoint(shape23) {
  const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
  let x2 = 0;
  let y2 = 0;
  if (x05 > 0)
    x2 = x05;
  if (x12 < 0)
    x2 = x12;
  if (y05 > 0)
    y2 = y05;
  if (y12 < 0)
    y2 = y12;
  return [x2, y2];
}
function inferBackgroundBounds(textShape, padding = []) {
  const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
  const container = textShape.parentNode;
  const angle2 = container.getEulerAngles();
  container.setEulerAngles(0);
  const { min: min6, halfExtents } = textShape.getLocalBounds();
  const [x2, y2] = min6;
  const [hw, hh] = halfExtents;
  container.setEulerAngles(angle2);
  return {
    x: x2 - left2,
    y: y2 - top,
    width: hw * 2 + left2 + right2,
    height: hh * 2 + top + bottom
  };
}
function inferConnectorPath(shape23, end, control, coordCenter, left2 = true, top = true) {
  const path2 = (points) => line_default()(points);
  if (!end[0] && !end[1])
    return path2([getConnectorPoint(shape23), end]);
  if (!control.length)
    return path2([[0, 0], end]);
  const [inflection, start] = control;
  const p1 = [...start];
  const p2 = [...inflection];
  if (start[0] !== inflection[0]) {
    const offset = left2 ? -4 : 4;
    p1[1] = start[1];
    if (top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset);
      if (start[1] < inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.max(p2[0], p1[0] - offset);
      }
    }
    if (!top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset);
      if (start[1] > inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.max(p2[0], p1[0] - offset);
      }
    }
    if (!top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset);
      if (start[1] > inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.min(p2[0], p1[0] - offset);
      }
    }
    if (top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset);
      if (start[1] < inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.min(p2[0], p1[0] - offset);
      }
    }
  }
  return path2([start, p1, p2, inflection, end]);
}
var Advance = createElement((g) => {
  const _a = g.attributes, {
    className: className2,
    // Do not pass className
    class: _c,
    transform,
    rotate: rotate2,
    labelTransform,
    labelTransformOrigin,
    x: x2,
    y: y2,
    x0: x05 = x2,
    y0: y05 = y2,
    text,
    background,
    connector,
    startMarker,
    endMarker,
    coordCenter,
    innerHTML
  } = _a, rest = __rest21(_a, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
  g.style.transform = `translate(${x2}, ${y2})`;
  if ([x2, y2, x05, y05].some((v) => !isNumber(v))) {
    g.children.forEach((d2) => d2.remove());
    return;
  }
  const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest21(_b, ["padding"]);
  const _d = subObject(rest, "connector"), { points: controlPoints2 = [] } = _d, connectorStyle = __rest21(_d, ["points"]);
  let textShape;
  if (innerHTML) {
    textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  } else {
    textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  }
  const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
  const left2 = +x05 < coordCenter[0];
  const top = +y05 < coordCenter[1];
  const end = [+x05 - +x2, +y05 - +y2];
  const connectorPath = inferConnectorPath(rect4, end, controlPoints2, coordCenter, left2, top);
  const markerStart = startMarker && new Marker({
    id: "startMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
  });
  const markerEnd = endMarker && new Marker({
    id: "endMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
  });
  select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
});

// node_modules/@antv/g2/esm/shape/text/text.js
var Text2 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color2, text = "", fontSize, rotate: rotate2 = 0, transform = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color2,
      fill: color2,
      fontSize
    };
    const [[x05, y05]] = points;
    return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transform", `${transform}rotate(${+rotate2})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
  };
};
Text2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/badge.js
var __rest22 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath(r) {
  const offset = r / Math.sqrt(2);
  const dy = r * Math.sqrt(2);
  const [p0x, p0y] = [-offset, offset - dy];
  const [p1x, p1y] = [0, 0];
  const [p2x, p2y] = [offset, offset - dy];
  return [
    ["M", p0x, p0y],
    ["A", r, r, 0, 1, 1, p2x, p2y],
    ["L", p1x, p1y],
    ["Z"]
  ];
}
function inferTextPosition(shape23) {
  const { min: min6, max: max6 } = shape23.getLocalBounds();
  return [(min6[0] + max6[0]) * 0.5, (min6[1] + max6[1]) * 0.5];
}
var BadgeShape = createElement((g) => {
  const _a = g.attributes, { class: className2, x: x05, y: y05, transform } = _a, rest = __rest22(_a, ["class", "x", "y", "transform"]);
  const markerStyle = subObject(rest, "marker");
  const { size: size3 = 24 } = markerStyle;
  const symbol = () => getPath(size3 / 2);
  const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
  const [x2, y2] = inferTextPosition(bgShape);
  select(g).maybeAppend("text", "text").style("x", x2).style("y", y2).call(applyStyle, rest);
});
var Badge = (options, context) => {
  const style = __rest22(options, []);
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest22(defaults4, ["color"]);
    const { color: color2 = defaultColor, text = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color2,
      fill: color2
    };
    const [[x05, y05]] = points;
    return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
  };
};
Badge.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/tag.js
var Tag = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color2, text = "", fontSize, rotate: rotate2 = 0, transform = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color2,
      fill: color2,
      fontSize,
      textAlign: "center",
      textBaseline: "middle"
    };
    const [[x05, y05]] = points;
    const n = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transformOrigin", "center center").style("transform", `${transform}rotate(${rotate2}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    return n;
  };
};
Tag.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/curve.js
var __rest23 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function segmentation2(points, defined3) {
  const definedPointsY1 = [];
  const definedPointsY0 = [];
  const segments = [];
  let m2 = false;
  let dp = null;
  const mid2 = points.length / 2;
  for (let i = 0; i < mid2; i++) {
    const y12 = points[i];
    const y05 = points[i + mid2];
    if ([...y12, ...y05].some((v) => !defined3(v)))
      m2 = true;
    else {
      definedPointsY1.push(y12);
      definedPointsY0.push(y05);
      if (m2 && dp) {
        m2 = false;
        const [dpy1, dpy0] = dp;
        segments.push([dpy1, y12, dpy0, y05]);
      }
      dp = [y12, y05];
    }
  }
  return [definedPointsY1.concat(definedPointsY0), segments];
}
var DoubleArea = createElement((g) => {
  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
  select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
});
var Curve2 = (options, context) => {
  const { curve, gradient = false, defined: defined3 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null, connect: connectNulls = false } = options, style = __rest23(options, ["curve", "gradient", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor } = defaults4;
    const { color: color2 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const tpShape = isTranspose(coordinate);
    const transform = getTransform(coordinate, value2);
    const fill = gradient && sc ? computeGradient(sc, sx, sy, gradient, void 0, tpShape) : color2;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults4), { stroke: fill, fill }), transform && { transform }), style);
    const [DP, MS] = segmentation2(P, defined3);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    const getPathNode = (path2) => {
      return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
    };
    if (!isPolar(coordinate)) {
      const areaPath = (points) => {
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return tpShape ? area_default().y((_, idx) => Y12[idx][1]).x1((_, idx) => Y12[idx][0]).x0((_, idx) => Y02[idx][0]).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y12) : area_default().x((_, idx) => Y12[idx][0]).y1((_, idx) => Y12[idx][1]).y0((_, idx) => Y02[idx][1]).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y12);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
    } else {
      const areaRadialPath = (points) => {
        const center2 = coordinate.getCenter();
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return areaRadial_default().angle((_, idx) => angleWithQuadrant(sub(Y12[idx], center2))).outerRadius((_, idx) => dist(Y12[idx], center2)).innerRadius((_, idx) => dist(Y02[idx], center2)).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y02);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaRadialPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaRadialPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
    }
  };
};
Curve2.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/area.js
var Area = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve2(Object.assign({ curve }, options), context)(...params);
  };
};
Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/area/smooth.js
var __rest24 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth2 = (options, context) => {
  const rest = __rest24(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve2(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/area/hvh.js
var HVH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
  };
};
HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/area/vh.js
var VH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
  };
};
VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/area/hv.js
var HV2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
  };
};
HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/link/link.js
var Link = (options, context) => {
  const { arrow = false } = options;
  return (...params) => {
    return Vector(Object.assign(Object.assign({}, options), { arrow }), context)(...params);
  };
};
Link.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/smooth.js
var __rest25 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth3 = (options, context) => {
  const style = __rest25(options, []);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest25(defaults4, ["color"]);
    const { color: color2 = defaultColor, transform } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
  };
};
Smooth3.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/vhv.js
var __rest26 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getVHVPath(from, to, coordinate, ratio) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const a3 = dist(from, center2);
    const b = dist(to, center2);
    const radius = (b - a3) * ratio + a3;
    path2.moveTo(from[0], from[1]);
    appendArc(path2, from, to, center2, radius);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  if (isTranspose(coordinate)) {
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  path2.moveTo(from[0], from[1]);
  path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], to[1]);
  return path2;
}
var VHV = (options, context) => {
  const { cornerRatio = 1 / 3 } = options, style = __rest26(options, ["cornerRatio"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest26(defaults4, ["defaultColor"]);
    const { color: color2 = defaultColor, transform } = value2;
    const [from, to] = points;
    const path2 = getVHVPath(from, to, coordinate, cornerRatio);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
  };
};
VHV.props = {
  defaultMarker: "vhv",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/arc.js
var __rest27 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Arc = (options, context) => {
  const style = __rest27(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest27(defaults4, ["color"]);
    const { color: color2 = defaultColor, transform } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
    } else {
      const center2 = mid(from, to);
      const raduis = dist(from, to) / 2;
      appendArc(path2, from, to, center2, raduis);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
  };
};
Arc.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/mark/utils.js
function baseChannels(options = {}) {
  const { shapes } = options;
  return [
    { name: "color" },
    { name: "opacity" },
    { name: "shape", range: shapes },
    { name: "enterType" },
    { name: "enterDelay", scaleKey: "enter" },
    { name: "enterDuration", scaleKey: "enter" },
    { name: "enterEasing" },
    { name: "key", scale: "identity" },
    { name: "groupKey", scale: "identity" },
    { name: "label", scale: "identity" }
  ];
}
function baseGeometryChannels(options = {}) {
  return [...baseChannels(options), { name: "title", scale: "identity" }];
}
function tooltip2d() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["x", "y"] }
  ];
}
function tooltip1d() {
  return [
    { type: MaybeTitle, channel: "x" },
    { type: MaybeTooltip, channel: ["y"] }
  ];
}
function tooltipXd() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["position"] }
  ];
}
function baseAnnotationChannels(options = {}) {
  return baseChannels(options);
}
function basePreInference() {
  return [{ type: MaybeKey }];
}
function basePostInference() {
  return [];
}
function bandWidth(scale3, x2) {
  return scale3.getBandWidth(scale3.invert(x2));
}
function createBandOffset(scale3, value2, options = {}) {
  const { x: X, y: Y, series: S } = value2;
  const { x: x2, y: y2, series } = scale3;
  const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
  const isBandX = !!(x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth);
  const isBandY = !!(y2 === null || y2 === void 0 ? void 0 : y2.getBandWidth);
  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
  if (!isBandX && !isBandY)
    return (d2) => d2;
  return (d2, i) => {
    const widthX = isBandX ? bandWidth(x2, X[i]) : 0;
    const widthY = isBandY ? bandWidth(y2, Y[i]) : 0;
    const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
    const offset = isSeries && S ? f() : 0;
    const [x05, y05] = d2;
    return [x05 + bandOffsetX * widthX + offset, y05 + bandOffsetY * widthY];
  };
}
function p(d2) {
  return parseFloat(d2) / 100;
}
function visualMark(index2, scale3, value2, coordinate) {
  const { x: X, y: Y } = value2;
  const { innerWidth, innerHeight } = coordinate.getOptions();
  const P = Array.from(index2, (i) => {
    const x05 = X[i];
    const y05 = Y[i];
    const x2 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
    const y2 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
    return [[x2, y2]];
  });
  return [index2, P];
}
function field(encode) {
  return typeof encode === "function" ? encode : (d2) => d2[encode];
}
function valueof(data, encode) {
  return Array.from(data, field(encode));
}
function initializeData(data, encode) {
  const { source = (d2) => d2.source, target = (d2) => d2.target, value: value2 = (d2) => d2.value } = encode;
  const { links, nodes } = data;
  const LS = valueof(links, source);
  const LT = valueof(links, target);
  const LV = valueof(links, value2);
  return {
    links: links.map((_, i) => ({
      target: LT[i],
      source: LS[i],
      value: LV[i]
    })),
    nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
  };
}

// node_modules/@antv/g2/esm/shape/image/image.js
var __rest28 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Image3 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest28(defaults4, ["color"]);
    const { color: color2 = defaultColor, src = "", size: size3 = 32, transform = "" } = value2;
    let { width = size3, height = size3 } = options;
    const [[x05, y05]] = points;
    const [w, h] = coordinate.getSize();
    width = typeof width === "string" ? p(width) * w : width;
    height = typeof height === "string" ? p(height) * h : height;
    const x2 = x05 - Number(width) / 2;
    const y2 = y05 - Number(height) / 2;
    return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x2).style("y", y2).style("src", src).style("stroke", color2).style("transform", transform).call(applyStyle, options).style("width", width).style("height", height).node();
  };
};
Image3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/polygon.js
var __rest29 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPolygonPath(points, coordinate) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const closedPoints = [...points, points[0]];
    const dists = closedPoints.map((p2) => dist(p2, center2));
    closedPoints.forEach((curr, idx) => {
      if (idx === 0) {
        path2.moveTo(curr[0], curr[1]);
        return;
      }
      const currDist = dists[idx];
      const prev = points[idx - 1];
      const prevDist = dists[idx - 1];
      if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
        appendArc(path2, prev, curr, center2, currDist);
      } else {
        path2.lineTo(curr[0], curr[1]);
      }
    });
    path2.closePath();
    return path2;
  }
  return appendPolygon(path2, points);
}
var Polygon2 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest29(defaults4, ["color"]);
    const { color: color2 = defaultColor, transform } = value2;
    const path2 = getPolygonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("fill", color2).style("transform", transform).call(applyStyle, options).node();
  };
};
Polygon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/ribbon.js
var __rest30 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getRibbonPath(points, coordinate) {
  const [p0, p1, p2, p3] = points;
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const radius = dist(center2, p0);
    path2.moveTo(p0[0], p0[1]);
    path2.quadraticCurveTo(center2[0], center2[1], p2[0], p2[1]);
    appendArc(path2, p2, p3, center2, radius);
    path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
    appendArc(path2, p1, p0, center2, radius);
    path2.closePath();
    return path2;
  }
  path2.moveTo(p0[0], p0[1]);
  path2.bezierCurveTo(p0[0] / 2 + p2[0] / 2, p0[1], p0[0] / 2 + p2[0] / 2, p2[1], p2[0], p2[1]);
  path2.lineTo(p3[0], p3[1]);
  path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
  path2.lineTo(p0[0], p0[1]);
  path2.closePath();
  return path2;
}
var Ribbon = (options, context) => {
  const style = __rest30(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest30(defaults4, ["color"]);
    const { color: color2 = defaultColor, transform } = value2;
    const path2 = getRibbonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color2 || defaultColor).style("stroke", color2 || defaultColor).style("transform", transform).call(applyStyle, style).node();
  };
};
Ribbon.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/box.js
var __rest31 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath2(points, coordinate) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...points[0]);
    path2.lineTo(...points[1]);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.lineTo(...points[5]);
    path2.lineTo(...points[6]);
    path2.lineTo(...points[7]);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.lineTo(...points[9]);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.lineTo(...points[13]);
  } else {
    const center2 = coordinate.getCenter();
    const [x2, y2] = center2;
    const startAngle = angle(sub(points[0], center2));
    const endAngle = angle(sub(points[1], center2));
    const radiusHigh = dist(center2, points[2]);
    const radiusQ3 = dist(center2, points[3]);
    const radiusMedian = dist(center2, points[8]);
    const radiusQ1 = dist(center2, points[10]);
    const radiusLow = dist(center2, points[11]);
    path2.moveTo(...points[0]);
    path2.arc(x2, y2, radiusHigh, startAngle, endAngle);
    path2.arc(x2, y2, radiusHigh, endAngle, startAngle, true);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.arc(x2, y2, radiusQ3, startAngle, endAngle);
    path2.lineTo(...points[6]);
    path2.arc(x2, y2, radiusQ1, endAngle, startAngle, true);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.arc(x2, y2, radiusMedian, startAngle, endAngle);
    path2.arc(x2, y2, radiusMedian, endAngle, startAngle, true);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.arc(x2, y2, radiusLow, startAngle, endAngle);
    path2.arc(x2, y2, radiusLow, endAngle, startAngle, true);
  }
  return path2;
}
var Box = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color2, transform } = value2;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest31(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath2(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
  };
};
Box.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/violin.js
var __rest32 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath3(p2, coordinate, size3 = 4) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...p2[2]);
    path2.lineTo(...p2[3]);
    path2.lineTo(p2[3][0] - size3, p2[3][1]);
    path2.lineTo(p2[10][0] - size3, p2[10][1]);
    path2.lineTo(p2[10][0] + size3, p2[10][1]);
    path2.lineTo(p2[3][0] + size3, p2[3][1]);
    path2.lineTo(...p2[3]);
    path2.closePath();
    path2.moveTo(...p2[10]);
    path2.lineTo(...p2[11]);
    path2.moveTo(p2[3][0] + size3 / 2, p2[8][1]);
    path2.arc(p2[3][0], p2[8][1], size3 / 2, 0, Math.PI * 2);
    path2.closePath();
    return path2;
  }
  const center2 = coordinate.getCenter();
  const [x2, y2] = center2;
  const radiusQ3 = dist(center2, p2[3]);
  const radiusMedian = dist(center2, p2[8]);
  const radiusQ1 = dist(center2, p2[10]);
  const middleAngle = angle(sub(p2[2], center2));
  const rectAngle = Math.asin(size3 / radiusMedian);
  const startAngle = middleAngle - rectAngle;
  const endAngle = middleAngle + rectAngle;
  path2.moveTo(...p2[2]);
  path2.lineTo(...p2[3]);
  path2.moveTo(Math.cos(startAngle) * radiusQ3 + x2, Math.sin(startAngle) * radiusQ3 + y2);
  path2.arc(x2, y2, radiusQ3, startAngle, endAngle);
  path2.lineTo(Math.cos(endAngle) * radiusQ1 + x2, Math.sin(endAngle) * radiusQ1 + y2);
  path2.arc(x2, y2, radiusQ1, endAngle, startAngle, true);
  path2.lineTo(Math.cos(startAngle) * radiusQ3 + x2, Math.sin(startAngle) * radiusQ3 + y2);
  path2.closePath();
  path2.moveTo(...p2[10]);
  path2.lineTo(...p2[11]);
  const a3 = (startAngle + endAngle) / 2;
  path2.moveTo(Math.cos(a3) * (radiusMedian + size3 / 2) + x2, Math.sin(a3) * (radiusMedian + size3 / 2) + y2);
  path2.arc(Math.cos(a3) * radiusMedian + x2, Math.sin(a3) * radiusMedian + y2, size3 / 2, a3, Math.PI * 2 + a3);
  path2.closePath();
  return path2;
}
var Violin = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color2, transform } = value2;
    const size3 = 4;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest32(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath3(points, coordinate, size3);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
  };
};
Violin.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/lineXY/line.js
var __rest33 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getArrowMarker(document2, arrowSize, arrowStyle) {
  const arrowMarker = document2.createElement("path", {
    style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
  });
  return arrowMarker;
}
function getPath4(points, coordinate) {
  if (!isPolar(coordinate))
    return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
  const center2 = coordinate.getCenter();
  return arc_default()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: dist(points[0], center2),
    innerRadius: dist(points[1], center2)
  });
}
function getTransform2(coordinate, transform) {
  if (!isPolar(coordinate))
    return transform;
  const [cx, cy] = coordinate.getCenter();
  return `translate(${cx}, ${cy}) ${transform || ""}`;
}
var Line4 = (options, context) => {
  const { arrow, arrowSize = 4 } = options, style = __rest33(options, ["arrow", "arrowSize"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, lineWidth } = defaults4, shapeTheme = __rest33(defaults4, ["color", "lineWidth"]);
    const { color: color2 = defaultColor, size: size3 = lineWidth } = value2;
    const arrowMarker = arrow ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color2, stroke: style.stroke || color2 }, subObject(style, "arrow"))) : null;
    const path2 = getPath4(points, coordinate);
    const transform = getTransform2(coordinate, value2.transform);
    return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color2).style("lineWidth", size3).style("transform", transform).style("markerEnd", arrowMarker).call(applyStyle, style).node();
  };
};
Line4.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/connector/connector.js
var __rest34 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferSymbol(x2, y2, r) {
  return [["M", x2, y2], ["L", x2 + 2 * r, y2 - r], ["L", x2 + 2 * r, y2 + r], ["Z"]];
}
function inferConnectorPath2(points) {
  return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
}
function getPoints(coordinate, points, offset1, offset2, length1 = 0) {
  const [[x05, y05], [x12, y12]] = points;
  if (isTranspose(coordinate)) {
    const X02 = x05 + offset1;
    const X12 = x12 + offset2;
    const X = X02 + length1;
    return [
      [X02, y05],
      [X, y05],
      [X, y12],
      [X12, y12]
    ];
  }
  const Y02 = y05 - offset1;
  const Y12 = y12 - offset2;
  const Y = Y02 - length1;
  return [
    [x05, Y02],
    [x05, Y],
    [x12, Y],
    [x12, Y12]
  ];
}
var Connector = (options, context) => {
  const { offset = 0, offset1 = offset, offset2 = offset, connectLength1: length1, endMarker = true } = options, style = __rest34(options, ["offset", "offset1", "offset2", "connectLength1", "endMarker"]);
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, connectLength1 } = defaults4, rest = __rest34(defaults4, ["color", "connectLength1"]);
    const { color: color2, transform } = value2;
    const P = getPoints(coordinate, points, offset1, offset2, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults4), "endMarker");
    return select(new Path()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color2 || defaultColor).style("transform", transform).style("markerEnd", endMarker ? new Marker({
      className: "marker",
      style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
    }) : null).call(applyStyle, style).node();
  };
};
Connector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/utils/string.js
function camelCase(s2) {
  return s2.replace(/-(\w)/g, function(_, letter) {
    return letter.toUpperCase();
  });
}
function kebabCase(s2) {
  return s2.replace(/([A-Z])/g, "-$1").toLowerCase();
}

// node_modules/@antv/g2/esm/shape/label/position/index.js
var position_exports = {};
__export(position_exports, {
  area: () => area,
  bottom: () => getDefaultStyle,
  bottomLeft: () => getDefaultStyle,
  bottomRight: () => getDefaultStyle,
  inside: () => getDefaultStyle,
  left: () => getDefaultStyle,
  outside: () => outside,
  right: () => getDefaultStyle,
  spider: () => spider,
  surround: () => surround,
  top: () => getDefaultStyle,
  topLeft: () => getDefaultStyle,
  topRight: () => getDefaultStyle
});

// node_modules/@antv/g2/esm/shape/label/position/area.js
function area(position, points, value2, coordinate) {
  const l = points.length / 2;
  const Y12 = points.slice(0, l);
  const Y02 = points.slice(l);
  let idx = maxIndex(Y12, (p2, i) => Math.abs(p2[1] - Y02[i][1]));
  idx = Math.max(Math.min(idx, l - 2), 1);
  const mid2 = (i) => [Y12[i][0], (Y12[i][1] + Y02[i][1]) / 2];
  const point6 = mid2(idx);
  const prev = mid2(idx - 1);
  const next = mid2(idx + 1);
  const rotate2 = angle(sub(next, prev)) / Math.PI * 180;
  return {
    x: point6[0],
    y: point6[1],
    transform: `rotate(${rotate2})`,
    textAlign: "center",
    textBaseline: "middle"
  };
}

// node_modules/@antv/g2/esm/shape/label/position/default.js
function inferNonCircularStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [[x05, y05], [x12, y12]] = bounds;
  const w = x12 - x05;
  const h = y12 - y05;
  const xy = (options) => {
    const { x: ox, y: oy } = options;
    const px = maybePercentage(value2.x, w);
    const py = maybePercentage(value2.y, h);
    return Object.assign(Object.assign({}, options), { x: (px || ox) + x05, y: (py || oy) + y05 });
  };
  if (position === "left")
    return xy({ x: 0, y: h / 2, textAlign: "start", textBaseline: "middle" });
  if (position === "right")
    return xy({ x: w, y: h / 2, textAlign: "end", textBaseline: "middle" });
  if (position === "top")
    return xy({ x: w / 2, y: 0, textAlign: "center", textBaseline: "top" });
  if (position === "bottom")
    return xy({ x: w / 2, y: h, textAlign: "center", textBaseline: "bottom" });
  if (position === "top-left")
    return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
  if (position === "top-right")
    return xy({ x: w, y: 0, textAlign: "end", textBaseline: "top" });
  if (position === "bottom-left")
    return xy({ x: 0, y: h, textAlign: "start", textBaseline: "bottom" });
  if (position === "bottom-right")
    return xy({ x: w, y: h, textAlign: "end", textBaseline: "bottom" });
  return xy({
    x: w / 2,
    y: h / 2,
    textAlign: "center",
    textBaseline: "middle"
  });
}
function inferRadialStyle(position, points, value2, coordinate) {
  const { y: y2, y1: y12, autoRotate, rotateToAlignArc } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y2, y12]);
  const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
  const angle2 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const point6 = (() => {
    const [p0, p1] = points;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const [x2, y3] = position === "inside" ? pointOfArc(center2, angle2, radius) : mid(p0, p1);
    return { x: x2, y: y3 };
  })();
  return Object.assign(Object.assign({}, point6), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate2 });
}
function pointOfArc(center2, angle2, radius) {
  return [
    center2[0] + Math.sin(angle2) * radius,
    center2[1] - Math.cos(angle2) * radius
  ];
}
function inferRotation(angle2, autoRotate, rotateToAlignArc) {
  if (!autoRotate)
    return 0;
  const append3 = rotateToAlignArc ? 0 : Math.sin(angle2) < 0 ? 90 : -90;
  return angle2 / Math.PI * 180 + append3;
}
function inferInnerCircularStyle(position, points, value2, coordinate) {
  const { y: y2, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset = 0 } = value2;
  const arcObject = getArcObject(coordinate, points, [y2, y12]);
  const { startAngle, endAngle } = arcObject;
  const center2 = coordinate.getCenter();
  const angle2 = (startAngle + endAngle) / 2;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate2 };
  const { innerRadius, outerRadius } = arcObject;
  const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
  const r1 = r0 + offset;
  const [x05, y05] = pointOfArc(center2, angle2, r1);
  return Object.assign({ x: x05, y: y05 }, textStyle);
}
function maybeUndefined(d2) {
  return d2 === void 0 ? null : d2;
}
function inferIdentityStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [p2] = bounds;
  return {
    x: maybeUndefined(p2[0]),
    y: maybeUndefined(p2[1])
  };
}
function getDefaultStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/outside.js
function linePoints(center2, angle2, radius, radius1, offsetX) {
  const [x05, y05] = pointOfArc(center2, angle2, radius);
  const [x12, y12] = pointOfArc(center2, angle2, radius1);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  return [
    [x05, y05],
    [x12, y12],
    [x12 + sign3 * offsetX, y12]
  ];
}
function radiusOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { innerRadius, outerRadius } = arcObject;
  return innerRadius + (outerRadius - innerRadius);
}
function angleOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { startAngle, endAngle } = arcObject;
  return (startAngle + endAngle) / 2;
}
function inferOutsideCircularStyle(position, points, value2, coordinate) {
  const { autoRotate, rotateToAlignArc, offset = 0, connector = true, connectorLength = offset, connectorLength2 = 0, connectorDistance = 0 } = value2;
  const center2 = coordinate.getCenter();
  const angle2 = angleOf2(points, value2, coordinate);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const textStyle = {
    textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
    textBaseline: "middle",
    rotate: rotate2
  };
  const radius = radiusOf2(points, value2, coordinate);
  const radius1 = radius + (connector ? connectorLength : offset);
  const [[x05, y05], [x12, y12], [x2, y2]] = linePoints(center2, angle2, radius, radius1, connector ? connectorLength2 : 0);
  const dx = connector ? +connectorDistance * sign3 : 0;
  const x3 = x2 + dx;
  const y3 = y2;
  const connectorStyle = {
    connector,
    connectorPoints: [
      [x12 - x3, y12 - y3],
      [x2 - x3, y2 - y3]
    ]
  };
  return Object.assign(Object.assign({
    x0: x05,
    y0: y05,
    x: x2 + dx,
    y: y2
  }, textStyle), connectorStyle);
}
function outside(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/utils.js
function dodgeY(labels, options = {}) {
  const { labelHeight = 14, height } = options;
  const sortedLabels = sort(labels, (d2) => d2.y);
  const n = sortedLabels.length;
  const boxes = new Array(n);
  for (let i2 = 0; i2 < n; i2++) {
    const label = sortedLabels[i2];
    const { y: y2 } = label;
    boxes[i2] = { y: y2, y1: y2 + labelHeight, labels: [y2] };
  }
  let overlap = true;
  while (overlap) {
    overlap = false;
    for (let i2 = boxes.length - 1; i2 > 0; i2--) {
      const box = boxes[i2];
      const preBox = boxes[i2 - 1];
      if (preBox.y1 > box.y) {
        overlap = true;
        preBox.labels.push(...box.labels);
        boxes.splice(i2, 1);
        preBox.y1 += box.y1 - box.y;
        const newHeight = preBox.y1 - preBox.y;
        preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
        preBox.y = preBox.y1 - newHeight;
      }
    }
  }
  let i = 0;
  for (const box of boxes) {
    const { y: y2, labels: labels2 } = box;
    let prevY = y2 - labelHeight;
    for (const curY of labels2) {
      const label = sortedLabels[i++];
      const expectedY = prevY + labelHeight;
      const dy = expectedY - curY;
      label.connectorPoints[0][1] -= dy;
      label.y = prevY + labelHeight;
      prevY += labelHeight;
    }
  }
}
function hideAndDodgeY(unsorted, options) {
  const labels = sort(unsorted, (d2) => d2.y);
  const { height, labelHeight = 14 } = options;
  const maxCount = Math.ceil(height / labelHeight);
  if (labels.length <= maxCount)
    return dodgeY(labels, options);
  const filtered = [];
  for (let i = 0; i < labels.length; i++) {
    if (i < labels.length - maxCount) {
      labels[i].opacity = 0;
      labels[i].connector = false;
    } else
      filtered.push(labels[i]);
  }
  dodgeY(filtered, options);
}

// node_modules/@antv/g2/esm/shape/label/position/spider.js
var __rest35 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var styleByPoints = /* @__PURE__ */ new WeakMap();
function compute(points, value2, coordinate) {
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest35(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const center2 = coordinate.getCenter();
  const radius = radiusOf2(points, value2, coordinate);
  const angle2 = angleOf2(points, value2, coordinate);
  const radius1 = radius + connectorLength + connectorLength2;
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
  const { x: originX } = style;
  const dx = newX - originX;
  style.x += dx;
  style.connectorPoints[0][0] -= dx;
  return style;
}
function spider(position, points, value2, coordinate, options, labels) {
  if (!isCircular(coordinate))
    return {};
  if (styleByPoints.has(points))
    return styleByPoints.get(points);
  const computed = labels.map((points2) => compute(points2, value2, coordinate));
  const { width, height } = coordinate.getOptions();
  const left2 = computed.filter((d2) => d2.x < width / 2);
  const right2 = computed.filter((d2) => d2.x >= width / 2);
  const extendedOptions = Object.assign(Object.assign({}, options), { height });
  hideAndDodgeY(left2, extendedOptions);
  hideAndDodgeY(right2, extendedOptions);
  computed.forEach((style, i) => styleByPoints.set(labels[i], style));
  return styleByPoints.get(points);
}

// node_modules/@antv/g2/esm/shape/label/position/surround.js
var __rest36 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function surround(position, points, value2, coordinate) {
  if (!isCircular(coordinate))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const { x0: x05, y0: y05 } = style;
  const center2 = coordinate.getCenter();
  const radius = getRadius(coordinate);
  const radius1 = radius + connectorLength;
  const angle2 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const [newX, newY] = pointOfArc(center2, angle2, radius1);
  style.x = newX + (connectorLength2 + connectorDistance) * sign3;
  style.y = newY;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/label.js
var __rest37 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferPosition(position, coordinate) {
  if (position !== void 0)
    return position;
  if (isCircular(coordinate))
    return "inside";
  if (isTranspose(coordinate))
    return "right";
  return "top";
}
function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
  const { position } = value2;
  const { render: render2 } = options;
  const p2 = inferPosition(position, coordinate);
  const labelType = render2 ? "htmlLabel" : p2 === "inside" ? "innerLabel" : "label";
  const t = theme[labelType];
  const v = Object.assign({}, t, value2);
  const processor = position_exports[camelCase(p2)];
  if (!processor) {
    throw new Error(`Unknown position: ${p2}`);
  }
  return Object.assign(Object.assign({}, t), processor(p2, points, v, coordinate, options, labels));
}
var Label = (options, context) => {
  const { coordinate, theme } = context;
  const { render: render2 } = options;
  return (points, value2, style, labels) => {
    const { text, x: x2, y: y2, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest37(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
    const _a = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate2 = 0, transform = "" } = _a, defaultStyle2 = __rest37(_a, ["rotate", "transform"]);
    return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render2 ? render2(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform} rotate(${+rotate2}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
  };
};
Label.props = {
  defaultMarker: "point"
};

// node_modules/@antv/g2/esm/shape/path/color.js
var __rest38 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Color3 = (options, context) => {
  const { arrow, colorAttribute } = options, style = __rest38(options, ["arrow", "colorAttribute"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, stroke: stroke2 } = defaults4, rest = __rest38(defaults4, ["color", "stroke"]);
    const { d: d2, color: color2 = defaultColor } = value2;
    const [width, height] = coordinate.getSize();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d2 === "function" ? d2({ width, height }) : d2).style(colorAttribute, color2).call(applyStyle, style).node();
  };
};
Color3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/path.js
var Path3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill" }, options), context);
};
Path3.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/hollow.js
var Hollow2 = (options, context) => {
  return Color3(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
};
Hollow2.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/density/density.js
var __rest39 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Density = (options, context) => {
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform } = value2;
    const { color: defaultColor } = defaults4, rest = __rest39(defaults4, ["color"]);
    const { color: color2 = defaultColor } = value2;
    const [first3, ...p2] = points;
    const path2 = path();
    path2.moveTo(...first3);
    p2.forEach(([x2, y2]) => {
      path2.lineTo(x2, y2);
    });
    path2.closePath();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2 || defaultColor).style("fill", color2 || defaultColor).style("fillOpacity", 0.4).style("transform", transform).call(applyStyle, options).node();
  };
};
Density.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/flru/dist/flru.mjs
function flru_default(max6) {
  var num, curr, prev;
  var limit = max6 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0) return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}

// node_modules/@antv/g2/esm/utils/lru.js
var cache = flru_default(3);
function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
  const cache2 = flru_default(maxSize);
  return (...args) => {
    const key = keyFn(...args);
    let v = cache2.get(key);
    if (cache2.has(key))
      return cache2.get(key);
    v = fn(...args);
    cache2.set(key, v);
    return v;
  };
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
function parseGradient(gradient) {
  if (typeof gradient === "string") {
    return gradient.split(" ").map((stop) => {
      const [r, c4] = stop.split(":");
      return [+r, c4];
    });
  }
  return gradient;
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
function newCanvas(createCanvas, width, height) {
  const c4 = createCanvas ? createCanvas() : document.createElement("canvas");
  c4.width = width;
  c4.height = height;
  return c4;
}
var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
  const tplCtx = tplCanvas.getContext("2d");
  const x2 = radius;
  const y2 = radius;
  if (blurFactor === 1) {
    tplCtx.beginPath();
    tplCtx.arc(x2, y2, radius, 0, 2 * Math.PI, false);
    tplCtx.fillStyle = "rgba(0,0,0,1)";
    tplCtx.fill();
  } else {
    const gradient = tplCtx.createRadialGradient(x2, y2, radius * blurFactor, x2, y2, radius);
    gradient.addColorStop(0, "rgba(0,0,0,1)");
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    tplCtx.fillStyle = gradient;
    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
  }
  return tplCanvas;
}, (radius) => `${radius}`);
function getColorPalette(gradientConfig, createCanvas) {
  const paletteCanvas = newCanvas(createCanvas, 256, 1);
  const paletteCtx = paletteCanvas.getContext("2d");
  const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
  parseGradient(gradientConfig).forEach(([r, c4]) => {
    gradient.addColorStop(r, c4);
  });
  paletteCtx.fillStyle = gradient;
  paletteCtx.fillRect(0, 0, 256, 1);
  return paletteCtx.getImageData(0, 0, 256, 1).data;
}
function drawAlpha(shadowCtx, min6, max6, data, options, createCanvas) {
  const { blur: blur3 } = options;
  let len = data.length;
  while (len--) {
    const { x: x2, y: y2, value: v, radius } = data[len];
    const value2 = Math.min(v, max6);
    const rectX = x2 - radius;
    const rectY = y2 - radius;
    const tpl = getPointTemplate(radius, 1 - blur3, createCanvas);
    const templateAlpha = (value2 - min6) / (max6 - min6);
    shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
    shadowCtx.drawImage(tpl, rectX, rectY);
  }
  return shadowCtx;
}
function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
  const x2 = 0;
  const y2 = 0;
  const width = maxWidth;
  const height = maxHeight;
  const img = shadowCtx.getImageData(x2, y2, width, height);
  const imgData = img.data;
  const len = imgData.length;
  for (let i = 3; i < len; i += 4) {
    const alpha = imgData[i];
    const offset = alpha * 4;
    if (!offset) {
      continue;
    }
    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
    imgData[i - 3] = palette[offset];
    imgData[i - 2] = palette[offset + 1];
    imgData[i - 1] = palette[offset + 2];
    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;
  }
  return img;
}
function HeatmapRenderer(width, height, min6, max6, data, options, createCanvas) {
  const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
    [0.25, "rgb(0,0,255)"],
    [0.55, "rgb(0,255,0)"],
    [0.85, "yellow"],
    [1, "rgb(255,0,0)"]
  ] }, options);
  opts.minOpacity *= 255;
  opts.opacity *= 255;
  opts.maxOpacity *= 255;
  const shadowCanvas = newCanvas(createCanvas, width, height);
  const shadowCtx = shadowCanvas.getContext("2d");
  const palette = getColorPalette(opts.gradient, createCanvas);
  shadowCtx.clearRect(0, 0, width, height);
  drawAlpha(shadowCtx, min6, max6, data, opts, createCanvas);
  const img = colorize(shadowCtx, width, height, palette, opts);
  const canvas = newCanvas(createCanvas, width, height);
  const ctx2 = canvas.getContext("2d");
  ctx2.putImageData(img, 0, 0);
  return ctx2;
}

// node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
var __rest40 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function deleteKey(obj, fn) {
  return Object.keys(obj).reduce((r, k2) => {
    const v = obj[k2];
    if (!fn(v, k2))
      r[k2] = v;
    return r;
  }, {});
}
var Heatmap = (options, context) => {
  const { gradient, opacity, maxOpacity, minOpacity, blur: blur3, useGradientOpacity } = options, style = __rest40(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
  const { coordinate, createCanvas, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform } = value2;
    const [width, height] = coordinate.getSize();
    const data = points.map((p2) => ({
      x: p2[0],
      y: p2[1],
      value: p2[2],
      radius: p2[3]
    }));
    const min6 = min(points, (p2) => p2[2]);
    const max6 = max(points, (p2) => p2[2]);
    const options2 = {
      gradient,
      opacity,
      minOpacity,
      maxOpacity,
      blur: blur3,
      useGradientOpacity
    };
    const ctx2 = width && height ? HeatmapRenderer(width, height, min6, max6, data, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
    return select(document2.createElement("image", {})).call(applyStyle, defaults4).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx2.canvas).style("transform", transform).call(applyStyle, style).node();
  };
};
Heatmap.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/shape/shape.js
var __rest41 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Shape2 = (options, context) => {
  const { render: render2 } = options, rest = __rest41(options, ["render"]);
  return (points) => {
    const [[x05, y05]] = points;
    return render2(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
  };
};
Shape2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/liquid/wave.js
var DURATION = 5e3;
function lerp(min6, max6, factor) {
  return min6 + (max6 - min6) * factor;
}
function getWaterWavePositions(x2, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, amplitude],
      [x2 + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [
        x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x2 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x2 + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [
      x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
      -amplitude / 2
    ],
    [x2 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  const path2 = [];
  let _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  const left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  let waveRight = 0;
  for (let c4 = 0; c4 < curves; ++c4) {
    const stage = c4 % 4;
    const pos = getWaterWavePositions(c4 * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c4 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWave(x2, y2, level, waveCount, waveAttrs, group2, minY, radius, waveLength, animation, document2) {
  const { fill, fillOpacity, opacity } = waveAttrs;
  for (let idx = 0; idx < waveCount; idx++) {
    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    const path2 = getWaterWavePath(
      radius,
      minY + radius * level,
      waveLength,
      0,
      // Amplitude height.
      radius / 40,
      x2,
      y2
    );
    const wave = document2.createElement("path", {
      style: {
        d: path2,
        fill,
        opacity: lerp(0.2, 0.9, factor) * Number(opacity || fillOpacity)
      }
    });
    group2.appendChild(wave);
    try {
      if (animation === false)
        return;
      const keyframes = [
        {
          transform: "translate(0, 0)"
        },
        {
          transform: `translate(${waveLength * 2}, 0)`
        }
      ];
      wave.animate(keyframes, {
        duration: lerp(0.5 * DURATION, DURATION, factor) * 2,
        iterations: Infinity
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}

// node_modules/@antv/g2/esm/shape/liquid/shapes.js
function circle(x2, y2, r) {
  return `
      M ${x2} ${y2 - r} 
      a ${r} ${r} 0 1 0 0 ${r * 2}
      a ${r} ${r} 0 1 0 0 ${-r * 2}
      Z
    `;
}
function rect3(x2, y2, r) {
  const GOLDEN_SECTION_RATIO = 0.618;
  const w = r * GOLDEN_SECTION_RATIO;
  return `
      M ${x2 - w} ${y2 - r}
      L ${x2 + w} ${y2 - r}
      L ${x2 + w} ${y2 + r}
      L ${x2 - w} ${y2 + r}
      Z
    `;
}
function diamond2(x2, y2, r) {
  return `
      M ${x2} ${y2 - r}
      L ${x2 + r} ${y2}
      L ${x2} ${y2 + r}
      L ${x2 - r} ${y2}
      Z
    `;
}
function triangle2(x2, y2, r) {
  return `
      M ${x2} ${y2 - r}
      L ${x2 + r} ${y2 + r}
      L ${x2 - r} ${y2 + r}
      Z
    `;
}
function pin(x2, y2, radius) {
  const w = radius * 4 / 3;
  const h = Math.max(w, radius * 2);
  const r = w / 2;
  const cx = x2;
  const cy = r + y2 - h / 2;
  const theta = Math.asin(r / ((h - r) * 0.85));
  const dy = Math.sin(theta) * r;
  const dx = Math.cos(theta) * r;
  const x05 = cx - dx;
  const y05 = cy + dy;
  const cpX = x2;
  const cpY = cy + r / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x2} ${y2 + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}
var LiquidShapesPath = {
  pin,
  rect: rect3,
  circle,
  diamond: diamond2,
  triangle: triangle2
};

// node_modules/@antv/g2/esm/shape/liquid/liquid.js
var __rest42 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
var Liquid = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  const { liquidOptions, styleOptions } = options;
  const { liquidShape, percent } = liquidOptions;
  const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr = __rest42(styleOptions, ["background", "outline", "wave"]);
  const { border = 2, distance: distance2 = 0 } = outline, outlineStyle = __rest42(outline, ["border", "distance"]);
  const { length = 192, count: count4 = 3 } = wave;
  return (points, cfg, defaultAttr) => {
    const { document: document2 } = context.canvas;
    const { color: color2, fillOpacity } = defaultAttr;
    const attrs = Object.assign(Object.assign({ fill: color2 }, defaultAttr), attr);
    const g = document2.createElement("g", {});
    const [centerX, centerY] = coordinate.getCenter();
    const size3 = coordinate.getSize();
    const radius = Math.min(...size3) / 2;
    const buildPath = isFunction(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
    const shapePath = buildPath(centerX, centerY, radius, ...size3);
    if (Object.keys(backgroundStyle).length) {
      const backgroundShape = document2.createElement("path", {
        style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
      });
      g.appendChild(backgroundShape);
    }
    if (percent > 0) {
      const clipShape = document2.createElement("path", {
        style: {
          d: shapePath
        }
      });
      g.appendChild(clipShape);
      g.style.clipPath = clipShape;
      addWave(centerX, centerY, 1 - percent, count4, attrs, g, clipShape.getBBox().y, radius * 2, length, true, document2);
    }
    const distanceShape = document2.createElement("path", {
      style: {
        d: shapePath,
        fill: "transparent",
        lineWidth: border + 2 * distance2,
        stroke: "#fff"
      }
    });
    const borderShape = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color2, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
    });
    g.appendChild(distanceShape);
    g.appendChild(borderShape);
    return g;
  };
};
Liquid.props = {};

// node_modules/@antv/g2/esm/shape/gauge/round.js
var getR = (point1, point22) => {
  return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
};
var Round = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
    return;
  const center2 = coordinate.getCenter();
  return (points, cfg, defaultCfg) => {
    const { document: document2 } = context.canvas;
    const { color: color2, index: index2 } = cfg;
    const g = document2.createElement("g", {});
    const minR = getR(points[0], points[1]);
    const maxR = getR(points[0], center2) * 2;
    const roundPath = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: [
        ["M", ...points[0]],
        ["A", minR, minR, 0, 1, 0, ...points[1]],
        ["A", maxR + minR * 2, maxR + minR * 2, 0, 0, 0, ...points[2]],
        ["A", minR, minR, 0, 1, index2 === 0 ? 0 : 1, ...points[3]],
        ["A", maxR, maxR, 0, 0, 1, ...points[0]],
        ["Z"]
      ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color2 || defaultCfg.color })
    });
    g.appendChild(roundPath);
    return g;
  };
};

// node_modules/@antv/g2/esm/mark/interval.js
function bandWidth2(scale3, x2) {
  return scale3.getBandWidth(scale3.invert(x2));
}
var shape = {
  rect: Rect2,
  hollow: Hollow,
  funnel: Funnel,
  pyramid: Pyramid
};
var Interval = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
    const x2 = scale3.x;
    const series = scale3.series;
    const [width] = coordinate.getSize();
    const NSZ = SZ ? SZ.map((d2) => +d2 / width) : null;
    const x1x2 = !SZ ? (x3, w, i) => [x3, x3 + w] : (x3, w, i) => {
      const mx = x3 + w / 2;
      const s2 = NSZ[i];
      return [mx - s2 / 2, mx + s2 / 2];
    };
    const P = Array.from(index2, (i) => {
      const groupWidth = bandWidth2(x2, X[i]);
      const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i]) : 1;
      const width2 = groupWidth * ratio;
      const offset = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x05 = +X[i] + offset;
      const [x12, x22] = x1x2(x05, width2, i);
      const y12 = +Y[i];
      const y2 = +Y12[i];
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y2];
      const p4 = [x12, y2];
      return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
    });
    return [index2, P];
  };
};
Interval.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/rect.js
var shape2 = {
  rect: Rect2,
  hollow: Hollow
};
var Rect3 = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
    const P = Array.from(index2, (i) => {
      const p1 = [+X[i], +Y[i]];
      const p2 = [+X12[i], +Y[i]];
      const p3 = [+X12[i], +Y12[i]];
      const p4 = [+X[i], +Y12[i]];
      return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
    });
    return [index2, P];
  };
};
Rect3.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape: shape2,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroY1 }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/line.js
var shape3 = {
  line: Line2,
  smooth: Smooth,
  hv: HV,
  vh: VH,
  hvh: HVH,
  trail: Trail
};
var line2 = (index2, scale3, value2, coordinate) => {
  var _a, _b;
  const { series: S, x: X, y: Y } = value2;
  const { x: x2, y: y2 } = scale3;
  if (X === void 0 || Y === void 0) {
    throw new Error("Missing encode for x or y channel.");
  }
  const series = S ? Array.from(group(index2, (i) => S[i]).values()) : [index2];
  const I = series.map((group2) => group2[0]).filter((i) => i !== void 0);
  const xoffset = (((_a = x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x2)) || 0) / 2;
  const yoffset = (((_b = y2 === null || y2 === void 0 ? void 0 : y2.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y2)) || 0) / 2;
  const P = Array.from(series, (I2) => {
    return I2.map((i) => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));
  });
  return [I, P, series];
};
var parallel = (index2, scale3, value2, coordinate) => {
  const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
  if (PV.length === 0) {
    throw new Error("Missing encode for position channel.");
  }
  const P = Array.from(index2, (i) => {
    const vector = PV.map((pv) => +pv[i]);
    const vectors = coordinate.map(vector);
    const points = [];
    for (let i2 = 0; i2 < vectors.length; i2 += 2) {
      points.push([vectors[i2], vectors[i2 + 1]]);
    }
    return points;
  });
  return [index2, P];
};
var Line5 = () => {
  return (index2, scale3, value2, coordinate) => {
    const mark2 = isParallel(coordinate) ? parallel : line2;
    return mark2(index2, scale3, value2, coordinate);
  };
};
Line5.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape3,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
    { name: "x" },
    { name: "y" },
    { name: "position", independent: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    // !!!Note This order is very important.
    { type: MaybeGradient },
    { type: MaybeSeries }
  ],
  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/point.js
var shape4 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  hollowCircle: HollowCircle,
  point: Point2,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown,
  circle: Circle2
};
var Point3 = (options) => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
    const [width, height] = coordinate.getSize();
    const offset = createBandOffset(scale3, value2, options);
    const xy = (i) => {
      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);
      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);
      const x2 = X12 ? (+X[i] + +X12[i]) / 2 : +X[i];
      const y2 = Y12 ? (+Y[i] + +Y12[i]) / 2 : +Y[i];
      const cx = x2 + dx;
      const cy = y2 + dy;
      return [cx, cy];
    };
    const P = S ? Array.from(index2, (i) => {
      const [cx, cy] = xy(i);
      const r = +S[i];
      const a3 = r / width;
      const b = r / height;
      const p1 = [cx - a3, cy - b];
      const p2 = [cx + a3, cy + b];
      return [
        coordinate.map(offset(p1, i)),
        coordinate.map(offset(p2, i))
      ];
    }) : Array.from(index2, (i) => [coordinate.map(offset(xy(i), i))]);
    return [index2, P];
  };
};
Point3.props = {
  defaultShape: "hollow",
  defaultLabelShape: "label",
  composite: false,
  shape: shape4,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" },
    { name: "dx", scale: "identity" },
    { name: "dy", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/text.js
var shape5 = {
  text: Text2,
  badge: Badge,
  tag: Tag
};
var Text3 = (options) => {
  const { cartesian: cartesian3 = false } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset = createBandOffset(scale3, value2, options);
    const P = Array.from(index2, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset(p2, i))];
    });
    return [index2, P];
  };
};
Text3.props = {
  defaultShape: "text",
  defaultLabelShape: "label",
  composite: false,
  shape: shape5,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "text", scale: "identity" },
    { name: "fontSize", scale: "identity" },
    { name: "rotate", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/cell.js
var shape6 = {
  cell: Rect2,
  hollow: Hollow
};
var Cell = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const x2 = scale3.x;
    const y2 = scale3.y;
    const P = Array.from(index2, (i) => {
      const width = x2.getBandWidth(x2.invert(+X[i]));
      const height = y2.getBandWidth(y2.invert(+Y[i]));
      const x12 = +X[i];
      const y12 = +Y[i];
      const p1 = [x12, y12];
      const p2 = [x12 + width, y12];
      const p3 = [x12 + width, y12 + height];
      const p4 = [x12, y12 + height];
      return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
    });
    return [index2, P];
  };
};
Cell.props = {
  defaultShape: "cell",
  defaultLabelShape: "label",
  shape: shape6,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
    { name: "x", required: true, scale: "band" },
    { name: "y", required: true, scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/area.js
var shape7 = {
  area: Area,
  smooth: Smooth2,
  hvh: HVH2,
  vh: VH2,
  hv: HV2
};
var Area2 = () => {
  return (index2, scale3, value2, coordinate) => {
    var _a, _b;
    const { x: X, y: Y, y1: Y12, series: S } = value2;
    const { x: x2, y: y2 } = scale3;
    const series = S ? Array.from(group(index2, (i) => S[i]).values()) : [index2];
    const I = series.map((group2) => group2[0]).filter((i) => i !== void 0);
    const xoffset = (((_a = x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x2)) || 0) / 2;
    const yoffset = (((_b = y2 === null || y2 === void 0 ? void 0 : y2.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y2)) || 0) / 2;
    const P = Array.from(series, (SI) => {
      const l = SI.length;
      const points = new Array(l * 2);
      for (let idx = 0; idx < SI.length; idx++) {
        const i = SI[idx];
        points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]);
        points[l + idx] = coordinate.map([+X[i] + xoffset, +Y12[i] + yoffset]);
      }
      return points;
    });
    return [I, P, series];
  };
};
Area2.props = {
  defaultShape: "area",
  defaultLabelShape: "label",
  composite: false,
  shape: shape7,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeSeries },
    { type: MaybeZeroY1 },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/link.js
var shape8 = {
  link: Link,
  arc: Arc,
  smooth: Smooth3,
  vhv: VHV
};
var Link2 = (options) => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
    const offset = createBandOffset(scale3, value2, options);
    const P = index2.map((i) => [
      coordinate.map(offset([+X[i], +Y[i]], i)),
      coordinate.map(offset([+X12[i], +Y12[i]], i))
    ]);
    return [index2, P];
  };
};
Link2.props = {
  defaultShape: "link",
  defaultLabelShape: "label",
  composite: false,
  shape: shape8,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeIdentityY },
    { type: MaybeIdentityX }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/image.js
var shape9 = {
  image: Image3
};
var Image4 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset = createBandOffset(scale3, value2, options);
    const P = Array.from(index2, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset(p2, i))];
    });
    return [index2, P];
  };
};
Image4.props = {
  defaultShape: "image",
  defaultLabelShape: "label",
  composite: false,
  shape: shape9,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "src", scale: "identity" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/polygon.js
var shape10 = {
  polygon: Polygon2,
  ribbon: Ribbon
};
var Polygon3 = () => {
  return (index2, scale3, value2, coordinate) => {
    const Xn2 = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const P = index2.map((i) => {
      const Pn = [];
      for (let j = 0; j < Xn2.length; j++) {
        const x2 = Xn2[j][i];
        if (x2 === void 0)
          break;
        const y2 = Yn2[j][i];
        Pn.push(coordinate.map([+x2, +y2]));
      }
      return Pn;
    });
    return [index2, P];
  };
};
Polygon3.props = {
  defaultShape: "polygon",
  defaultLabelShape: "label",
  composite: false,
  shape: shape10,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/box.js
var shape11 = {
  box: Box,
  violin: Violin
};
var Box2 = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
    const xScale = scale3.x;
    const series = scale3.series;
    const P = Array.from(index2, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x2 = +X[i] + offset + width / 2;
      const [low, q12, median3, q32, high] = [
        +Y[i],
        +Y12[i],
        +Y22[i],
        +Y3[i],
        +Y4[i]
      ];
      const P13 = [
        [x2 - width / 2, high],
        [x2 + width / 2, high],
        [x2, high],
        [x2, q32],
        [x2 - width / 2, q32],
        [x2 + width / 2, q32],
        [x2 + width / 2, q12],
        [x2 - width / 2, q12],
        [x2 - width / 2, median3],
        [x2 + width / 2, median3],
        [x2, q12],
        [x2, low],
        [x2 - width / 2, low],
        [x2 + width / 2, low]
      ];
      return P13.map((d2) => coordinate.map(d2));
    });
    return [index2, P];
  };
};
Box2.props = {
  defaultShape: "box",
  defaultLabelShape: "label",
  composite: false,
  shape: shape11,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroX }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/vector.js
var shape12 = {
  vector: Vector
};
var Vector2 = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, size: S, rotate: R } = value2;
    const [width, height] = coordinate.getSize();
    const P = index2.map((i) => {
      const angle2 = +R[i] / 180 * Math.PI;
      const s2 = +S[i];
      const a3 = s2 / width;
      const b = s2 / height;
      const vx = a3 * Math.cos(angle2);
      const vy = -b * Math.sin(angle2);
      return [
        coordinate.map([+X[i] - vx / 2, +Y[i] - vy / 2]),
        coordinate.map([+X[i] + vx / 2, +Y[i] + vy / 2])
      ];
    });
    return [index2, P];
  };
};
Vector2.props = {
  defaultShape: "vector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape12,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "rotate", required: true, scale: "identity" },
    { name: "size", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/lineY.js
var shape13 = {
  line: Line4
};
var LineY = (options) => {
  return (index2, scale3, value2, coordinate) => {
    const { y: Y } = value2;
    const offset = createBandOffset(scale3, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index2, (i) => {
      const p1 = [0, Y[i]];
      const p2 = [1, Y[i]];
      return [p1, p2].map((d2) => coordinate.map(offset(d2, i)));
    });
    return [index2, P];
  };
};
LineY.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape13,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/lineX.js
var shape14 = {
  line: Line4
};
var LineX = (options) => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X } = value2;
    const offset = createBandOffset(scale3, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index2, (i) => {
      const p1 = [X[i], 1];
      const p2 = [X[i], 0];
      return [p1, p2].map((d2) => coordinate.map(offset(d2, i)));
    });
    return [index2, P];
  };
};
LineX.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape14,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/connector.js
var shape15 = {
  connector: Connector
};
var Connector2 = (...args) => {
  return Link2(...args);
};
Connector2.props = {
  defaultShape: "connector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape15,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/range.js
function extend(channel, extended, value2, scale3) {
  if (extended)
    return () => [0, 1];
  const { [channel]: C2, [`${channel}1`]: C1 } = value2;
  return (i) => {
    var _a;
    const offset = ((_a = scale3.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale3, scale3.invert(+C1[i]))) || 0;
    return [C2[i], C1[i] + offset];
  };
}
function AbstractRange(options = {}) {
  const { extendX = false, extendY = false } = options;
  return (index2, scale3, value2, coordinate) => {
    const x2 = extend("x", extendX, value2, scale3.x);
    const y2 = extend("y", extendY, value2, scale3.y);
    const P = Array.from(index2, (i) => {
      const [x12, x22] = x2(i);
      const [y12, y22] = y2(i);
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
    });
    return [index2, P];
  };
}
var shape16 = { range: Rect2 };
var Range = () => {
  return AbstractRange();
};
Range.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape16,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeX.js
var shape17 = {
  range: Rect2
};
var RangeX = () => {
  return AbstractRange({ extendY: true });
};
RangeX.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape17,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeY.js
var shape18 = {
  range: Rect2
};
var RangeY = () => {
  return AbstractRange({ extendX: true });
};
RangeY.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape18,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
function targetDepth(d2) {
  return d2.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
function constant3(x2) {
  return function() {
    return x2;
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
function ascendingSourceBreadth(a3, b) {
  return ascendingBreadth(a3.source, b.source) || a3.index - b.index;
}
function ascendingTargetBreadth(a3, b) {
  return ascendingBreadth(a3.target, b.target) || a3.index - b.index;
}
function ascendingBreadth(a3, b) {
  return a3.y0 - b.y0;
}
function value(d2) {
  return d2.value;
}
function defaultId(d2) {
  return d2.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  const node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y05 = node.y0;
    let y12 = y05;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y05 + link3.width / 2;
      y05 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId;
  let align = justify;
  let depth;
  let sort2;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey(arg) {
    const graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant3(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant3(_), sankey) : align;
  };
  sankey.nodeDepth = function(_) {
    return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort2 = _, sankey) : sort2;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant3(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant3(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x05 = y05 = 0, x12 = +_[0], y12 = +_[1], sankey) : [x12 - x05, y12 - y05];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x05 = +_[0][0], x12 = +_[1][0], y05 = +_[0][1], y12 = +_[1][1], sankey) : [
      [x05, y05],
      [x12, y12]
    ];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    nodes2.forEach((node, idx) => {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    const nodeById = new Map(nodes2.map((d2) => [id2(d2), d2]));
    links2.forEach((link3, idx) => {
      link3.index = idx;
      let { source, target } = link3;
      if (typeof source !== "object")
        source = link3.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link3.target = find(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    });
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.depth = x2;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      });
      if (++x2 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      const maxDepth2 = Math.max(max(nodes2, (d2) => d2.depth) + 1, 0);
      let node;
      for (let i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth2);
      }
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.height = x2;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      });
      if (++x2 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x2 = Math.max(max(nodes2, (d2) => d2.depth) + 1, 0);
    const kx2 = (x12 - x05 - dx) / (x2 - 1);
    const columns = new Array(x2).fill(0).map(() => []);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i;
      node.x0 = x05 + i * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort2)
      for (const column2 of columns) {
        column2.sort(sort2);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min(columns, (c4) => (y12 - y05 - (c4.length - 1) * py) / sum(c4, value));
    for (const nodes2 of columns) {
      let y2 = y05;
      for (const node of nodes2) {
        node.y0 = y2;
        node.y1 = y2 + node.value * ky2;
        y2 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky2;
        }
      }
      y2 = (y12 - y2 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y2 * (i + 1);
        node.y1 += y2 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y05) / (max(columns, (c4) => c4.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations2; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column2 = columns[i];
      for (const target of column2) {
        let y2 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          const v = value2 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y2 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column2 = columns[i];
      for (const source of column2) {
        let y2 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          const v = value2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y2 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y2 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y2) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}

// node_modules/@antv/g2/esm/data/sankey.js
var DEFAULT_OPTIONS = {
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodes: (graph) => graph.nodes,
  links: (graph) => graph.links,
  nodeSort: void 0,
  linkSort: void 0,
  iterations: 6
};
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
function getNodeAlignFunction(nodeAlign) {
  const type = typeof nodeAlign;
  if (type === "string")
    return ALIGN_METHOD[nodeAlign] || justify;
  if (type === "function")
    return nodeAlign;
  return justify;
}
var Sankey2 = (options) => {
  return (data) => {
    const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
    const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
      [0, 0],
      [1, 1]
    ]);
    if (typeof nodeId === "function") {
      sankeyProcessor.nodeId(nodeId);
    }
    const layoutData = sankeyProcessor(data);
    const { nodes: N, links: L } = layoutData;
    const nodes = N.map((node) => {
      const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
      return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
    });
    const links = L.map((edge) => {
      const { source, target } = edge;
      const sx = source.x1;
      const tx = target.x0;
      const offset = edge.width / 2;
      return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
        edge.y0 + offset,
        edge.y0 - offset,
        edge.y1 + offset,
        edge.y1 - offset
      ] });
    });
    return { nodes, links };
  };
};
Sankey2.props = {};

// node_modules/@antv/g2/esm/utils/mark.js
function subTooltip(tooltip2, name2, defaults4 = {}, main = false) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2) && main)
    return tooltip2;
  const sub2 = subObject(tooltip2, name2);
  return deep_mix_default(defaults4, sub2);
}
function maybeTooltip(tooltip2, defaults4 = {}) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2))
    return tooltip2;
  if (!isFullTooltip(tooltip2))
    return tooltip2;
  return deep_mix_default(defaults4, tooltip2);
}
function isFullTooltip(tooltip2) {
  if (Object.keys(tooltip2).length === 0)
    return true;
  const { title, items } = tooltip2;
  return title !== void 0 || items !== void 0;
}
function maybeAnimation(animate, sub2) {
  return typeof animate === "object" ? subObject(animate, sub2) : animate;
}

// node_modules/@antv/g2/esm/mark/sankey.js
var __rest43 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS = {
  nodeId: (d2) => d2.key,
  nodeWidth: 0.02,
  nodePadding: 0.02
};
var DEFAULT_NODE_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    stroke: "#000"
  }
};
var DEFAULT_LINK_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    fillOpacity: 0.5,
    stroke: void 0
  }
};
var DEFAULT_LABEL_OPTIONS = {
  textAlign: (d2) => d2.x[0] < 0.5 ? "start" : "end",
  position: (d2) => d2.x[0] < 0.5 ? "right" : "left",
  fontSize: 10
};
var Sankey3 = (options) => {
  const { data, encode = {}, scale: scale3, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {}, interaction } = options;
  const { links, nodes } = initializeData(data, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
  const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
  const _a = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a, labelStyle = __rest43(_a, ["text", "spacing"]);
  const key1 = field(nodeKey);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: key1,
    items: [{ field: "value" }]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d2) => ({ name: "source", value: key1(d2.source) }),
      (d2) => ({ name: "target", value: key1(d2.target) })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
      scale: scale3,
      style: subObject(style, "node"),
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d2) => d2.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node"),
      axis: false,
      interaction
    }),
    deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
      data: linkData,
      encode: linkEncode,
      labels: linkLabels,
      style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link"),
      interaction
    })
  ];
};
Sankey3.props = {};

// node_modules/@antv/g2/esm/data/utils/arc/sort.js
var sort_exports = {};
__export(sort_exports, {
  frequency: () => frequency,
  id: () => id,
  name: () => name,
  weight: () => weight
});
function weight(a3, b) {
  return b.value - a3.value;
}
function frequency(a3, b) {
  return b.frequency - a3.frequency;
}
function id(a3, b) {
  return `${a3.id}`.localeCompare(`${b.id}`);
}
function name(a3, b) {
  return `${a3.name}`.localeCompare(`${b.name}`);
}

// node_modules/@antv/g2/esm/data/utils/arc/arc.js
var DEFAULT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  weight: false,
  marginRatio: 0.1,
  id: (node) => node.id,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
};
function Arc2(options) {
  const { y: y2, thickness, weight: weight2, marginRatio, id: id2, source, target, sourceWeight, targetWeight, sortBy: sortBy2 } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  function arc(data) {
    const nodes = data.nodes.map((n) => Object.assign({}, n));
    const edges = data.edges.map((n) => Object.assign({}, n));
    preprocess(nodes, edges);
    sortNodes(nodes, edges);
    layoutNodes(nodes, edges);
    layoutEdges(nodes, edges);
    return { nodes, edges };
  }
  function preprocess(nodes, edges) {
    edges.forEach((edge) => {
      edge.source = source(edge);
      edge.target = target(edge);
      edge.sourceWeight = sourceWeight(edge);
      edge.targetWeight = targetWeight(edge);
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      node.id = id2(node);
      const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
      const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
      node.frequency = sources.length + targets.length;
      node.value = sum(sources, (d2) => d2.sourceWeight) + sum(targets, (d2) => d2.targetWeight);
    });
    return { nodes, edges };
  }
  function sortNodes(nodes, edges) {
    const method = typeof sortBy2 === "function" ? sortBy2 : sort_exports[sortBy2];
    if (method) {
      nodes.sort(method);
    }
  }
  function layoutNodes(nodes, edges) {
    const size3 = nodes.length;
    if (!size3) {
      throw error("Invalid nodes: it's empty!");
    }
    if (!weight2) {
      const deltaX = 1 / size3;
      nodes.forEach((node, i) => {
        node.x = (i + 0.5) * deltaX;
        node.y = y2;
      });
      return { nodes, edges };
    }
    const margin = marginRatio / (2 * size3);
    const total = nodes.reduce((prev, node) => prev += node.value, 0);
    nodes.reduce((deltaX, node) => {
      node.weight = node.value / total;
      node.width = node.weight * (1 - marginRatio);
      node.height = thickness;
      const minX = margin + deltaX;
      const maxX = minX + node.width;
      const minY = y2 - thickness / 2;
      const maxY2 = minY + thickness;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
      return deltaX + node.width + 2 * margin;
    }, 0);
    return {
      nodes,
      edges
    };
  }
  function layoutEdges(nodes, edges) {
    const nodesMap = new Map(nodes.map((d2) => [d2.id, d2]));
    if (!weight2) {
      edges.forEach((edge) => {
        const sourceId = source(edge);
        const targetId = target(edge);
        const sourceNode = nodesMap.get(sourceId);
        const targetNode = nodesMap.get(targetId);
        if (sourceNode && targetNode) {
          edge.x = [sourceNode.x, targetNode.x];
          edge.y = [sourceNode.y, targetNode.y];
        }
      });
      return { nodes, edges };
    }
    edges.forEach((edge) => {
      edge.x = [0, 0, 0, 0];
      edge.y = [y2, y2, y2, y2];
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      const { edges: edges2, width, x: x2, y: y3, value: value2, id: id3 } = node;
      const sourceEdges = edgesBySource.get(id3) || [];
      const targetEdges = edgesByTarget.get(id3) || [];
      let offset = 0;
      sourceEdges.map((edge) => {
        const w = edge.sourceWeight / value2 * width;
        edge.x[0] = x2[0] + offset;
        edge.x[1] = x2[0] + offset + w;
        offset += w;
      });
      targetEdges.forEach((edge) => {
        const w = edge.targetWeight / value2 * width;
        edge.x[3] = x2[0] + offset;
        edge.x[2] = x2[0] + offset + w;
        offset += w;
      });
    });
  }
  return arc;
}

// node_modules/@antv/g2/esm/data/arc.js
var Arc3 = (options) => {
  return (data) => {
    return Arc2(options)(data);
  };
};
Arc3.props = {};

// node_modules/@antv/g2/esm/mark/chord.js
var __rest44 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  marginRatio: 0.1,
  id: (node) => node.key,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
  // optional, id | weight | frequency | {function}
};
var DEFAULT_NODE_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  }
};
var DEFAULT_LINK_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    opacity: 0.5,
    lineWidth: 1
  }
};
var DEFAULT_LABEL_OPTIONS2 = {
  position: "outside",
  fontSize: 10
};
var Chord = (options, context) => {
  const { data, encode = {}, scale: scale3, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const { nodes, links } = initializeData(data, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
  const { linkEncodeColor = (d2) => d2.source } = linkEncode;
  const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest44(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
  const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
  const _a = subObject(style, "label"), { text = nodeKey } = _a, labelStyle = __rest44(_a, ["text"]);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "",
    items: [(d2) => ({ name: d2.key, value: d2.value })]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [(d2) => ({ name: `${d2.source} -> ${d2.target}`, value: d2.value })]
  });
  const { height, width } = context;
  const minimumLen = Math.min(height, width);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
      data: linkData,
      encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
      labels: linkLabels,
      style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
      scale: scale3,
      style: subObject(style, "node"),
      coordinate: {
        type: "polar",
        // Leave enough rendering space for the label.
        outerRadius: (minimumLen - 20) / minimumLen,
        startAngle: -Math.PI * 2,
        endAngle: 0
      },
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node"),
      axis: false
    })
  ];
};
Chord.props = {};

// node_modules/@antv/g2/esm/mark/path.js
var shape19 = {
  path: Path3,
  hollow: Hollow2
};
var Path4 = (options) => {
  return (index2, scale3, value2, coordinate) => {
    return [index2, index2.map(() => [[0, 0]])];
  };
};
Path4.props = {
  defaultShape: "path",
  defaultLabelShape: "label",
  shape: shape19,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
    { name: "d", scale: "identity" }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a3, b) {
  return a3.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x2, c4) {
  return x2 + c4.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c4) {
  return Math.max(y2, c4.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root) {
    var previousNode, x2 = 0;
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x2 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root), right2 = leafRight(root), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster) : separation;
  };
  cluster.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum4 = 0, children = node.children, i = children && children.length;
  if (!i) sum4 = 1;
  else while (--i >= 0) sum4 += children[i].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count3);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum4 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0) sum4 += children[i].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b) {
  if (a3 === b) return a3;
  var aNodes = a3.ancestors(), bNodes = b.ancestors(), c4 = null;
  a3 = aNodes.pop();
  b = bNodes.pop();
  while (a3 === b) {
    c4 = a3;
    a3 = aNodes.pop();
    b = bNodes.pop();
  }
  return c4;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node(data), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d2) {
  return d2.children;
}
function mapChildren(d2) {
  return Array.isArray(d2) ? d2[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a2 * s2 + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function shuffle(array2, random) {
  let m2 = array2.length, t, i;
  while (m2) {
    i = random() * m2-- | 0;
    t = array2[m2];
    array2[m2] = array2[i];
    array2[i] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B2 = [], p2, e;
  while (i < n) {
    p2 = circles[i];
    if (e && enclosesWeak(e, p2)) ++i;
    else e = encloseBasis(B2 = extendBasis(B2, p2)), i = 0;
  }
  return e;
}
function extendBasis(B2, p2) {
  var i, j;
  if (enclosesWeakAll(p2, B2)) return [p2];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p2, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p2), B2)) {
      return [B2[i], p2];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p2) && enclosesNot(encloseBasis2(B2[i], p2), B2[j]) && enclosesNot(encloseBasis2(B2[j], p2), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p2), B2)) {
        return [B2[i], B2[j], p2];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a3, b) {
  var dr = a3.r - b.r, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b) {
  var dr = a3.r - b.r + Math.max(a3.r, b.r, 1) * 1e-9, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a3, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    r: a3.r
  };
}
function encloseBasis2(a3, b) {
  var x12 = a3.x, y12 = a3.y, r1 = a3.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x2 + x21 / l * r21) / 2,
    y: (y12 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b, c4) {
  var x12 = a3.x, y12 = a3.y, r1 = a3.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c4.x, y3 = c4.y, r3 = c4.r, a22 = x12 - x2, a32 = x12 - x3, b2 = y12 - y2, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C2)) / (2 * A5) : C2 / B2);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a3, c4) {
  var dx = b.x - a3.x, x2, a22, dy = b.y - a3.y, y2, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a3.r + c4.r, a22 *= a22;
    b2 = b.r + c4.r, b2 *= b2;
    if (a22 > b2) {
      x2 = (d2 + b2 - a22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b2 / d2 - x2 * x2));
      c4.x = b.x - x2 * dx - y2 * dy;
      c4.y = b.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a22 - b2) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
      c4.x = a3.x + x2 * dx - y2 * dy;
      c4.y = a3.y + x2 * dy + y2 * dx;
    }
  } else {
    c4.x = a3.x + c4.r;
    c4.y = a3.y;
  }
}
function intersects(a3, b) {
  var dr = a3.r + b.r - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a3 = node._, b = node.next._, ab = a3.r + b.r, dx = (a3.x * b.r + b.x * a3.r) / ab, dy = (a3.y * b.r + b.y * a3.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random) {
  if (!(n = (circles = array_default2(circles)).length)) return 0;
  var a3, b, c4, n, aa, ca, i, j, k2, sj, sk;
  a3 = circles[0], a3.x = 0, a3.y = 0;
  if (!(n > 1)) return a3.r;
  b = circles[1], a3.x = -b.r, b.x = a3.r, b.y = 0;
  if (!(n > 2)) return a3.r + b.r;
  place(b, a3, c4 = circles[2]);
  a3 = new Node2(a3), b = new Node2(b), c4 = new Node2(c4);
  a3.next = c4.previous = b;
  b.next = a3.previous = c4;
  c4.next = b.previous = a3;
  pack: for (i = 3; i < n; ++i) {
    place(a3._, b._, c4 = circles[i]), c4 = new Node2(c4);
    j = b.next, k2 = a3.previous, sj = b._.r, sk = a3._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c4._)) {
          b = j, a3.next = b, b.previous = a3, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k2._, c4._)) {
          a3 = k2, a3.next = b, b.previous = a3, --i;
          continue pack;
        }
        sk += k2._.r, k2 = k2.previous;
      }
    } while (j !== k2.next);
    c4.previous = a3, c4.next = b, a3.next = b.previous = b = c4;
    aa = score(a3);
    while ((c4 = c4.next) !== b) {
      if ((ca = score(c4)) < aa) {
        a3 = c4, aa = ca;
      }
    }
    b = a3.next;
  }
  a3 = [b._], c4 = b;
  while ((c4 = c4.next) !== b) a3.push(c4._);
  c4 = packEncloseRandom(a3, random);
  for (i = 0; i < n; ++i) a3 = circles[i], a3.x -= c4.x, a3.y -= c4.y;
  return c4.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d2) {
  return Math.sqrt(d2.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack3(root) {
    const random = lcg_default();
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack3.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack3) : radius;
  };
  pack3.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack3) : [dx, dy];
  };
  pack3.padding = function(x2) {
    return arguments.length ? (padding = typeof x2 === "function" ? x2 : constant_default2(+x2), pack3) : padding;
  };
  return pack3;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding(node) * k2 || 0, e;
      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packSiblingsRandom(children, random);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round = false;
  function partition2(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(round_default);
    return root;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x05 = node.x0, y05 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round = !!x2, partition2) : round;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding = +x2, partition2) : padding;
  };
  return partition2;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId2(d2) {
  return d2.id;
}
function defaultParentId(d2) {
  return d2.parentId;
}
function stratify_default() {
  var id2 = defaultId2, parentId = defaultParentId, path2;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d2, i, root, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d3, i2) => normalize(path2(d3, i2, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d2 = nodes[i], node = nodes[i] = new Node(d2);
      if ((nodeId = currentId(d2, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d2, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root) throw new Error("no root");
    if (path2 != null) {
      while (root.data === imputed && root.children.length === 1) {
        root = root.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }
  stratify.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify) : id2;
  };
  stratify.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify) : parentId;
  };
  stratify.path = function(x2) {
    return arguments.length ? (path2 = optional(x2), stratify) : path2;
  };
  return stratify;
}
function normalize(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path2, i)) break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k2 = 0;
    while (i > 0 && path2[--i] === "\\") ++k2;
    if ((k2 & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a3, b) {
  return a3.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root.eachBefore(sizeNode);
    else {
      var left2 = root, right2 = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left2.x) left2 = node;
        if (node.x > right2.x) right2 = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x2) {
    return arguments.length ? (separation = x2, tree) : separation;
  };
  tree.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) dice_default(row, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
    else slice_default(row, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent, x05, y05, x12, y12);
  }
  squarify.ratio = function(x2) {
    return custom8((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(round_default);
    return root;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x05 = node.x0 + p2, y05 = node.y0 + p2, x12 = node.x1 - p2, y12 = node.y1 - p2;
    if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
    if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
    node.x0 = x05;
    node.y0 = y05;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x05 += paddingLeft(node) - p2;
      y05 += paddingTop(node) - p2;
      x12 -= paddingRight(node) - p2;
      y12 -= paddingBottom(node) - p2;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      tile(node, x05, y05, x12, y12);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap) : round;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum4, sums = new Array(n + 1);
  for (sums[0] = sum4 = i = 0; i < n; ++i) {
    sums[i + 1] = sum4 += nodes[i].value;
  }
  partition2(0, n, parent.value, x05, y05, x12, y12);
  function partition2(i2, j, value2, x06, y06, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x06, node.y0 = y06;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid2 = k2 + hi >>> 1;
      if (sums[mid2] < valueTarget) k2 = mid2 + 1;
      else hi = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2) --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x06 > y13 - y06) {
      var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
      partition2(i2, k2, valueLeft, x06, y06, xk, y13);
      partition2(k2, j, valueRight, xk, y06, x13, y13);
    } else {
      var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
      partition2(i2, k2, valueLeft, x06, y06, x13, yk);
      partition2(k2, j, valueRight, x06, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x05, y05, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent, x05, y05, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m2 = rows.length, value2 = parent.value;
      while (++j < m2) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) dice_default(row, x05, y05, x12, value2 ? y05 += (y12 - y05) * row.value / value2 : y12);
        else slice_default(row, x05, y05, value2 ? x05 += (x12 - x05) * row.value / value2 : x12, y12);
        value2 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x2) {
    return custom9((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2/esm/utils/treeDataTransform.js
function generateHierarchyRoot(data, path2) {
  if (Array.isArray(data)) {
    return typeof path2 === "function" ? stratify_default().path(path2)(data) : stratify_default()(data);
  }
  return hierarchy(data);
}
function addObjectDataPath(root, path2 = [root.data.name]) {
  root.id = root.id || root.data.name;
  root.path = path2;
  if (root.children) {
    root.children.forEach((item) => {
      item.id = `${root.id}/${item.data.name}`;
      item.path = [...path2, item.data.name];
      addObjectDataPath(item, item.path);
    });
  }
}
function addArrayDataPath(root) {
  const name2 = get_default(root, ["data", "name"]);
  if (name2.replaceAll) {
    root.path = name2.replaceAll(".", "/").split("/");
  }
  if (root.children) {
    root.children.forEach((item) => {
      addArrayDataPath(item);
    });
  }
}
function getTileMethod(tile, ratio) {
  const tiles = {
    treemapBinary: binary_default,
    treemapDice: dice_default,
    treemapSlice: slice_default,
    treemapSliceDice: sliceDice_default,
    treemapSquarify: squarify_default,
    treemapResquarify: resquarify_default
  };
  const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
  if (!tileMethod) {
    throw new TypeError("Invalid tile method!");
  }
  return tileMethod;
}
function treeDataTransform(data, layout, encode) {
  const { value: value2 } = encode;
  const tileMethod = getTileMethod(layout.tile, layout.ratio);
  const root = generateHierarchyRoot(data, layout.path);
  if (isArray(data)) {
    addArrayDataPath(root);
  } else {
    addObjectDataPath(root);
  }
  value2 ? root.sum((d2) => layout.ignoreParentValue && d2.children ? 0 : field(value2)(d2)).sort(layout.sort) : root.count();
  treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root);
  const nodes = root.descendants().map((d2) => Object.assign(d2, {
    id: d2.id.replace(/^\//, ""),
    x: [d2.x0, d2.x1],
    y: [d2.y0, d2.y1]
  }));
  const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d2) => d2.height === layout.layer);
  return [filterData, nodes];
}

// node_modules/@antv/g2/esm/mark/treemap.js
var __rest45 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
  tile: "treemapSquarify",
  ratio: 0.5 * (1 + Math.sqrt(5)),
  size: [width, height],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  sort: (a3, b) => b.value - a3.value,
  layer: 0
});
var GET_DEFAULT_OPTIONS = (width, height) => ({
  type: "rect",
  axis: false,
  encode: {
    x: "x",
    y: "y",
    key: "id",
    color: (d2) => d2.path[1]
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] }
  },
  style: {
    stroke: "#fff"
  },
  state: {
    active: { opacity: 0.6 },
    inactive: { opacity: 1 }
  }
});
var DEFAULT_LABEL_OPTIONS3 = {
  fontSize: 10,
  text: (d2) => last(d2.path),
  position: "inside",
  fill: "#000",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d2) => d2.x1 - d2.x0
};
var DEFAULT_TOOLTIP_OPTIONS = {
  title: (d2) => {
    var _a, _b;
    return (_b = (_a = d2.path) === null || _a === void 0 ? void 0 : _a.join) === null || _b === void 0 ? void 0 : _b.call(_a, ".");
  },
  items: [{ field: "value" }]
};
var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
  title: (d2) => last(d2.path),
  items: [{ field: "value" }]
};
var Treemap = (options, context) => {
  const { width, height, options: markOptions } = context;
  const { data, encode = {}, scale: scale3, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest45(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const treemapDrillDown = get_default(markOptions, [
    "interaction",
    "treemapDrillDown"
  ]);
  const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
    layer: treemapDrillDown ? (d2) => {
      return d2.depth === 1;
    } : layout.layer
  });
  const [transformedData, transformedDataAll] = treeDataTransform(data, layoutOptions, encode);
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
    data: transformedData,
    scale: scale3,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle),
      ...labels
    ]
  }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
    interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
    encode: Object.assign({ color: (d2) => last(d2.path) }, encode),
    tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
  } : {});
};
Treemap.props = {};

// node_modules/@antv/g2/esm/mark/pack.js
var __rest46 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
  size: [width, height],
  padding: 0,
  sort: (a3, b) => b.value - a3.value
});
var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
  type: "point",
  axis: false,
  legend: false,
  scale: {
    x: { domain: [0, width] },
    y: { domain: [0, height] },
    size: { type: "identity" }
  },
  encode: {
    x: "x",
    y: "y",
    size: "r",
    shape: "point"
  },
  style: {
    fill: !encode.color ? (d2) => d2.height === 0 ? "#ddd" : "#fff" : void 0,
    stroke: !encode.color ? (d2) => d2.height === 0 ? "" : "#000" : void 0
  }
});
var DEFAULT_LABEL_OPTIONS4 = {
  text: "",
  position: "inside",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d2) => d2.r * 2
};
var DEFAULT_TOOLTIP_OPTIONS2 = {
  title: (d2) => d2.data.name,
  items: [{ field: "value" }]
};
var dataTransform = (data, layout, encode) => {
  const { value: value2 } = encode;
  const root = isArray(data) ? stratify_default().path(layout.path)(data) : hierarchy(data);
  value2 ? root.sum((d2) => field(value2)(d2)).sort(layout.sort) : root.count();
  pack_default().size(layout.size).padding(layout.padding)(root);
  return root.descendants();
};
var Pack2 = (markOptions, context) => {
  const { width, height } = context;
  const { data, encode = {}, scale: scale3 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest46(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const DEFAULT_OPTIONS8 = GET_DEFAULT_OPTIONS2(width, height, encode);
  const transformedData = dataTransform(data, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS8["encode"], encode));
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, DEFAULT_OPTIONS8, Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale3,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
};
Pack2.props = {};

// node_modules/@antv/g2/esm/mark/boxplot.js
var __rest47 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function min5(I, V) {
  return min(I, (i) => V[i]);
}
function max5(I, V) {
  return max(I, (i) => V[i]);
}
function lower(I, V) {
  const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
  return min(I, (i) => V[i] >= lo ? V[i] : NaN);
}
function q1(I, V) {
  return quantile(I, 0.25, (i) => V[i]);
}
function q2(I, V) {
  return quantile(I, 0.5, (i) => V[i]);
}
function q3(I, V) {
  return quantile(I, 0.75, (i) => V[i]);
}
function upper(I, V) {
  const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
  return max(I, (i) => V[i] <= hi ? V[i] : NaN);
}
function OutlierY() {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y2, x: x2 } = encode;
    const { value: V } = y2;
    const { value: X } = x2;
    const GI = Array.from(group(I, (i) => X[+i]).values());
    const FI = GI.flatMap((I2) => {
      const lo = lower(I2, V);
      const hi = upper(I2, V);
      return I2.filter((i) => V[i] < lo || V[i] > hi);
    });
    return [FI, mark2];
  };
}
var Boxplot = (options) => {
  const { data, encode, style = {}, tooltip: tooltip2 = {}, transform, animate } = options, rest = __rest47(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
  const { point: point6 = true } = style, restStyle = __rest47(style, ["point"]);
  const { y: y2 } = encode;
  const encodeY = { y: y2, y1: y2, y2, y3: y2, y4: y2 };
  const qy = { y1: q1, y2: q2, y3: q3 };
  const boxTooltip = subTooltip(tooltip2, "box", {
    items: [
      { channel: "y", name: "min" },
      { channel: "y1", name: "q1" },
      { channel: "y2", name: "q2" },
      { channel: "y3", name: "q3" },
      { channel: "y4", name: "max" }
    ]
  }, true);
  const pointTooltip = subTooltip(tooltip2, "point", {
    title: { channel: "x" },
    items: [{ name: "outlier", channel: "y" }]
  });
  if (!point6) {
    return Object.assign({ type: "box", data, transform: [
      Object.assign(Object.assign({ type: "groupX", y: min5 }, qy), { y4: max5 })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
  }
  const boxStyle = subObject(restStyle, "box");
  const pointStyle = subObject(restStyle, "point");
  return [
    Object.assign({ type: "box", data, transform: [
      Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate, "box") }, rest),
    // Draw outliers.
    {
      type: "point",
      data,
      transform: [{ type: OutlierY }],
      encode,
      style: Object.assign({}, pointStyle),
      tooltip: pointTooltip,
      animate: maybeAnimation(animate, "point")
    }
  ];
};
Boxplot.props = {};

// node_modules/@antv/g2/esm/mark/shape.js
var shape20 = {
  shape: Shape2
};
var Shape3 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset = createBandOffset(scale3, value2, options);
    const P = Array.from(index2, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset(p2, i))];
    });
    return [index2, P];
  };
};
Shape3.props = {
  defaultShape: "shape",
  defaultLabelShape: "label",
  composite: false,
  shape: shape20,
  channels: [
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition },
    { type: MaybeFunctionAttribute }
  ]
};

// node_modules/@antv/g2/esm/mark/forceGraph.js
var __rest48 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS3 = {
  joint: true
};
var DEFAULT_LINK_OPTIONS3 = {
  type: "link",
  axis: false,
  legend: false,
  encode: {
    x: [(d2) => d2.source.x, (d2) => d2.target.x],
    y: [(d2) => d2.source.y, (d2) => d2.target.y]
  },
  style: {
    stroke: "#999",
    strokeOpacity: 0.6
  }
};
var DEFAULT_NODE_OPTIONS3 = {
  type: "point",
  axis: false,
  legend: false,
  encode: {
    x: "x",
    y: "y",
    size: 5,
    color: "group",
    shape: "point"
  },
  style: {
    stroke: "#fff"
  }
};
var DEFAULT_LABEL_OPTIONS5 = {
  text: ""
};
function dataTransform2(data, layout, encode) {
  const { nodes, links } = data;
  const { joint, nodeStrength, linkStrength } = layout;
  const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = encode;
  const nodeForce = manyBody_default();
  const linkForce = link_default(links).id(field(linkKey));
  typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
  typeof linkStrength === "function" && linkForce.strength(linkStrength);
  const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
  joint ? simulation.force("center", center_default()) : simulation.force("x", x_default()).force("y", y_default());
  simulation.stop();
  const n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
  for (let i = 0; i < n; i++)
    simulation.tick();
  return {
    nodesData: nodes,
    linksData: links
  };
}
var ForceGraph = (options) => {
  const { data, encode: e = {}, scale: scale3, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = e, restEncode = __rest48(e, ["nodeKey", "linkKey"]);
  const encode = Object.assign({ nodeKey, linkKey }, restEncode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { links, nodes } = initializeData(data, encode);
  const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
  const linkTooltip = subTooltip(tooltip2, "link", {
    items: [
      (d2) => ({ name: "source", value: field(linkKey)(d2.source) }),
      (d2) => ({ name: "target", value: field(linkKey)(d2.target) })
    ]
  });
  const nodeTooltip = subTooltip(tooltip2, "node", {
    items: [(d2) => ({ name: "key", value: field(nodeKey)(d2) })]
  }, true);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
      data: linksData,
      encode: linkEncode,
      labels: linkLabels,
      style: subObject(style, "link"),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
      data: nodesData,
      encode: Object.assign({}, nodeEncode),
      scale: scale3,
      style: subObject(style, "node"),
      tooltip: nodeTooltip,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
        ...nodeLabels
      ],
      animate: maybeAnimation(animate, "link")
    })
  ];
};
ForceGraph.props = {};

// node_modules/@antv/g2/esm/data/cluster.js
var hierarchyFunction = (layoutFunction) => (options) => {
  return (data) => {
    const { field: field3 = "value", nodeSize, separation, sortBy: sortBy2, as = ["x", "y"] } = options;
    const [x2, y2] = as;
    const root = hierarchy(data, (d2) => d2.children).sum((d2) => d2[field3]).sort(sortBy2);
    const c4 = layoutFunction();
    c4.size([1, 1]);
    if (nodeSize)
      c4.nodeSize(nodeSize);
    if (separation)
      c4.separation(separation);
    c4(root);
    const nodes = [];
    root.each((node) => {
      node[x2] = node.x;
      node[y2] = node.y;
      node.name = node.data.name;
      nodes.push(node);
    });
    const edges = root.links();
    edges.forEach((edge) => {
      edge[x2] = [edge.source[x2], edge.target[x2]];
      edge[y2] = [edge.source[y2], edge.target[y2]];
    });
    return { nodes, edges };
  };
};
var Cluster = (options) => {
  return hierarchyFunction(cluster_default)(options);
};
Cluster.props = {};

// node_modules/@antv/g2/esm/data/tree.js
var Tree = (options) => {
  return hierarchyFunction(tree_default)(options);
};
Tree.props = {};

// node_modules/@antv/g2/esm/mark/tree.js
var DEFAULT_LAYOUT_OPTIONS4 = {
  sortBy: (a3, b) => b.value - a3.value
};
var DEFAULT_NODE_OPTIONS4 = {
  axis: false,
  legend: false,
  type: "point",
  encode: {
    x: "x",
    y: "y",
    size: 2,
    shape: "point"
  }
};
var DEFAULT_LINK_OPTIONS4 = {
  type: "link",
  encode: {
    x: "x",
    y: "y",
    shape: "smooth"
  }
};
var DEFAULT_LABEL_OPTIONS6 = {
  text: "",
  fontSize: 10
};
var Tree2 = (options) => {
  const { data, encode = {}, scale: scale3 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
  const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "name",
    items: ["value"]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d2) => ({ name: "source", value: d2.source.name }),
      (d2) => ({ name: "target", value: d2.target.name })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
      data: edges,
      encode: subObject(encode, "link"),
      scale: subObject(scale3, "link"),
      labels: linkLabels,
      style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
      data: nodes,
      scale: subObject(scale3, "node"),
      encode: subObject(encode, "node"),
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
        ...nodeLabels
      ],
      style: Object.assign({}, subObject(style, "node")),
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node")
    })
  ];
};
Tree2.props = {};

// node_modules/@antv/g2/esm/mark/wordCloud.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest49 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function initializeData2(data, encode) {
  const { text = "text", value: value2 = "value" } = encode;
  return data.map((d2) => Object.assign(Object.assign({}, d2), { text: d2[text], value: d2[value2] }));
}
var GET_DEFAULT_OPTIONS3 = () => ({
  axis: false,
  type: "text",
  encode: {
    x: "x",
    y: "y",
    text: "text",
    rotate: "rotate",
    fontSize: "size",
    shape: "tag"
  },
  scale: {
    x: { range: [0, 1] },
    y: { range: [0, 1] }
  },
  style: {
    fontFamily: (d2) => d2.fontFamily
  }
});
var WordCloud = (options, context) => __awaiter2(void 0, void 0, void 0, function* () {
  const { width, height } = context;
  const { data, encode = {}, scale: scale3, style = {}, layout = {} } = options, resOptions = __rest49(options, ["data", "encode", "scale", "style", "layout"]);
  const initializedData = initializeData2(data, encode);
  return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
    data: {
      value: initializedData,
      transform: [
        Object.assign({ type: "wordCloud", size: [width, height] }, layout)
      ]
    },
    encode,
    scale: scale3,
    style
  }, resOptions), { axis: false }));
});
WordCloud.props = {};

// node_modules/@antv/g2/esm/mark/gauge.js
var __rest50 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var indicatorShape = (options, context) => {
  const { shape: shape23, radius } = options, style = __rest50(options, ["shape", "radius"]);
  const pointerStyle = subObject(style, "pointer");
  const pinStyle = subObject(style, "pin");
  const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest50(pointerStyle, ["shape"]);
  const { shape: pinShape } = pinStyle, resPinStyle = __rest50(pinStyle, ["shape"]);
  const { coordinate, theme } = context;
  return (points, value2) => {
    const invertedPoints = points.map((p2) => coordinate.invert(p2));
    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
    const newCoordinate = coordinate.clone();
    const { color: stroke2 } = value2;
    const newTransformations = Radial({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius: radius
    });
    newTransformations.push(["cartesian"]);
    newCoordinate.update({
      transformations: newTransformations
    });
    const newPoints = invertedPoints.map((p2) => newCoordinate.map(p2));
    const [x2, y2] = getOrigin(newPoints);
    const [cx, cy] = coordinate.getCenter();
    const pointerAttrs = Object.assign(Object.assign({ x1: x2, y1: y2, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
    const pinAttrs = Object.assign(Object.assign({
      cx,
      cy,
      stroke: stroke2
    }, resPinStyle), style);
    const indicatorGroup = select(new Group());
    if (!isUnset(pointerShape)) {
      typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
    }
    if (!isUnset(pinShape)) {
      typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
    }
    return indicatorGroup.node();
  };
};
var DEFAULT_OPTIONS3 = {
  coordinate: {
    type: "radial",
    innerRadius: 0.9,
    outerRadius: 1,
    startAngle: -11 / 10 * Math.PI,
    endAngle: 1 / 10 * Math.PI
  },
  axis: {
    x: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "x",
    y: "y",
    color: "color"
  },
  scale: {
    color: {
      range: ["#30BF78", "#D0D0D0"]
    }
  }
};
var DEFAULT_INDICATOR_OPTIONS = {
  style: {
    shape: indicatorShape,
    lineWidth: 4,
    pointerLineCap: "round",
    pinR: 10,
    pinFill: "#fff",
    radius: 0.6
  }
};
var DEFAULT_TEXT_OPTIONS = {
  type: "text",
  style: {
    x: "50%",
    y: "60%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  tooltip: false
};
function getGaugeData(data) {
  if (isNumber(data)) {
    const percent = Math.max(0, Math.min(data, 1));
    return {
      percent,
      target: percent,
      total: 1
    };
  }
  return data;
}
function dataTransform3(data, scale3) {
  const { name: name2 = "score", target, total, percent, thresholds = [] } = getGaugeData(data);
  const _target = percent || target;
  const _total = percent ? 1 : total;
  const newScale = Object.assign({ y: {
    domain: [0, _total]
  } }, scale3);
  if (!thresholds.length) {
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: [
        { x: name2, y: _target, color: "target" },
        { x: name2, y: _total - _target, color: "total" }
      ],
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  return {
    targetData: [{ x: name2, y: _target, color: "target" }],
    totalData: thresholds.map((d2, i) => ({
      x: name2,
      y: i >= 1 ? d2 - thresholds[i - 1] : d2,
      color: i
    })),
    target: _target,
    total: _total,
    scale: newScale
  };
}
function getTextContent(textStyle, { target, total }) {
  const { content } = textStyle;
  return content ? content(target, total) : target.toString();
}
var Gauge = (options) => {
  const { data = {}, scale: scale3 = {}, style = {}, animate = {}, transform = [] } = options, resOptions = __rest50(options, ["data", "scale", "style", "animate", "transform"]);
  const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data, scale3);
  const _a = subObject(style, "text"), { tooltip: tooltip2 } = _a, textStyle = __rest50(_a, ["tooltip"]);
  const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
  const arcStyle = subObject(style, "arc");
  const shape23 = arcStyle.shape;
  return [
    deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape23 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate === "object" ? subObject(animate, "arc") : animate }, resOptions)),
    deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate === "object" ? subObject(animate, "indicator") : animate }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
      style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
      tooltip: tooltip2,
      animate: typeof animate === "object" ? subObject(animate, "text") : animate
    })
  ];
};
Gauge.props = {};

// node_modules/@antv/g2/esm/mark/density.js
var shape21 = {
  density: Density
};
var Density2 = () => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, series: S } = value2;
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
    if (X === void 0 || Yn2 === void 0 || SZn === void 0) {
      throw new Error("Missing encode for x or y or size channel.");
    }
    const xScale = scale3.x;
    const series = scale3.series;
    const P = Array.from(index2, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x2 = +X[i] + offset + width / 2;
      const PN = [
        ...Yn2.map((_, idx) => [x2 + +SZn[idx][i] / index2.length, +Yn2[idx][i]]),
        ...Yn2.map((_, idx) => [
          x2 - +SZn[idx][i] / index2.length,
          +Yn2[idx][i]
        ]).reverse()
        // left
      ];
      return PN.map((p2) => coordinate.map(p2));
    });
    return [index2, P];
  };
};
Density2.props = {
  defaultShape: "density",
  defaultLabelShape: "label",
  composite: false,
  shape: shape21,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "size", required: true },
    { name: "series", scale: "band" },
    { name: "size", required: true, scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/heatmap.js
var shape22 = {
  heatmap: Heatmap
};
var Heatmap2 = (options) => {
  return (index2, scale3, value2, coordinate) => {
    const { x: X, y: Y, size: S, color: C2 } = value2;
    const P = Array.from(index2, (i) => {
      const r = S ? +S[i] : 40;
      return [...coordinate.map([+X[i], +Y[i]]), C2[i], r];
    });
    return [[0], [P]];
  };
};
Heatmap2.props = {
  defaultShape: "heatmap",
  defaultLabelShape: "label",
  composite: false,
  shape: shape22,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "color", scale: "identity", required: true },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/liquid.js
var __rest51 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS4 = {
  axis: {
    x: false,
    y: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "type",
    y: "percent"
  },
  scale: {
    y: {
      domain: [0, 1]
    }
  },
  style: {
    shape: Liquid
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var DEFAULT_TEXT_OPTIONS2 = {
  type: "text",
  style: {
    x: "50%",
    y: "50%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var Liquid2 = (options) => {
  const { data = {}, style = {}, animate } = options, resOptions = __rest51(options, ["data", "style", "animate"]);
  const percent = Math.max(0, isNumber(data) ? data : data === null || data === void 0 ? void 0 : data.percent);
  const newData = [{ percent, type: "liquid" }];
  const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
  const outline = subObject(style, "outline");
  const wave = subObject(style, "wave");
  const background = subObject(style, "background");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
      liquidOptions: {
        percent,
        liquidShape: style === null || style === void 0 ? void 0 : style.shape
      },
      styleOptions: Object.assign(Object.assign({}, style), {
        outline,
        wave,
        background
      })
    }, animate }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
      style: Object.assign({ text: `${prettyNumber(percent * 100)} %` }, contentStyle),
      animate
    })
  ];
};
Liquid2.props = {};

// node_modules/@antv/g2/esm/palette/category10.js
var Category10 = () => {
  return [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
};
Category10.props = {};

// node_modules/@antv/g2/esm/palette/category20.js
var Category20 = () => {
  return [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
};
Category20.props = {};

// node_modules/@antv/g2/esm/scale/band.js
var Band2 = (options) => {
  return new Band(options);
};
Band2.props = {};

// node_modules/@antv/g2/esm/scale/linear.js
var Linear3 = (options) => {
  return new Linear(options);
};
Linear3.props = {};

// node_modules/@antv/g2/esm/scale/ordinal.js
var Ordinal2 = (options) => {
  return new Ordinal(options);
};
Ordinal2.props = {};

// node_modules/@antv/g2/esm/scale/identity.js
var Identity2 = (options) => {
  return new Identity(options);
};
Identity2.props = {};

// node_modules/@antv/g2/esm/scale/point.js
var Point4 = (options) => {
  return new Point(options);
};
Point4.props = {};

// node_modules/@antv/g2/esm/scale/time.js
var Time2 = (options) => {
  return new Time(options);
};
Time2.props = {};

// node_modules/@antv/g2/esm/scale/log.js
var Log2 = (options) => {
  return new Log(options);
};
Log2.props = {};

// node_modules/@antv/g2/esm/scale/pow.js
var Pow2 = (options) => {
  return new Pow(options);
};
Pow2.props = {};

// node_modules/@antv/g2/esm/scale/threshold.js
var Threshold2 = (options) => {
  return new Threshold(options);
};
Threshold2.props = {};

// node_modules/@antv/g2/esm/scale/quantile.js
var Quantile2 = (options) => {
  return new Quantile(options);
};
Quantile2.props = {};

// node_modules/@antv/g2/esm/scale/quantize.js
var Quantize2 = (options) => {
  return new Quantize(options);
};
Quantize2.props = {};

// node_modules/@antv/g2/esm/scale/sqrt.js
var Sqrt2 = (options) => {
  return new Sqrt(options);
};
Sqrt2.props = {};

// node_modules/@antv/g2/esm/scale/sequential.js
var Sequential2 = (options) => {
  return new Sequential(options);
};
Sequential2.props = {};

// node_modules/@antv/g2/esm/scale/constant.js
var Constant3 = (options) => {
  return new Constant(options);
};
Constant3.props = {};

// node_modules/@antv/g2/esm/theme/create.js
function create({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
  return {
    padding,
    margin,
    size: sizeDefault,
    color: colorDefault,
    category10,
    category20,
    enter: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    update: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    exit: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    view: {
      viewFill: colorBackground,
      plotFill: "transparent",
      mainFill: "transparent",
      contentFill: "transparent"
    },
    line: {
      line: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 1,
        lineCap: "round"
      }
    },
    point: {
      point: {
        r: 3,
        fillOpacity: 0.95,
        lineWidth: 0
      },
      hollow: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      },
      plus: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 3
      },
      diamond: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      }
    },
    interval: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    area: {
      area: {
        fillOpacity: 0.85,
        lineWidth: 0
      }
    },
    polygon: {
      polygon: {
        fillOpacity: 0.95
      }
    },
    cell: {
      cell: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    rect: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    link: {
      link: {
        fill: "",
        strokeOpacity: 1
      }
    },
    vector: {
      vector: {
        fillOpacity: 1
      }
    },
    box: {
      box: {
        fillOpacity: 0.95,
        stroke: colorBlack,
        lineWidth: 1
      }
    },
    text: {
      text: {
        fill: "#1D2129",
        fontSize: 12,
        lineWidth: 0,
        connectorStroke: colorStroke,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: colorStroke,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: "circle",
        startMarkerSize: 4,
        endMarkerSymbol: "circle",
        endMarkerSize: 4
      },
      badge: {
        fill: "#1D2129",
        fillOpacity: 0.65,
        lineWidth: 0,
        fontSize: 10,
        textAlign: "center",
        textBaseline: "middle",
        markerFill: colorStroke,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    lineY: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    rangeX: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    rangeY: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    connector: {
      connector: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: true,
        endMarkerSize: 6,
        endMarkerFill: colorStroke,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: false,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: colorBlack,
      gridStrokeOpacity: alpha10,
      labelAlign: "horizontal",
      labelFill: colorBlack,
      labelOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: padding1,
      line: false,
      lineLineWidth: 0.5,
      lineStroke: colorBlack,
      lineStrokeOpacity: alpha45,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: colorBlack,
      tickOpacity: alpha45,
      titleFill: colorBlack,
      titleOpacity: alpha90,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 12,
      titleTransformOrigin: "center",
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: "positive",
      labelDirection: "negative",
      tickDirection: "negative",
      titlePosition: "top",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "middle"
    },
    axisBottom: {
      gridDirection: "negative",
      labelDirection: "positive",
      tickDirection: "positive",
      titlePosition: "bottom",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "bottom",
      titleTransform: "translate(0, 8)"
    },
    axisLeft: {
      gridDirection: "positive",
      labelDirection: "negative",
      labelSpacing: 4,
      tickDirection: "negative",
      titlePosition: "left",
      titleSpacing: 12,
      titleTextBaseline: "middle",
      titleDirection: "vertical",
      titleTransform: "rotate(-90) translate(0, -8)",
      titleTransformOrigin: "center"
    },
    axisRight: {
      gridDirection: "negative",
      labelDirection: "positive",
      labelSpacing: 4,
      tickDirection: "positive",
      titlePosition: "right",
      titleSpacing: 12,
      titleTextBaseline: "top",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisLinear: {
      girdClosed: true,
      gridConnect: "arc",
      gridDirection: "negative",
      gridType: "surround",
      titlePosition: "top",
      titleSpacing: 0
    },
    axisArc: {
      title: false,
      titlePosition: "inner",
      line: false,
      tick: true,
      labelSpacing: 4
    },
    axisRadar: {
      girdClosed: true,
      gridStrokeOpacity: 0.3,
      gridType: "surround",
      label: false,
      tick: false,
      titlePosition: "start"
    },
    legendCategory: {
      backgroundFill: "transparent",
      itemBackgroundFill: "transparent",
      itemLabelFill: colorBlack,
      itemLabelFillOpacity: alpha90,
      itemLabelFontSize: 12,
      itemLabelFontWeight: "normal",
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      itemSpacing: [padding1, padding1],
      itemValueFill: colorBlack,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: "normal",
      navButtonFill: colorBlack,
      navButtonFillOpacity: 0.65,
      navPageNumFill: colorBlack,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: false,
      titleFill: colorBlack,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 4,
      tickStroke: colorBlack,
      tickStrokeOpacity: 0.25,
      rowPadding: padding1,
      colPadding: padding2,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: alpha45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal",
      handleMarkerFill: colorBlack,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: colorBlack,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: colorBlack,
      labelFillOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: 3,
      tick: true,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: "#aaa",
      handle: true,
      handleLabel: false,
      handleShape: "slider",
      handleIconSize: 12 / 1.8,
      indicator: false,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: "normal",
      titleFillOpacity: alpha90,
      tickStroke: colorBlack,
      tickStrokeOpacity: alpha45
    },
    label: {
      fill: colorBlack,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: "normal",
      stroke: void 0,
      offset: 12,
      connectorStroke: colorBlack,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: colorWhite,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: "normal",
      stroke: void 0,
      offset: 0
    },
    htmlLabel: {
      fontSize: 12,
      opacity: 0.65,
      color: colorBlack,
      fontWeight: "normal"
    },
    slider: {
      trackSize: 16,
      trackFill: colorStroke,
      trackFillOpacity: 1,
      selectionFill: colorDefault,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: "#f7f7f7",
      handleIconFillOpacity: 1,
      handleIconStroke: colorBlack,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal"
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: true,
      slidable: true,
      scrollable: true,
      trackFill: "#e5e5e5",
      trackFillOpacity: 0,
      thumbFill: "#000",
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: colorBlack,
      titleFillOpacity: alpha90,
      titleFontSize: 16,
      titleFontWeight: "bold",
      titleTextBaseline: "top",
      subtitleFill: colorBlack,
      subtitleFillOpacity: alpha65,
      subtitleFontSize: 12,
      subtitleFontWeight: "normal",
      subtitleTextBaseline: "top"
    },
    tooltip: {
      css: {
        ".g2-tooltip": {
          "font-family": "sans-serif"
        }
      }
    }
  };
}

// node_modules/@antv/g2/esm/theme/light.js
var tokens = {
  colorBlack: "#1D2129",
  colorWhite: "#ffffff",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults = create(tokens);
var Light = (options) => {
  return deep_mix_default({}, defaults, options);
};
Light.props = {};

// node_modules/@antv/g2/esm/theme/classic.js
var Classic = (options) => {
  return deep_mix_default({}, Light(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
Classic.props = {};

// node_modules/@antv/g2/esm/theme/dark.js
var tokens2 = {
  colorBlack: "#fff",
  colorWhite: "#000",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.25
};
var defaults2 = create(tokens2);
var Dark = (options) => {
  return deep_mix_default({}, defaults2, {
    tooltip: {
      crosshairsStroke: "#fff",
      crosshairsLineWidth: 1,
      crosshairsStrokeOpacity: 0.25,
      css: {
        ".g2-tooltip": {
          background: "#1f1f1f",
          opacity: 0.95
        },
        ".g2-tooltip-title": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-name-label": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-value": {
          color: "#A6A6A6"
        }
      }
    }
  }, options);
};

// node_modules/@antv/g2/esm/theme/classicDark.js
var ClassicDark = (options) => {
  return Object.assign({}, Dark(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
ClassicDark.props = {};

// node_modules/@antv/g2/esm/theme/academy.js
var tokens3 = {
  colorBlack: "#000",
  colorWhite: "#fff",
  colorStroke: "#888",
  colorDefault: "#4e79a7",
  colorBackground: "transparent",
  category10: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  category20: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults3 = create(tokens3);
var Academy = (options) => {
  return deep_mix_default({}, defaults3, {
    text: { text: { fontSize: 10 } },
    axis: {
      gridLineDash: [0, 0],
      gridLineWidth: 1,
      gridStroke: "#ddd",
      gridStrokeOpacity: 1,
      labelOpacity: 1,
      labelStrokeOpacity: 1,
      labelFontSize: 10,
      line: true,
      lineLineWidth: 1,
      lineStroke: "#888",
      lineStrokeOpacity: 1,
      tickLength: 5,
      tickStrokeOpacity: 1,
      titleOpacity: 1,
      titleStrokeOpacity: 1,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    axisLeft: {
      gridFilter: (_, i) => i !== 0
    },
    axisRight: {
      gridFilter: (_, i) => i !== 0
    },
    legendCategory: {
      itemLabelFillOpacity: 1,
      itemLabelFontSize: 10,
      itemValueFillOpacity: 1,
      itemValueFontSize: 10,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    legendContinuous: {
      handleLabelFontSize: 10,
      labelFillOpacity: 0.45,
      labelFontSize: 10
    },
    label: {
      fontSize: 10
    },
    innerLabel: {
      fontSize: 10
    },
    htmlLabel: {
      fontSize: 10
    },
    slider: {
      handleLabelFontSize: 10,
      trackFillOpacity: 0.05
    }
  }, options);
};
Academy.props = {};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value2.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent = d2[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent = d2[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded_default(x2 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c4;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c4 = value2.charCodeAt(i), 48 > c4 || c4 > 57) {
              valueSuffix = (c4 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group2(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value2 = group2(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@antv/g2/esm/component/utils.js
var __rest52 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createComponent(descriptor) {
  return class extends CustomElement {
    constructor(config) {
      super(config);
      this.descriptor = descriptor;
    }
    connectedCallback() {
      var _a, _b;
      (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
    }
    update(cfg = {}) {
      var _a, _b;
      this.attr(deep_mix_default({}, this.attributes, cfg));
      (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
    }
  };
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}
function titleContent(field3) {
  return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
}
function inferComponentLayout(position, userDefinitions) {
  const preset = {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-start",
    alignItems: "center"
  };
  let { flexDirection, justifyContent, alignItems } = preset;
  const layout = {
    top: ["row", "flex-start", "center"],
    bottom: ["row", "flex-start", "center"],
    left: ["column", "flex-start", "center"],
    right: ["column", "flex-start", "center"],
    center: ["column", "center", "center"]
  };
  if (position in layout) {
    [flexDirection, justifyContent, alignItems] = layout[position];
  }
  return Object.assign({
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems
  }, userDefinitions);
}
var G2Layout = class extends Layout {
  get child() {
    var _a;
    return (_a = this.children) === null || _a === void 0 ? void 0 : _a[0];
  }
  update(options) {
    var _a;
    this.attr(options);
    const { subOptions } = options;
    (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
  }
};
var LegendCategoryLayout = class extends G2Layout {
  update(options) {
    var _a;
    const { subOptions } = options;
    this.attr(options);
    (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
  }
};
function scaleOf(scales, type) {
  var _a;
  return (_a = scales.filter((s2) => s2.getOptions().name === type)) === null || _a === void 0 ? void 0 : _a[0];
}
function isHorizontal(orientation) {
  return orientation === "horizontal" || orientation === 0;
}
function isVertical(orientation) {
  return orientation === "vertical" || orientation === -Math.PI / 2;
}
function inferComponentShape(value2, options, component) {
  const { bbox } = value2;
  const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
  const isHorizontal2 = ["top", "bottom", "center"].includes(position);
  const [bboxSize, bboxLength] = isHorizontal2 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
  const { defaultSize, defaultLength } = component.props;
  const size3 = userDefinedSize || defaultSize || bboxSize;
  const length = userDefinedLength || defaultLength || bboxLength;
  const orientation = isHorizontal2 ? "horizontal" : "vertical";
  const [width, height] = isHorizontal2 ? [length, size3] : [size3, length];
  return {
    orientation,
    width,
    height,
    size: size3,
    length
  };
}
function domainOf2(scales) {
  return scales.find((scale3) => scale3.getOptions().domain.length > 0).getOptions().domain;
}
function adaptor(style) {
  const reservedKeys = [
    "arrow",
    "crosshairs",
    "grid",
    "handle",
    "handleLabel",
    "indicator",
    "label",
    "line",
    "tick",
    "tip",
    "title",
    "trunc"
  ];
  const { style: styles } = style, rest = __rest52(style, ["style"]);
  const finalStyle = {};
  Object.entries(rest).forEach(([key, value2]) => {
    if (reservedKeys.includes(key)) {
      finalStyle[`show${upper_first_default(key)}`] = value2;
    } else
      finalStyle[key] = value2;
  });
  return Object.assign(Object.assign({}, finalStyle), styles);
}

// node_modules/@antv/g2/esm/component/axis.js
var __rest53 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function rotateAxis(axis, options) {
  const { eulerAngles, origin } = options;
  if (origin) {
    axis.setOrigin(origin);
  }
  if (eulerAngles) {
    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
  }
}
function sizeOf(coordinate) {
  const { innerWidth, innerHeight, depth } = coordinate.getOptions();
  return [innerWidth, innerHeight, depth];
}
function createFisheye(position, coordinate) {
  const { width, height } = coordinate.getOptions();
  return (tick2) => {
    if (!isFisheye(coordinate))
      return tick2;
    const tickPoint = position === "bottom" ? [tick2, 1] : [0, tick2];
    const vector = coordinate.map(tickPoint);
    if (position === "bottom") {
      const v = vector[0];
      const x2 = new Linear({
        domain: [0, width],
        range: [0, 1]
      });
      return x2.map(v);
    } else if (position === "left") {
      const v = vector[1];
      const x2 = new Linear({
        domain: [0, height],
        range: [0, 1]
      });
      return x2.map(v);
    }
    return tick2;
  };
}
function ticksOf(scale3, domain, tickMethod) {
  if (scale3.getTicks)
    return scale3.getTicks();
  if (!tickMethod)
    return domain;
  const [min6, max6] = extent(domain, (d2) => +d2);
  const { tickCount } = scale3.getOptions();
  return tickMethod(min6, max6, tickCount);
}
function createInset(position, coordinate) {
  if (isPolar(coordinate))
    return (d2) => d2;
  const options = coordinate.getOptions();
  const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
  const [start, end, size3] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
  const x2 = new Linear({
    domain: [0, 1],
    range: [start / size3, 1 - end / size3]
  });
  return (i) => x2.map(i);
}
function getData(scale3, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
  var _a;
  if (tickCount !== void 0 || tickMethod !== void 0) {
    scale3.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
  }
  const ticks2 = ticksOf(scale3, domain, tickMethod);
  const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
  const toString3 = (d2) => d2 instanceof Date ? String(d2) : typeof d2 === "object" && !!d2 ? d2 : String(d2);
  const labelFormatter = defaultTickFormatter || ((_a = scale3.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale3)) || toString3;
  const applyInset = createInset(position, coordinate);
  const applyFisheye = createFisheye(position, coordinate);
  const isHorizontal2 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
  const isVertical2 = (position2) => ["left", "right"].includes(position2);
  if (isPolar(coordinate) || isTranspose(coordinate)) {
    return filteredTicks.map((d2, i, array2) => {
      var _a2, _b;
      const offset = ((_a2 = scale3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale3, d2)) / 2 || 0;
      const tick2 = applyInset(scale3.map(d2) + offset);
      const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale3.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale3)) && isHorizontal2(position) || isTranspose(coordinate) && isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick2 : tick2,
        label: toString3(labelFormatter(prettyNumber(d2), i, array2)),
        id: String(i)
      };
    });
  }
  return filteredTicks.map((d2, i, array2) => {
    var _a2;
    const offset = ((_a2 = scale3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale3, d2)) / 2 || 0;
    const tick2 = applyFisheye(applyInset(scale3.map(d2) + offset));
    const shouldReverse = isVertical2(position);
    return {
      value: shouldReverse ? 1 - tick2 : tick2,
      label: toString3(labelFormatter(prettyNumber(d2), i, array2)),
      id: String(i)
    };
  });
}
function inferGridLength(position, coordinate, plane = "xy") {
  const [width, height, depth] = sizeOf(coordinate);
  if (plane === "xy") {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return width;
  } else if (plane === "xz") {
    if (position.includes("bottom") || position.includes("top"))
      return depth;
    return width;
  } else {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return depth;
  }
}
function inferLabelOverlap(transform = [], style) {
  if (transform.length > 0)
    return transform;
  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
  const finalTransforms = [];
  const addToTransforms = (overlap, state) => {
    if (state) {
      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
    }
  };
  addToTransforms({
    type: "rotate",
    optionalAngles: [0, 15, 30, 45, 60, 90]
  }, labelAutoRotate);
  addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
  addToTransforms({ type: "hide" }, labelAutoHide);
  addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
  return finalTransforms;
}
function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
  const { x: x2, y: y2, width, height } = bbox;
  const center2 = [x2 + width / 2, y2 + height / 2];
  const radius = Math.min(width, height) / 2;
  const [startAngle, endAngle] = angleOf(coordinate);
  const [w, h] = sizeOf(coordinate);
  const r = Math.min(w, h) / 2;
  const common = {
    center: center2,
    radius,
    startAngle,
    endAngle,
    gridLength: (outerRadius - innerRadius) * r
  };
  if (position === "inner") {
    const { insetLeft, insetTop } = coordinate.getOptions();
    return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
  }
  return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
}
function inferGrid(value2, coordinate, scale3) {
  if (isTheta(coordinate) || isParallel(coordinate))
    return false;
  return value2 === void 0 ? !!scale3.getTicks : value2;
}
function infer3DAxisLinearOverrideStyle(coordinate) {
  const { depth } = coordinate.getOptions();
  return depth ? {
    tickIsBillboard: true,
    lineIsBillboard: true,
    labelIsBillboard: true,
    titleIsBillboard: true,
    gridIsBillboard: true
  } : {};
}
function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
  const { x: x2, y: y2, width, height } = bbox;
  if (position === "bottom") {
    return { startPos: [x2, y2], endPos: [x2 + width, y2] };
  }
  if (position === "left") {
    return { startPos: [x2 + width, y2 + height], endPos: [x2 + width, y2] };
  }
  if (position === "right") {
    return { startPos: [x2, y2 + height], endPos: [x2, y2] };
  }
  if (position === "top") {
    return { startPos: [x2, y2 + height], endPos: [x2 + width, y2 + height] };
  }
  if (position === "center") {
    if (orientation === "vertical") {
      return {
        startPos: [x2, y2],
        endPos: [x2, y2 + height]
      };
    } else if (orientation === "horizontal") {
      return {
        startPos: [x2, y2],
        endPos: [x2 + width, y2]
      };
    } else if (typeof orientation === "number") {
      const [cx, cy] = coordinate.getCenter();
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const [startAngle, endAngle] = angleOf(coordinate);
      const r = Math.min(width, height) / 2;
      const { insetLeft, insetTop } = coordinate.getOptions();
      const innerR = innerRadius * r;
      const outerR = outerRadius * r;
      const [actualCx, actualCy] = [cx + x2 - insetLeft, cy + y2 - insetTop];
      const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
      const startPos = [
        actualCx + outerR * cos3,
        actualCy + outerR * sin3
      ];
      const endPos = [
        actualCx + innerR * cos3,
        actualCy + innerR * sin3
      ];
      const getAxisXDomainLength = () => {
        const { domain } = xScale.getOptions();
        return domain.length;
      };
      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
      return {
        startPos,
        endPos,
        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
        gridCenter: [actualCx, actualCy],
        gridControlAngles: new Array(controllAngleCount).fill(0).map((d2, i, arr) => (endAngle - startAngle) / controllAngleCount * i)
      };
    }
  }
  return {};
}
var ArcAxisComponent = (options) => {
  const { order, size: size3, position, orientation, labelFormatter, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid = false } = options, rest = __rest53(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
  return ({ scales: [scale3], value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const { domain } = scale3.getOptions();
    const data = getData(scale3, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data.map((d2, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d2;
      if (bbox2[0] !== d2.label)
        return d2;
      return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
    }) : data;
    const [innerRadius, outerRadius] = radiusOf(coordinate);
    const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
    const { axis: axisTheme, axisArc = {} } = theme;
    const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid }, rest), important)));
    return new Axis({
      // @fixme transform is not valid for arcAxis.
      // @ts-ignore
      style: omit_default(finalStyle, ["transform"])
    });
  };
};
function inferThemeStyle(scale3, coordinate, theme, direction, position, orientation) {
  const baseStyle = theme.axis;
  const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
  const channel = scale3.getOptions().name;
  const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
  return Object.assign({}, baseStyle, positionStyle, channelStyle);
}
function inferDefaultStyle(scale3, coordinate, theme, direction, position, orientation) {
  const themeStyle = inferThemeStyle(scale3, coordinate, theme, direction, position, orientation);
  if (position === "center") {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction === "right" ? "negative" : "positive" }), direction === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction === "right" ? "negative" : "positive", labelSpacing: direction === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction === "center" ? false : void 0 });
  }
  return themeStyle;
}
var LinearAxisComponent = (options) => {
  const { direction = "left", important = {}, labelFormatter, order, orientation, actualPosition, position, size: size3, style = {}, title, tickCount, tickFilter, tickMethod, transform, indexBBox } = options, userDefinitions = __rest53(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
  return ({ scales, value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const [scale3] = scales;
    const { domain, xScale } = scale3.getOptions();
    const defaultStyle2 = inferDefaultStyle(scale3, coordinate, theme, direction, position, orientation);
    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
    const data = getData(scale3, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data.map((d2, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d2;
      if (bbox2[0] !== d2.label)
        return d2;
      return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
    }) : data;
    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
      type: "linear",
      data: labels,
      crossSize: size3,
      titleText: titleContent(title),
      labelOverlap: inferLabelOverlap(transform, internalAxisStyle),
      grid: inferGrid(internalAxisStyle.grid, coordinate, scale3),
      gridLength,
      // Always showLine, make title could align the end of axis.
      line: true,
      indexBBox
    }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
    const hasHide = finalAxisStyle.labelOverlap.find((d2) => d2.type === "hide");
    if (hasHide)
      finalAxisStyle.crossSize = false;
    return new Axis({
      className: "axis",
      style: adaptor(finalAxisStyle)
    });
  };
};
var axisFactor = (axis) => {
  return (options) => {
    const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
    return (context) => {
      var _a;
      const { scales: [scale3] } = context;
      const ticks2 = ((_a = scale3.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale3)) || scale3.getOptions().domain;
      const labelFormatter = typeof useDefinedLabelFormatter === "string" ? format(useDefinedLabelFormatter) : useDefinedLabelFormatter;
      const labelFilter = (datum, index2, array2) => userDefinedLabelFilter(ticks2[index2], index2, ticks2);
      const normalizedOptions = Object.assign(Object.assign({}, options), {
        labelFormatter,
        labelFilter,
        scale: scale3
      });
      return axis(normalizedOptions)(context);
    };
  };
};
var LinearAxis = axisFactor(LinearAxisComponent);
var ArcAxis = axisFactor(ArcAxisComponent);
LinearAxis.props = {
  defaultPosition: "center",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};
ArcAxis.props = {
  defaultPosition: "outer",
  defaultOrientation: "vertical",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/axisX.js
var AxisX = (options) => {
  return (...args) => {
    const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
    rotateAxis(axisX, options);
    return axisX;
  };
};
AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/axisY.js
var AxisY = (options) => {
  return (...args) => {
    const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
    rotateAxis(axisY, options);
    return axisY;
  };
};
AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/axisRadar.js
var __rest54 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferTitleTransform(orientation) {
  const internalOrientation = orientation % (Math.PI * 2);
  if (internalOrientation === Math.PI / 2) {
    return { titleTransform: "translate(0, 50%)" };
  }
  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
    return { titleTransform: "translate(50%, 0)" };
  }
  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
    return { titleTransform: "translate(-50%, 0)" };
  }
  return {};
}
function inferAxisStyle(options, theme, coordinate, scales) {
  const { radar } = options;
  const [scale3] = scales;
  const name2 = scale3.getOptions().name;
  const [startAngle, endAngle] = angleOf(coordinate);
  const { axisRadar: radarTheme = {} } = theme;
  return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_, i) => {
    const angle2 = (endAngle - startAngle) / radar.count;
    return angle2 * i;
  }) });
}
var AxisRadar = (options) => {
  const { important = {} } = options, restOptions = __rest54(options, ["important"]);
  return (context) => {
    const { theme, coordinate, scales } = context;
    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
  };
};
AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

// node_modules/@antv/g2/esm/component/legendCategory.js
var __rest55 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferShape(scales, markState) {
  const shapeScale = scaleOf(scales, "shape");
  const colorScale = scaleOf(scales, "color");
  const shapeScale1 = shapeScale ? shapeScale.clone() : null;
  const shapes = [];
  for (const [mark2, state] of markState) {
    const namespace = mark2.type;
    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
    const shape23 = domain.map((d2, i) => {
      var _a;
      if (shapeScale1)
        return shapeScale1.map(d2 || "point");
      return ((_a = mark2 === null || mark2 === void 0 ? void 0 : mark2.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || "point";
    });
    if (typeof namespace === "string")
      shapes.push([namespace, shape23]);
  }
  if (shapes.length === 0)
    return ["point", ["point"]];
  if (shapes.length === 1)
    return shapes[0];
  if (!shapeScale)
    return shapes[0];
  const { range: range3 } = shapeScale.getOptions();
  return shapes.map(([namespace, shape23]) => {
    let sum4 = 0;
    for (let i = 0; i < shapes.length; i++) {
      const targetShape = range3[i % range3.length];
      if (shape23[i] === targetShape)
        sum4++;
    }
    return [sum4 / shape23.length, [namespace, shape23]];
  }).sort((a3, b) => b[0] - a3[0])[0][1];
}
function inferItemMarker(options, context) {
  const { scales, library: library3, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerSize: size3 } = options;
  const create2 = (name2, d2) => {
    var _a, _b, _c;
    const marker = ((_c = (_b = (_a = library3[`mark.${mark2}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
    const radius = typeof size3 === "function" ? size3(d2) : size3;
    return () => useMarker(marker, { color: d2.color })(0, 0, radius);
  };
  const shapeOf = (i) => `${shapes[i]}`;
  const shapeScale = scaleOf(scales, "shape");
  if (shapeScale && !itemMarker)
    return (d2, i) => create2(shapeOf(i), d2);
  if (typeof itemMarker === "function") {
    return (d2, i) => {
      const node = itemMarker(d2.id, i);
      if (typeof node === "string")
        return create2(node, d2);
      return node;
    };
  }
  return (d2, i) => create2(itemMarker || shapeOf(i), d2);
}
function inferItemMarkerOpacity(scales) {
  const scale3 = scaleOf(scales, "opacity");
  if (scale3) {
    const { range: range3 } = scale3.getOptions();
    return (d2, i) => range3[i];
  }
  return void 0;
}
function inferItemMarkerSize(scales, defaults4) {
  const scale3 = scaleOf(scales, "size");
  if (scale3 instanceof Identity)
    return scale3.map(NaN) * 2;
  return defaults4;
}
function inferCategoryStyle(options, context) {
  const { labelFormatter = (d2) => `${d2}` } = options;
  const { scales, theme } = context;
  const defaultSize = theme.legendCategory.itemMarkerSize;
  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
  const baseStyle = {
    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
    itemMarkerSize,
    itemMarkerOpacity: inferItemMarkerOpacity(scales)
  };
  const finalLabelFormatter = typeof labelFormatter === "string" ? format(labelFormatter) : labelFormatter;
  const colorScale = scaleOf(scales, "color");
  const domain = domainOf2(scales);
  const colorOf = colorScale ? (d2) => colorScale.map(d2) : () => context.theme.color;
  return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d2) => ({
    id: d2,
    label: finalLabelFormatter(d2),
    color: colorOf(d2)
  })) });
}
function inferLegendShape(value2, options, component) {
  const { position } = options;
  if (position === "center") {
    const { bbox } = value2;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  const { width, height } = inferComponentShape(value2, options, component);
  return { width, height };
}
var LegendCategory = (options) => {
  const { labelFormatter, layout, order, orientation, position, size: size3, title, cols, itemMarker } = options, style = __rest55(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
  const { gridRow } = style;
  return (context) => {
    const { value: value2, theme } = context;
    const { bbox } = value2;
    const { width, height } = inferLegendShape(value2, options, LegendCategory);
    const finalLayout = inferComponentLayout(position, layout);
    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
      width,
      height,
      layout: cols !== void 0 ? "grid" : "flex"
    }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
    const { legendCategory: legendTheme = {} } = theme;
    const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));
    const layoutWrapper = new LegendCategoryLayout({
      style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
        // @ts-ignore
        subOptions: categoryStyle
      })
    });
    layoutWrapper.appendChild(new Category({
      className: "legend-category",
      style: categoryStyle
    }));
    return layoutWrapper;
  };
};
LegendCategory.props = {
  defaultPosition: "top",
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/legendContinuous.js
var __rest56 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function updateShapeDimensions(shape23, finalSize, orientation) {
  shape23.size = finalSize;
  if (isHorizontal(orientation)) {
    shape23.height = finalSize;
  } else {
    shape23.width = finalSize;
  }
  return shape23;
}
function inferContinuousShape(value2, options, component) {
  const { size: size3 } = options;
  const shape23 = inferComponentShape(value2, options, component);
  return updateShapeDimensions(shape23, size3, shape23.orientation);
}
function getFormatter(max6) {
  return (value2) => ({
    value: value2 / max6,
    label: String(value2)
  });
}
function getQuantizeOrQuantileConfig(shape23, colorScale, min6, max6, range3) {
  const thresholds = colorScale.thresholds;
  const formatter = getFormatter(max6);
  return Object.assign(Object.assign({}, shape23), { color: range3, data: [min6, ...thresholds, max6].map(formatter) });
}
function getThresholdConfig(shape23, colorScale, range3) {
  const thresholds = colorScale.thresholds;
  const data = [-Infinity, ...thresholds, Infinity].map((value2, index2) => ({
    value: index2,
    label: value2
  }));
  return Object.assign(Object.assign({}, shape23), { data, color: range3, labelFilter: (datum, index2) => {
    return index2 > 0 && index2 < data.length - 1;
  } });
}
function rangeOf2(scale3) {
  const { domain } = scale3.getOptions();
  const [min6, max6] = [domain[0], lastOf(domain)];
  return [min6, max6];
}
function createColorScale(scale3, defaultColor) {
  const options = scale3.getOptions();
  const newScale = scale3.clone();
  newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
  return newScale;
}
function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
  const { length } = shape23;
  const definedScale = sizeScale || opacityScale;
  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
  const scale3 = colorScale || createColorScale(definedScale, defaultColor);
  const [min6, max6] = rangeOf2(scale3);
  const [domainMin, domainMax] = rangeOf2([colorScale, sizeScale, opacityScale].filter((d2) => d2 !== void 0).find((d2) => !(d2 instanceof Constant)));
  return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale3.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length)).fill(0).map((d2, i) => {
    const value2 = (max6 - min6) / (length - 1) * i + min6;
    const color2 = scale3.map(value2) || defaultColor;
    const opacity = opacityScale ? opacityScale.map(value2) : 1;
    return color2.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);
  }) });
}
function inferContinuousConfig(scales, scale3, value2, options, component, theme) {
  const colorScale = scaleOf(scales, "color");
  const shape23 = inferContinuousShape(value2, options, component);
  if (colorScale instanceof Threshold) {
    const { range: range3 } = colorScale.getOptions();
    const [min6, max6] = rangeOf2(colorScale);
    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
      return getQuantizeOrQuantileConfig(shape23, colorScale, min6, max6, range3);
    }
    return getThresholdConfig(shape23, colorScale, range3);
  }
  const sizeScale = scaleOf(scales, "size");
  const opacityScale = scaleOf(scales, "opacity");
  return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale3, theme);
}
var LegendContinuous = (options) => {
  const { labelFormatter, layout, order, orientation, position, size: size3, title, style, crossPadding, padding } = options, rest = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
  return ({ scales, value: value2, theme, scale: scale3 }) => {
    const { bbox } = value2;
    const { x: x2, y: y2, width, height } = bbox;
    const finalLayout = inferComponentLayout(position, layout);
    const { legendContinuous: legendTheme = {} } = theme;
    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter === "string" ? (d2) => format(labelFormatter)(d2.label) : labelFormatter }, inferContinuousConfig(scales, scale3, value2, options, LegendContinuous, theme)), style), rest));
    const layoutWrapper = new G2Layout({
      style: Object.assign(Object.assign({
        x: x2,
        y: y2,
        width,
        height
      }, finalLayout), {
        // @ts-ignore
        subOptions: finalStyle
      })
    });
    layoutWrapper.appendChild(new Continuous({
      className: "legend-continuous",
      style: finalStyle
    }));
    return layoutWrapper;
  };
};
LegendContinuous.props = {
  defaultPosition: "top",
  defaultOrientation: "vertical",
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  defaultCrossPadding: [12, 12]
  // [horizontal, vertical]
};

// node_modules/@antv/g2/esm/component/legendContinuousBlock.js
var LegendContinuousBlock = (options) => {
  return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
};
LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousSize.js
var LegendContinuousSize = (options) => {
  return (context) => {
    const { scales } = context;
    const sizeScale = scaleOf(scales, "size");
    return LegendContinuous(Object.assign({}, {
      type: "size",
      data: sizeScale.getTicks().map((value2, index2) => ({
        value: value2,
        label: String(value2)
      }))
    }, options))(context);
  };
};
LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
var LegendContinuousBlockSize = (options) => {
  return LegendContinuousSize(Object.assign({}, { block: true }, options));
};
LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/title.js
var __rest57 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferStyleByAlign(x2, y2, width, align) {
  switch (align) {
    case "center":
      return {
        x: x2 + width / 2,
        y: y2,
        textAlign: "middle"
      };
    case "right":
      return {
        x: x2 + width,
        y: y2,
        textAlign: "right"
      };
    default:
      return {
        x: x2,
        y: y2,
        textAlign: "left"
      };
  }
}
var Title = createComponent({
  render(attributes, container) {
    const { width, title, subtitle, spacing = 2, align = "left", x: x2, y: y2 } = attributes, style = __rest57(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
    container.style.transform = `translate(${x2}, ${y2})`;
    const titleStyle = subObject(style, "title");
    const subtitleStyle = subObject(style, "subtitle");
    const mainTitle = maybeAppend(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
    const bounds = mainTitle.getLocalBounds();
    maybeAppend(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
      if (!subtitle)
        return selection.node().remove();
      selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
    });
  }
});
var TitleComponent = (options) => {
  return ({ value: value2, theme }) => {
    const { x: x2, y: y2, width, height } = value2.bbox;
    return new Title({
      style: deep_mix_default({}, theme.title, Object.assign({
        x: x2,
        y: y2,
        width,
        height
      }, options))
    });
  };
};
TitleComponent.props = {
  defaultPosition: "top",
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/utils/scale.js
function constrain(x2, lo, hi) {
  return Math.min(hi, Math.max(lo, x2));
}
function isOrdinalScale(scale3) {
  return !!scale3.getBandWidth;
}
function invert(scale3, x2, start) {
  if (!isOrdinalScale(scale3))
    return scale3.invert(x2);
  const { adjustedRange } = scale3;
  const { domain } = scale3.getOptions();
  const offset = start ? -1 : 0;
  const step = scale3.getStep();
  const range3 = start ? adjustedRange : adjustedRange.map((d2) => d2 + step);
  const i0 = bisectLeft(range3, x2);
  const i1 = constrain(i0 + offset, 0, domain.length - 1);
  return domain[i1];
}
function domainOf3(scale3, values3, ratioX) {
  if (!values3)
    return scale3.getOptions().domain;
  if (!isOrdinalScale(scale3)) {
    const sortedDomain = sort(values3);
    if (!ratioX)
      return sortedDomain;
    const [d2] = sortedDomain;
    const { range: range3 } = scale3.getOptions();
    const [r0, r1] = range3;
    const v = r0 > r1 ? -1 : 1;
    const d1 = scale3.invert(scale3.map(d2) + v * ratioX);
    return [d2, d1];
  }
  const { domain } = scale3.getOptions();
  const v1 = values3[0];
  const start = domain.indexOf(v1);
  if (ratioX) {
    const end2 = start + Math.round(domain.length * ratioX);
    return domain.slice(start, end2);
  }
  const v2 = values3[values3.length - 1];
  const end = domain.indexOf(v2);
  return domain.slice(start, end + 1);
}
function selectionOf(x2, y2, x12, y12, scale3, coordinate) {
  const { x: scaleX, y: scaleY } = scale3;
  const abstractDomain = (point6, start) => {
    const [x3, y3] = coordinate.invert(point6);
    return [invert(scaleX, x3, start), invert(scaleY, y3, start)];
  };
  const p0 = abstractDomain([x2, y2], true);
  const p1 = abstractDomain([x12, y12], false);
  const domainX = domainOf3(scaleX, [p0[0], p1[0]]);
  const domainY = domainOf3(scaleY, [p0[1], p1[1]]);
  return [domainX, domainY];
}
function abstractOf(domain, scale3) {
  const [d0, d1] = domain;
  const maybeStep = (scale4) => scale4.getStep ? scale4.getStep() : 0;
  return [scale3.map(d0), scale3.map(d1) + maybeStep(scale3)];
}
function pixelsOf(selection, scale3, coordinate) {
  const { x: scaleX, y: scaleY } = scale3;
  const [X, Y] = selection;
  const AX = abstractOf(X, scaleX);
  const AY = abstractOf(Y, scaleY);
  const p0 = [AX[0], AY[0]];
  const p1 = [AX[1], AY[1]];
  const [x2, y2] = coordinate.map(p0);
  const [x12, y12] = coordinate.map(p1);
  return [x2, y2, x12, y12];
}

// node_modules/@antv/g2/esm/component/slider.js
var __rest58 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferPosition2(bbox, position, trackSize) {
  const { x: x2, y: y2, width, height } = bbox;
  if (position === "left")
    return [x2 + width - trackSize, y2];
  if (position === "right")
    return [x2, y2];
  if (position === "bottom")
    return [x2, y2];
  if (position === "top")
    return [x2, y2 + height - trackSize];
}
var Slider2 = (options) => {
  const { orientation, labelFormatter, size: size3, style = {}, position } = options, rest = __rest58(options, ["orientation", "labelFormatter", "size", "style", "position"]);
  return (context) => {
    var _a;
    const { scales: [scale3], value: value2, theme, coordinate } = context;
    const { bbox } = value2;
    const { width, height } = bbox;
    const { slider: sliderTheme = {} } = theme;
    const defaultFormatter = ((_a = scale3.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale3)) || ((v) => v + "");
    const formatter = typeof labelFormatter === "string" ? format(labelFormatter) : labelFormatter;
    const isHorizontal2 = orientation === "horizontal";
    const reverse2 = isTranspose(coordinate) && isHorizontal2;
    const { trackSize = sliderTheme.trackSize } = style;
    const [x05, y05] = inferPosition2(bbox, position, trackSize);
    return new Slider({
      className: "slider",
      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal2 ? width : height, orientation, formatter: (v) => {
        const f = formatter || defaultFormatter;
        const v1 = reverse2 ? 1 - v : v;
        const tick2 = invert(scale3, v1, true);
        return f(tick2);
      }, sparklineData: inferSparklineData(options, context) }, style), rest))
    });
  };
};
function markValue(markState, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === "line" || mark2.type === "area").filter(([mark2]) => mark2.slider).map(([mark2]) => {
    const { encode, slider } = mark2;
    if (slider === null || slider === void 0 ? void 0 : slider.x) {
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    }
  });
  if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
    return value2 === null || value2 === void 0 ? void 0 : value2.y;
  const result = value2.series.reduce((acc, curr, index2) => {
    acc[curr] = acc[curr] || [];
    acc[curr].push(value2.y[index2]);
    return acc;
  }, {});
  return Object.values(result);
}
function inferSparklineData(options, context) {
  const { markState } = context;
  if (isArray(options.sparklineData))
    return options.sparklineData;
  return markValue(markState, ["y", "series"]);
}
Slider2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/sliderX.js
var SliderX = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/sliderY.js
var SliderY = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/scrollbar.js
var __rest59 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Scrollbar2 = (options) => {
  const { orientation, labelFormatter, style } = options, rest = __rest59(options, ["orientation", "labelFormatter", "style"]);
  return ({ scales: [scale3], value: value2, theme }) => {
    const { bbox } = value2;
    const { x: x2, y: y2, width, height } = bbox;
    const { scrollbar: scrollbarTheme = {} } = theme;
    const { ratio, range: range3 } = scale3.getOptions();
    const mainSize = orientation === "horizontal" ? width : height;
    const actualSize = mainSize / ratio;
    const [r0, r1] = range3;
    const value1 = r1 > r0 ? 0 : 1;
    return new Scrollbar({
      className: "g2-scrollbar",
      style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
        x: x2,
        y: y2,
        trackLength: mainSize,
        value: value1
      }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
    });
  };
};
Scrollbar2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/scrollbarX.js
var ScrollbarX = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/scrollbarY.js
var ScrollbarY = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/legends.js
var Legends = (options) => {
  return () => {
    return new Group();
  };
};
Legends.props = {};

// node_modules/@antv/g2/esm/animation/scaleInX.js
var ScaleInX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutX.js
var ScaleOutX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleInY.js
var ScaleInY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  CSS.registerProperty({
    name: "scaleInYRadius",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  return (from, _, defaults4) => {
    const [shape23] = from;
    const PolarScaleInY = (shape24) => {
      const { __data__, style } = shape24;
      const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y2, y1: y12 } = __data__;
      const arcObject = getArcObject(coordinate, points, [y2, y12]);
      const { innerRadius, outerRadius } = arcObject;
      const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
      const pathForConversion = new Path({});
      const createArcPath = (arcParams) => {
        pathForConversion.attr({
          d: path2(arcParams)
        });
        const convertedPathDefinition = convertToPath(pathForConversion);
        return convertedPathDefinition;
      };
      const keyframes = [
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          scaleInYRadius: outerRadius,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      animation.onframe = function() {
        shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius: Number(shape24.style.scaleInYRadius) }));
      };
      animation.onfinish = function() {
        shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius }));
      };
      return animation;
    };
    const RectangularScaleInY = (shape24) => {
      const { style } = shape24;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    if (isPolar(coordinate)) {
      return PolarScaleInY(shape23);
    } else {
      return RectangularScaleInY(shape23);
    }
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutY.js
var ScaleOutY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/fadeIn.js
var FadeIn = (options) => {
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeIn.props = {};

// node_modules/@antv/g2/esm/animation/fadeOut.js
var FadeOut = (options) => {
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      {
        fillOpacity,
        strokeOpacity,
        opacity
      },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeOut.props = {};

// node_modules/@antv/g2/esm/animation/utils.js
var DEFAULT_ATTRIBUTE_VALUE = {
  opacity: 1,
  strokeOpacity: 1,
  fillOpacity: 1,
  lineWidth: 0,
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  r: 0,
  rx: 0,
  ry: 0,
  width: 0,
  height: 0
};
var GEOMETRY_ATTRIBUTES = {
  [Shape.CIRCLE]: ["cx", "cy", "r"],
  [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
  [Shape.RECT]: ["x", "y", "width", "height"],
  [Shape.IMAGE]: ["x", "y", "width", "height"],
  [Shape.LINE]: ["x1", "y1", "x2", "y2"],
  [Shape.POLYLINE]: ["points"],
  [Shape.POLYGON]: ["points"]
};
function attributeOf(shape23, keys, useDefaultValue = false) {
  const attribute = {};
  for (const key of keys) {
    const value2 = shape23.style[key];
    if (value2) {
      attribute[key] = value2;
    } else if (useDefaultValue) {
      attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
    }
  }
  return attribute;
}
var attributeKeys = [
  "fill",
  "stroke",
  "fillOpacity",
  "strokeOpacity",
  "opacity",
  "lineWidth"
];

// node_modules/@antv/g2/esm/animation/morphing.js
function localBBoxOf(shape23) {
  const { min: min6, max: max6 } = shape23.getLocalBounds();
  const [x05, y05] = min6;
  const [x12, y12] = max6;
  const height = y12 - y05;
  const width = x12 - x05;
  return [x05, y05, width, height];
}
function d(bbox) {
  const [x2, y2, width, height] = bbox;
  return `
    M ${x2} ${y2}
    L ${x2 + width} ${y2}
    L ${x2 + width} ${y2 + height}
    L ${x2} ${y2 + height}
    Z
  `;
}
function pack2(shape23, count4) {
  const [x05, y05, width, height] = localBBoxOf(shape23);
  const aspect = height / width;
  const col = Math.ceil(Math.sqrt(count4 / aspect));
  const row = Math.ceil(count4 / col);
  const B2 = [];
  const h = height / row;
  let j = 0;
  let n = count4;
  while (n > 0) {
    const c4 = Math.min(n, col);
    const w = width / c4;
    for (let i = 0; i < c4; i++) {
      const x2 = x05 + i * w;
      const y2 = y05 + j * h;
      B2.push(d([x2, y2, w, h]));
    }
    n -= c4;
    j += 1;
  }
  return B2;
}
function normalizeSplit(split = "pack") {
  if (typeof split == "function")
    return split;
  return pack2;
}
function shapeToShape(from, to, timeEffect) {
  let { transform: fromTransform } = from.style;
  const { transform: toTransform } = to.style;
  replaceChild(to, from);
  let keys = attributeKeys;
  if (from.nodeName === Shape.GROUP) {
    const [x05, y05, w0, h0] = localBBoxOf(from);
    const [x12, y12, w1, h1] = localBBoxOf(to);
    const dx = x05 - x12;
    const dy = y05 - y12;
    const sx = w0 / w1;
    const sy = h0 / h1;
    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
  } else {
    keys = keys.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
  }
  const keyframes = [
    Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys, true)),
    Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys, true))
  ];
  const animation = to.animate(keyframes, timeEffect);
  return animation;
}
function replaceChild(newChild, oldChild) {
  newChild["__data__"] = oldChild["__data__"];
  newChild.className = oldChild.className;
  newChild.markType = oldChild.markType;
  oldChild.parentNode.replaceChild(newChild, oldChild);
}
function maybePath(node, d2) {
  const { nodeName } = node;
  if (nodeName === "path")
    return node;
  const path2 = new Path({
    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d2 })
  });
  replaceChild(path2, node);
  return path2;
}
function hasUniqueString(search, pattern) {
  const first3 = search.indexOf(pattern);
  const last5 = search.lastIndexOf(pattern);
  return first3 === last5;
}
function hasSubPath(path2) {
  return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
}
function shape2path(shape23) {
  const path2 = convertToPath(shape23);
  if (!path2)
    return;
  if (hasSubPath(path2))
    return;
  return path2;
}
function hasMarker(shape23) {
  const { nodeName } = shape23;
  if (nodeName === "path") {
    const attributes = get_default(shape23, "attributes");
    return attributes.markerEnd || attributes.markerStart;
  }
  return false;
}
function oneToOne(shape23, from, to, timeEffect) {
  const { nodeName: fromName } = from;
  const { nodeName: toName } = to;
  const fromPath = shape2path(from);
  const toPath = shape2path(to);
  const isSameNodes = fromName === toName && fromName !== "path";
  const hasNonPathNode = fromPath === void 0 || toPath === void 0;
  const isPathWithMarker = hasMarker(from) || hasMarker(to);
  if (isSameNodes || hasNonPathNode || isPathWithMarker)
    return shapeToShape(from, to, timeEffect);
  const pathShape = maybePath(shape23, fromPath);
  const keyframes = [
    Object.assign({}, attributeOf(from, attributeKeys)),
    Object.assign({}, attributeOf(to, attributeKeys))
  ];
  if (fromPath !== toPath) {
    keyframes[0].d = fromPath;
    keyframes[1].d = toPath;
    const animation = pathShape.animate(keyframes, timeEffect);
    animation.onfinish = () => {
      const d2 = pathShape.style.d;
      copyAttributes(pathShape, to);
      pathShape.style.d = d2;
      pathShape.style.transform = "none";
    };
    pathShape.style.transform = "none";
    return animation;
  }
  return null;
}
function oneToMultiple(from, to, timeEffect, split) {
  from.style.visibility = "hidden";
  const D2 = split(from, to.length);
  return to.map((shape23, i) => {
    const path2 = new Path({
      style: Object.assign({ d: D2[i] }, attributeOf(from, attributeKeys))
    });
    return oneToOne(shape23, path2, shape23, timeEffect);
  });
}
function multipleToOne(from, to, timeEffect, split) {
  const D2 = split(to, from.length);
  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
  const keyframes = [
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
    {
      fillOpacity,
      strokeOpacity,
      opacity
    }
  ];
  const animation = to.animate(keyframes, timeEffect);
  const animations = from.map((shape23, i) => {
    const path2 = new Path({
      style: {
        d: D2[i],
        fill: to.style.fill
      }
    });
    return oneToOne(shape23, shape23, path2, timeEffect);
  });
  return [...animations, animation];
}
var Morphing = (options) => {
  return (from, to, defaults4) => {
    const split = normalizeSplit(options.split);
    const timeEffect = Object.assign(Object.assign({}, defaults4), options);
    const { length: fl } = from;
    const { length: tl } = to;
    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
      const [f] = from;
      const [t] = to;
      return oneToOne(f, f, t, timeEffect);
    }
    if (fl === 1 && tl > 1) {
      const [f] = from;
      return oneToMultiple(f, to, timeEffect, split);
    }
    if (fl > 1 && tl === 1) {
      const [t] = to;
      return multipleToOne(from, t, timeEffect, split);
    }
    return null;
  };
};
Morphing.props = {};

// node_modules/@antv/g2/esm/animation/waveIn.js
var WaveIn = (options, context) => {
  const ZERO = 1e-4;
  CSS.registerProperty({
    name: "waveInArcAngle",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  const { coordinate } = context;
  return (from, to, defaults4) => {
    const [shape23] = from;
    if (!isPolar(coordinate)) {
      return ScaleInX(options, context)(from, to, defaults4);
    }
    const { __data__, style } = shape23;
    const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
    const { points, y: y2, y1: y12 } = __data__;
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    const arcObject = getArcObject(coordinate, points, [y2, y12]);
    const { startAngle, endAngle } = arcObject;
    const keyframes = [
      // Use custom interpolable CSS property.
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        waveInArcAngle: endAngle,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    animation.onframe = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
    };
    animation.onfinish = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
    };
    return animation;
  };
};
WaveIn.props = {};

// node_modules/@antv/g2/esm/animation/zoomIn.js
var ZoomIn = (options) => {
  const ZERO = 1e-4;
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/zoomOut.js
var ZoomOut = (options) => {
  const ZERO = 1e-4;
  return (from, _, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/pathIn.js
var PathIn = (options) => {
  return (from, _, defaults4) => {
    var _a, _b;
    const [shape23] = from;
    const length = ((_b = (_a = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a)) || 0;
    const keyframes = [
      { lineDash: [0, length] },
      { lineDash: [length, 0] }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
PathIn.props = {};

// node_modules/@antv/g2/esm/animation/growInX.js
var GrowInX = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x2, y2], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path({
      style: {
        d: `M${x2},${y2}L${x2 + width},${y2}L${x2 + width},${y2 + height}L${x2},${y2 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInX(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInX.props = {};

// node_modules/@antv/g2/esm/animation/growInY.js
var GrowInY = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x2, y2], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path({
      style: {
        d: `M${x2},${y2}L${x2 + width},${y2}L${x2 + width},${y2 + height}L${x2},${y2 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInY(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInY.props = {};

// node_modules/@antv/g2/esm/runtime/constant.js
var MAIN_LAYER_CLASS_NAME = "main-layer";
var LABEL_LAYER_CLASS_NAME = "label-layer";
var ELEMENT_CLASS_NAME = "element";
var VIEW_CLASS_NAME = "view";
var PLOT_CLASS_NAME = "plot";
var COMPONENT_CLASS_NAME = "component";
var LABEL_CLASS_NAME = "label";
var AREA_CLASS_NAME = "area";
var MASK_CLASS_NAME = "mask";

// node_modules/@antv/g2/esm/utils/event.js
var ChartEvent = {
  BEFORE_RENDER: "beforerender",
  AFTER_RENDER: "afterrender",
  BEFORE_PAINT: "beforepaint",
  AFTER_PAINT: "afterpaint",
  BEFORE_CHANGE_DATA: "beforechangedata",
  AFTER_CHANGE_DATA: "afterchangedata",
  BEFORE_CLEAR: "beforeclear",
  AFTER_CLEAR: "afterclear",
  BEFORE_DESTROY: "beforedestroy",
  AFTER_DESTROY: "afterdestroy",
  BEFORE_CHANGE_SIZE: "beforechangesize",
  AFTER_CHANGE_SIZE: "afterchangesize",
  POINTER_TAP: "pointertap",
  POINTER_DOWN: "pointerdown",
  POINTER_UP: "pointerup",
  POINTER_OVER: "pointerover",
  POINTER_OUT: "pointerout",
  POINTER_MOVE: "pointermove",
  POINTER_ENTER: "pointerenter",
  POINTER_LEAVE: "pointerleave",
  POINTER_UPOUTSIDE: "pointerupoutside",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_END: "dragend",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "DROP",
  CLICK: "click",
  DBLCLICK: "dblclick"
};

// node_modules/@antv/g2/esm/component/constant.js
var LEGEND_INFER_STRATEGIES = [
  [
    "legendCategory",
    [
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      //   ['size', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      //   ['size', 'constant'],
      // ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      // ],
      [["color", "discrete"]]
      // [['color', 'constant']],
    ]
  ],
  [
    "legendContinuousSize",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["size", "continuous"]
      ],
      [
        ["size", "continuous"],
        ["opacity", "continuous"]
      ],
      [["size", "continuous"]]
    ]
  ],
  [
    "legendContinuousBlockSize",
    [
      [
        ["color", "distribution"],
        ["opacity", "distribution"],
        ["size", "distribution"]
      ],
      [
        ["color", "distribution"],
        ["size", "distribution"]
      ]
    ]
  ],
  [
    "legendContinuousBlock",
    [
      [
        ["color", "distribution"],
        ["opacity", "continuous"]
      ],
      [["color", "distribution"]]
    ]
  ],
  [
    "legendContinuous",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"]
      ],
      [["color", "continuous"]],
      [["opacity", "continuous"]]
    ]
  ]
];

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value2) {
  return is_type_default(value2, "Function");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default(value2, "Array");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default2 = each;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default2 = isPlainObject;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf2 = arrPrototype.indexOf;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str) {
  return is_type_default(str, "String");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value2) {
  return is_type_default(value2, "Number");
};
var is_number_default = isNumber2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default2(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var values_default = values;

// node_modules/@antv/coord/node_modules/@antv/util/esm/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f, resolver) {
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL = 5;
function _deepMix(dist2, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default2(value2)) {
        if (!is_plain_object_default2(dist2[key])) {
          dist2[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist2[key], value2, level + 1, maxLevel);
        } else {
          dist2[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist2[key] = [];
        dist2[key] = dist2[key].concat(value2);
      } else if (value2 !== void 0) {
        dist2[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default2 = deepMix;

// node_modules/@antv/coord/node_modules/@antv/util/esm/identity.js
var identity_default3 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// node_modules/@antv/coord/node_modules/@antv/util/esm/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/@antv/coord/esm/utils/compose.js
function compose2(fn) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return fn ? rest.reduce(function(total, current) {
    return function(x2) {
      return current(total(x2));
    };
  }, fn) : identity_default3;
}

// node_modules/@antv/coord/esm/utils/isMatrix.js
function isMatrix(transformer2) {
  return transformer2 instanceof Float32Array || transformer2 instanceof Array;
}

// node_modules/@antv/coord/esm/utils/extend.js
var __read = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function extend2(transform) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 2) {
      var from = [vector[i], vector[i + 1]];
      var to = transform(from);
      v.push.apply(v, __spreadArray([], __read(to), false));
    }
    return v;
  };
}
function extend3D(transform) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 3) {
      var from = [vector[i], vector[i + 1], vector[i + 2]];
      var to = transform(from);
      v.push.apply(v, __spreadArray([], __read(to), false));
    }
    return v;
  };
}

// node_modules/@antv/coord/esm/utils/adjustAngle.js
function adjustAngle(theta, min6, max6) {
  while (theta < min6)
    theta += Math.PI * 2;
  while (theta > max6)
    theta -= Math.PI * 2;
  return theta;
}

// node_modules/@antv/coord/esm/transforms/translate.js
var __read2 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var translate = function(params, x2, y2, width, height) {
  var _a = __read2(params, 2), tx = _a[0], ty = _a[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromTranslation(matrix2, [tx, ty]);
};

// node_modules/@antv/coord/esm/transforms/cartesian.js
var __read3 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var cartesian = function(params, x2, y2, width, height) {
  var sx = new Linear({
    range: [x2, x2 + width]
  });
  var sy = new Linear({
    range: [y2, y2 + height]
  });
  return {
    transform: function(vector) {
      var _a = __read3(vector, 2), v1 = _a[0], v2 = _a[1];
      return [sx.map(v1), sy.map(v2)];
    },
    untransform: function(vector) {
      var _a = __read3(vector, 2), v1 = _a[0], v2 = _a[1];
      return [sx.invert(v1), sy.invert(v2)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/custom.js
var __read4 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var custom10 = function(params, x2, y2, width, height) {
  var _a = __read4(params, 1), callback = _a[0];
  return callback(x2, y2, width, height);
};

// node_modules/@antv/coord/esm/transforms/matrix.js
var __read5 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var matrix = function(params, x2, y2, width, height) {
  var _a = __read5(params, 1), matrix2 = _a[0];
  return matrix2;
};

// node_modules/@antv/coord/esm/transforms/polar.js
var __read6 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var polar = function(params, x2, y2, width, height) {
  var _a = __read6(params, 4), startAngle = _a[0], endAngle = _a[1], innerRadius = _a[2], outerRadius = _a[3];
  var radius = new Linear({
    range: [innerRadius, outerRadius]
  });
  var angle2 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a2 = __read6(vector, 2), v1 = _a2[0], v2 = _a2[1];
      var theta = angle2.map(v1);
      var r = radius.map(v2);
      var x3 = r * Math.cos(theta) * sx;
      var y3 = r * Math.sin(theta) * sy;
      var dx = x3 * 0.5 + 0.5;
      var dy = y3 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a2 = __read6(vector, 2), dx = _a2[0], dy = _a2[1];
      var x3 = (dx - 0.5) * 2 / sx;
      var y3 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
      var t = Math.atan2(y3, x3);
      var theta = adjustAngle(t, startAngle, endAngle);
      var v1 = angle2.invert(theta);
      var v2 = radius.invert(r);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/transpose.js
var __read7 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var transpose2 = function(params, x2, y2, width, height) {
  return {
    transform: function(_a) {
      var _b = __read7(_a, 2), x3 = _b[0], y3 = _b[1];
      return [y3, x3];
    },
    untransform: function(_a) {
      var _b = __read7(_a, 2), x3 = _b[0], y3 = _b[1];
      return [y3, x3];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale.js
var __read8 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var scale = function(params, x2, y2, width, height) {
  var _a = __read8(params, 2), sx = _a[0], sy = _a[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromScaling(matrix2, [sx, sy]);
};

// node_modules/@antv/coord/esm/transforms/reflect.js
var __read9 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var reflect = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray2([[-1, -1]], __read9(args), false));
};
var reflectX = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray2([[-1, 1]], __read9(args), false));
};
var reflectY = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray2([[1, -1]], __read9(args), false));
};

// node_modules/@antv/coord/esm/transforms/rotate.js
var __read10 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var rotate = function(params, x2, y2, width, height) {
  var _a = __read10(params, 1), theta = _a[0];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromRotation(matrix2, theta);
};

// node_modules/@antv/coord/esm/transforms/helix.js
var __read11 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var helix = function(params, x2, y2, width, height) {
  var _a = __read11(params, 4), startAngle = _a[0], endAngle = _a[1], innerRadius = _a[2], outerRadius = _a[3];
  var count4 = (endAngle - 0) / (2 * Math.PI) + 1;
  var d2 = (outerRadius - innerRadius) / count4;
  var b = d2 / (Math.PI * 2);
  var step = new Linear({
    range: [innerRadius, innerRadius + d2 * 0.99]
    // 
  });
  var angle2 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a2 = __read11(vector, 2), v1 = _a2[0], v2 = _a2[1];
      var theta = angle2.map(v1);
      var a3 = step.map(v2);
      var x3 = Math.cos(theta) * (b * theta + a3) * sx;
      var y3 = Math.sin(theta) * (b * theta + a3) * sy;
      var dx = x3 * 0.5 + 0.5;
      var dy = y3 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a2 = __read11(vector, 2), dx = _a2[0], dy = _a2[1];
      var x3 = (dx - 0.5) * 2 / sx;
      var y3 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
      var t = Math.atan2(y3, x3) + Math.floor(r / d2) * Math.PI * 2;
      var theta = adjustAngle(t, startAngle, endAngle);
      var a3 = r - b * theta;
      var v1 = angle2.invert(theta);
      var v2 = step.invert(a3);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/parallel.js
var __read12 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var parallel2 = function(params, x2, y2, width, height) {
  var _a = __read12(params, 4), x05 = _a[0], x12 = _a[1], y05 = _a[2], y12 = _a[3];
  var sy = new Linear({
    range: [y05, y12]
  });
  return {
    transform: function(vector) {
      var v = [];
      var len = vector.length;
      var sx = new Point({
        domain: new Array(len).fill(0).map(function(_, i2) {
          return i2;
        }),
        range: [x05, x12]
      });
      for (var i = 0; i < len; i++) {
        var e = vector[i];
        var x_1 = sx.map(i);
        var y_1 = sy.map(e);
        v.push(x_1, y_1);
      }
      return v;
    },
    untransform: function(vector) {
      var v = [];
      for (var i = 0; i < vector.length; i += 2) {
        var y_2 = vector[i + 1];
        v.push(sy.invert(y_2));
      }
      return v;
    }
  };
};

// node_modules/@antv/coord/esm/transforms/shear.js
var __read13 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function cot(theta) {
  return 1 / Math.tan(theta);
}
var shearX = function(params, x2, y2, width, height) {
  var _a = __read13(params, 1), theta = _a[0];
  var sx = cot(theta);
  return {
    transform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], y3 = _a2[1];
      var xx = x3 + y3 * sx;
      return [xx, y3];
    },
    untransform: function(vector) {
      var _a2 = __read13(vector, 2), xx = _a2[0], y3 = _a2[1];
      var x3 = xx - y3 * sx;
      return [x3, y3];
    }
  };
};
var shearY = function(params, x2, y2, width, height) {
  var _a = __read13(params, 1), theta = _a[0];
  var sy = cot(theta);
  return {
    transform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], y3 = _a2[1];
      var yy = y3 + x3 * sy;
      return [x3, yy];
    },
    untransform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], yy = _a2[1];
      var y3 = yy - x3 * sy;
      return [x3, y3];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/fisheye.js
var __read14 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function fisheyeTransform(x2, focus, distortion, min6, max6) {
  var left2 = x2 < focus;
  var m2 = (left2 ? focus - min6 : max6 - focus) || max6 - min6;
  var f = left2 ? -1 : 1;
  return f * m2 * (distortion + 1) / (distortion + m2 / ((x2 - focus) * f)) + focus;
}
function fisheyeUntransform(tx, focus, distortion, min6, max6) {
  var left2 = tx < focus;
  var m2 = (left2 ? focus - min6 : max6 - focus) || max6 - min6;
  var f = left2 ? -1 : 1;
  return m2 / (m2 * (distortion + 1) / (tx - focus) - distortion * f) + focus;
}
function normalize2(focus, length, isVisual) {
  if (!isVisual)
    return focus;
  var s2 = new Linear({
    range: [0, 1],
    domain: [0, length]
  });
  return s2.map(focus);
}
var fisheyeX = function(params, x2, y2, width, height) {
  var _a = __read14(params, 3), focus = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize2(focus, width, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
      return [fx, vy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), fx = _a2[0], vy = _a2[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeY = function(params, x2, y2, width, height) {
  var _a = __read14(params, 3), focus = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusY = normalize2(focus, height, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
      return [vx, fy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], fy = _a2[1];
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheye = function(params, x2, y2, width, height) {
  var _a = __read14(params, 5), focusX = _a[0], focusY = _a[1], distortionX = _a[2], distortionY = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize2(focusX, width, isVisual);
  var normalizedFocusY = normalize2(focusY, height, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
      var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
      return [fx, fy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), fx = _a2[0], fy = _a2[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeCircular = function(params, x2, y2, width, height) {
  var _a = __read14(params, 5), focusX = _a[0], focusY = _a[1], radius = _a[2], distortion = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
  var scaleX = new Linear({
    range: [0, width]
  });
  var scaleY = new Linear({
    range: [0, height]
  });
  var nx = isVisual ? focusX : scaleX.map(focusX);
  var ny = isVisual ? focusY : scaleY.map(focusY);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), x3 = _a2[0], y3 = _a2[1];
      var dx = scaleX.map(x3) - nx;
      var dy = scaleY.map(y3) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [x3, y3];
      var r = fisheyeTransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + r * Math.cos(theta);
      var fy = ny + r * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), tx = _a2[0], ty = _a2[1];
      var dx = scaleX.map(tx) - nx;
      var dy = scaleY.map(ty) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [tx, ty];
      var x3 = fisheyeUntransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + x3 * Math.cos(theta);
      var fy = ny + x3 * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/cartesian3D.js
var __read15 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var cartesian3D = function(params, x2, y2, z, width, height, depth) {
  var sx = new Linear({
    range: [x2, x2 + width]
  });
  var sy = new Linear({
    range: [y2, y2 + height]
  });
  var sz = new Linear({
    range: [z, z + depth]
  });
  return {
    transform: function(vector) {
      var _a = __read15(vector, 3), v1 = _a[0], v2 = _a[1], v3 = _a[2];
      return [sx.map(v1), sy.map(v2), sz.map(v3)];
    },
    untransform: function(vector) {
      var _a = __read15(vector, 3), v1 = _a[0], v2 = _a[1], v3 = _a[2];
      return [sx.invert(v1), sy.invert(v2), sz.invert(v3)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/translate3D.js
var __read16 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var translate3D = function(params, x2, y2, z, width, height, depth) {
  var _a = __read16(params, 3), tx = _a[0], ty = _a[1], tz = _a[2];
  return mat4_exports.fromTranslation(mat4_exports.create(), [tx, ty, tz]);
};

// node_modules/@antv/coord/esm/transforms/transpose3D.js
var __read17 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var transpose3D = function(params, x2, y2, z, width, height, depth) {
  return {
    transform: function(_a) {
      var _b = __read17(_a, 3), x3 = _b[0], y3 = _b[1], z2 = _b[2];
      return [y3, x3, z2];
    },
    untransform: function(_a) {
      var _b = __read17(_a, 3), x3 = _b[0], y3 = _b[1], z2 = _b[2];
      return [y3, x3, z2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale3D.js
var __read18 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var scale3D = function(params, x2, y2, z, width, height, depth) {
  var _a = __read18(params, 3), sx = _a[0], sy = _a[1], sz = _a[2];
  return mat4_exports.fromScaling(mat4_exports.create(), [sx, sy, sz]);
};

// node_modules/@antv/coord/esm/coordinate.js
var __read19 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = function(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(options) {
      this.options = {
        x: 0,
        y: 0,
        width: 300,
        height: 150,
        transformations: []
      };
      this.transformers = {
        cartesian,
        translate,
        custom: custom10,
        matrix,
        polar,
        transpose: transpose2,
        scale,
        "shear.x": shearX,
        "shear.y": shearY,
        reflect,
        "reflect.x": reflectX,
        "reflect.y": reflectY,
        rotate,
        helix,
        parallel: parallel2,
        fisheye,
        "fisheye.x": fisheyeX,
        "fisheye.y": fisheyeY,
        "fisheye.circular": fisheyeCircular
      };
      this.update(options);
    }
    Coordinate2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate2.prototype.clone = function() {
      return new Coordinate2(this.options);
    };
    Coordinate2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate2.prototype.getSize = function() {
      var _a = this.options, width = _a.width, height = _a.height;
      return [width, height];
    };
    Coordinate2.prototype.getCenter = function() {
      var _a = this.options, x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
      return [(x2 * 2 + width) / 2, (y2 * 2 + height) / 2];
    };
    Coordinate2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray3(__spreadArray3([], __read19(transformations), false), [__spreadArray3([], __read19(args), false)], false)
      });
      return this;
    };
    Coordinate2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate2.prototype.compose = function(invert2) {
      var e_1, _a;
      if (invert2 === void 0) {
        invert2 = false;
      }
      var transformations = invert2 ? __spreadArray3([], __read19(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert2 ? function(d2) {
        return d2.untransform;
      } : function(d2) {
        return d2.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add2 = function(transform2, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend2(transform2) : transform2);
      };
      try {
        for (var transformations_1 = __values(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read19(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x2 = _c.x, y2 = _c.y, width = _c.width, height = _c.height;
            var transformer2 = createTransformer(__spreadArray3([], __read19(args), false), x2, y2, width, height);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert2);
                add2(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform = getter(transformer2) || identity_default3;
              add2(transform, name_1 !== "parallel");
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a = transformations_1.return)) _a.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform = this.createMatrixTransform(matrixes, invert2);
        add2(transform);
      }
      return compose2.apply(void 0, __spreadArray3([], __read19(transforms), false));
    };
    Coordinate2.prototype.createMatrixTransform = function(matrixes, invert2) {
      var matrix2 = mat3_exports.create();
      if (invert2)
        matrixes.reverse();
      matrixes.forEach(function(m2) {
        return mat3_exports.mul(matrix2, matrix2, m2);
      });
      if (invert2) {
        mat3_exports.invert(matrix2, mat3_exports.clone(matrix2));
      }
      return function(vector) {
        var vector3 = [vector[0], vector[1], 1];
        vec3_exports.transformMat3(vector3, vector3, matrix2);
        return [vector3[0], vector3[1]];
      };
    };
    return Coordinate2;
  }()
);

// node_modules/@antv/coord/esm/coordinate3D.js
var __read20 = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values2 = function(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate3D = (
  /** @class */
  function() {
    function Coordinate3D2(options) {
      this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      };
      this.transformers = {
        cartesian3D,
        translate3D,
        scale3D,
        transpose3D
      };
      this.update(options);
    }
    Coordinate3D2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate3D2.prototype.clone = function() {
      return new Coordinate3D2(this.options);
    };
    Coordinate3D2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate3D2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate3D2.prototype.getSize = function() {
      var _a = this.options, width = _a.width, height = _a.height, depth = _a.depth;
      return [width, height, depth];
    };
    Coordinate3D2.prototype.getCenter = function() {
      var _a = this.options, x2 = _a.x, y2 = _a.y, z = _a.z, width = _a.width, height = _a.height, depth = _a.depth;
      return [(x2 * 2 + width) / 2, (y2 * 2 + height) / 2, (z * 2 + depth) / 2];
    };
    Coordinate3D2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray4(__spreadArray4([], __read20(transformations), false), [__spreadArray4([], __read20(args), false)], false)
      });
      return this;
    };
    Coordinate3D2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate3D2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate3D2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate3D2.prototype.compose = function(invert2) {
      var e_1, _a;
      if (invert2 === void 0) {
        invert2 = false;
      }
      var transformations = invert2 ? __spreadArray4([], __read20(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert2 ? function(d2) {
        return d2.untransform;
      } : function(d2) {
        return d2.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add2 = function(transform2, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3D(transform2) : transform2);
      };
      try {
        for (var transformations_1 = __values2(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read20(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x2 = _c.x, y2 = _c.y, z = _c.z, width = _c.width, height = _c.height, depth = _c.depth;
            var transformer2 = createTransformer(__spreadArray4([], __read20(args), false), x2, y2, z, width, height, depth);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert2);
                add2(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform = getter(transformer2) || identity_default3;
              add2(transform, true);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a = transformations_1.return)) _a.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform = this.createMatrixTransform(matrixes, invert2);
        add2(transform);
      }
      return compose2.apply(void 0, __spreadArray4([], __read20(transforms), false));
    };
    Coordinate3D2.prototype.createMatrixTransform = function(matrixes, invert2) {
      var matrix2 = mat4_exports.create();
      if (invert2)
        matrixes.reverse();
      matrixes.forEach(function(m2) {
        return mat4_exports.mul(matrix2, matrix2, m2);
      });
      if (invert2) {
        mat4_exports.invert(matrix2, mat4_exports.clone(matrix2));
      }
      return function(vector) {
        var vector4 = [vector[0], vector[1], vector[2], 1];
        vec4_exports.transformMat4(vector4, vector4, matrix2);
        return [vector4[0], vector4[1], vector4[2]];
      };
    };
    return Coordinate3D2;
  }()
);

// node_modules/@antv/g2/esm/composition/utils.js
var __rest60 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function useDefaultAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, adaptor33(options, ...rest), options);
}
function useOverrideAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, options, adaptor33(options, ...rest));
}
function isObject2(d2) {
  if (d2 instanceof Date)
    return false;
  return typeof d2 === "object";
}
function mergeData(dataDescriptor, dataValue) {
  if (!dataDescriptor)
    return dataValue;
  if (Array.isArray(dataDescriptor))
    return dataDescriptor;
  if (isObject2(dataDescriptor)) {
    const { value: value2 = dataValue } = dataDescriptor, rest = __rest60(dataDescriptor, ["value"]);
    return Object.assign(Object.assign({}, rest), { value: value2 });
  }
  return dataDescriptor;
}

// node_modules/@antv/g2/esm/composition/spaceLayer.js
var __rest61 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SpaceLayer = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
    return children.map((_a) => {
      var { data, x: x2, y: y2, width, height } = _a, rest = __rest61(_a, ["data", "x", "y", "width", "height"]);
      return Object.assign(Object.assign({}, rest), { data: mergeData(data, layerData), x: x2 !== null && x2 !== void 0 ? x2 : viewX, y: y2 !== null && y2 !== void 0 ? y2 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
    });
  };
};
SpaceLayer.props = {};

// node_modules/@antv/g2/esm/composition/spaceFlex.js
var __rest62 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SpaceFlex = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { direction = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
    const [mainStart, mainSize, crossSize, crossStart] = direction === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
    const sum4 = ratio.reduce((total, value2) => total + value2);
    const totalSize = options[mainSize] - padding * (children.length - 1);
    const sizes = ratio.map((value2) => totalSize * (value2 / sum4));
    const newChildren = [];
    let next = options[mainStart] || 0;
    for (let i = 0; i < sizes.length; i += 1) {
      const _a = children[i], { data } = _a, rest = __rest62(_a, ["data"]);
      const newData = mergeData(data, flexData);
      newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
      next += sizes[i] + padding;
    }
    return newChildren;
  };
};
SpaceFlex.props = {};

// node_modules/@antv/g2/esm/composition/view.js
var __rest63 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var View = () => {
  return (options) => {
    const { children } = options, restOptions = __rest63(options, ["children"]);
    if (!Array.isArray(children))
      return [];
    const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest = __rest63(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
    const marks = children.map((_a) => {
      var { data, scale: scale3 = {}, axis = {}, legend = {}, encode = {}, transform = [] } = _a, rest2 = __rest63(_a, ["data", "scale", "axis", "legend", "encode", "transform"]);
      return Object.assign({ data: mergeData(data, viewData), scale: deep_mix_default({}, viewScale, scale3), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest2);
    });
    return [Object.assign(Object.assign({}, rest), { marks, type: "standardView" })];
  };
};
View.props = {};

// node_modules/@antv/g2/esm/composition/mark.js
var __rest64 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Mark = ({ static: isStatic = false } = {}) => {
  return (options) => {
    const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data, coordinate, theme, component, interaction, x: x2, y: y2, z, key, frame, labelTransform, parentKey, clip, viewStyle, title } = options, mark2 = __rest64(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
    return [
      Object.assign(Object.assign({
        type: "standardView",
        x: x2,
        y: y2,
        z,
        key,
        width,
        height,
        depth,
        padding,
        paddingLeft,
        paddingRight,
        paddingTop,
        inset,
        insetLeft,
        insetTop,
        insetRight,
        insetBottom,
        paddingBottom,
        theme,
        coordinate,
        component,
        interaction,
        frame,
        labelTransform,
        margin,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        parentKey,
        clip,
        style: viewStyle
      }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark2), { key: `${key}-0`, data }), isStatic && { title })] })
    ];
  };
};
Mark.props = {};

// node_modules/@antv/g2/esm/utils/container.js
var Container = class _Container {
  constructor(x2) {
    this.$value = x2;
  }
  static of(x2) {
    return new _Container(x2);
  }
  call(f, ...rest) {
    return this.$value = f(this.$value, ...rest), this;
  }
  value() {
    return this.$value;
  }
};

// node_modules/@antv/g2/esm/composition/facetRect.js
var __rest65 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale = useDefaultAdaptor((options) => {
  const { encode, data, scale: scale3, shareSize = false } = options;
  const { x: x2, y: y2 } = encode;
  const flexDomain = (encode2, channel) => {
    var _a;
    if (encode2 === void 0 || !shareSize)
      return {};
    const groups2 = group(data, (d2) => d2[encode2]);
    const domain = ((_a = scale3 === null || scale3 === void 0 ? void 0 : scale3[channel]) === null || _a === void 0 ? void 0 : _a.domain) || Array.from(groups2.keys());
    const flex = domain.map((key) => {
      if (!groups2.has(key))
        return 1;
      return groups2.get(key).length;
    });
    return { domain, flex };
  };
  return {
    scale: {
      x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x2 === void 0 ? null : { position: "top" } }, x2 === void 0 && { paddingInner: 0 }), flexDomain(x2, "x")),
      y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y2 === void 0 ? null : { position: "right" } }, y2 === void 0 && { paddingInner: 0 }), flexDomain(y2, "y"))
    }
  };
});
var inferColor = useOverrideAdaptor((options) => {
  const { data, scale: scale3, legend } = options;
  const discovered = [options];
  let encodeColor;
  let scaleColor;
  let legendColor;
  while (discovered.length) {
    const node = discovered.shift();
    const { children, encode = {}, scale: scale4 = {}, legend: legend2 = {} } = node;
    const { color: c4 } = encode;
    const { color: cs } = scale4;
    const { color: cl } = legend2;
    if (c4 !== void 0)
      encodeColor = c4;
    if (cs !== void 0)
      scaleColor = cs;
    if (cl !== void 0)
      legendColor = cl;
    if (Array.isArray(children)) {
      discovered.push(...children);
    }
  }
  const domainColor = () => {
    var _a;
    const domain2 = (_a = scale3 === null || scale3 === void 0 ? void 0 : scale3.color) === null || _a === void 0 ? void 0 : _a.domain;
    if (domain2 !== void 0)
      return [domain2];
    if (encodeColor === void 0)
      return [void 0];
    const color2 = typeof encodeColor === "function" ? encodeColor : (d2) => d2[encodeColor];
    const values3 = data.map(color2);
    if (values3.some((d2) => typeof d2 === "number"))
      return [extent(values3)];
    return [Array.from(new Set(values3)), "ordinal"];
  };
  const title = typeof encodeColor === "string" ? encodeColor : "";
  const [domain, type] = domainColor();
  return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
    legend: { color: deep_mix_default({ title }, legendColor) }
  });
});
var setAnimation = useDefaultAdaptor(() => ({
  animate: {
    enterType: "fadeIn"
  }
}));
var setStyle = useOverrideAdaptor(() => ({
  frame: false,
  encode: {
    shape: "hollow"
  },
  style: {
    lineWidth: 0
  }
}));
var toCell = useOverrideAdaptor(() => ({
  type: "cell"
}));
var setData = useOverrideAdaptor((options) => {
  const { data } = options;
  const connector = {
    type: "custom",
    callback: () => {
      const { data: data2, encode } = options;
      const { x: x2, y: y2 } = encode;
      const X = x2 ? Array.from(new Set(data2.map((d2) => d2[x2]))) : [];
      const Y = y2 ? Array.from(new Set(data2.map((d2) => d2[y2]))) : [];
      const cellData = () => {
        if (X.length && Y.length) {
          const cellData2 = [];
          for (const vx of X) {
            for (const vy of Y) {
              cellData2.push({ [x2]: vx, [y2]: vy });
            }
          }
          return cellData2;
        }
        if (X.length)
          return X.map((d2) => ({ [x2]: d2 }));
        if (Y.length)
          return Y.map((d2) => ({ [y2]: d2 }));
      };
      return cellData();
    }
  };
  return {
    data: { type: "inline", value: data, transform: [connector] }
  };
});
var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
  const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
  const { value: data } = dataValue;
  const { x: encodeX, y: encodeY } = encode;
  const { color: facetScaleColor } = facetScale;
  const { domain: facetDomainColor } = facetScaleColor;
  const createChildren = (visualData, scale3, layout) => {
    const { x: scaleX, y: scaleY } = scale3;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index2 = indexOf(visualData);
    const bboxs = visualData.map(subLayout);
    const values3 = visualData.map(({ x: x2, y: y2 }) => [
      scaleX.invert(x2),
      scaleY.invert(y2)
    ]);
    const filters = values3.map(([fx, fy]) => (d2) => {
      const { [encodeX]: x2, [encodeY]: y2 } = d2;
      const inX = encodeX !== void 0 ? x2 === fx : true;
      const inY = encodeY !== void 0 ? y2 === fy : true;
      return inX && inY;
    });
    const facetData2d = filters.map((f) => data.filter(f));
    const maxDataDomain = shareData ? max(facetData2d, (data2) => data2.length) : void 0;
    const facets = values3.map(([fx, fy]) => ({
      columnField: encodeX,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: encodeY,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index2.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const facet = facets[i];
      const facetData = facetData2d[i];
      const children2 = normalizedChildren[i];
      return children2.map((_a) => {
        var _b, _c;
        var { scale: scale4, key, facet: isFacet = true, axis = {}, legend = {} } = _a, rest = __rest65(_a, ["scale", "key", "facet", "axis", "legend"]);
        const guideY = ((_b = scale4 === null || scale4 === void 0 ? void 0 : scale4.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
        const guideX = ((_c = scale4 === null || scale4 === void 0 ? void 0 : scale4.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
        const defaultScale = {
          x: { tickCount: encodeX ? 5 : void 0 },
          y: { tickCount: encodeY ? 5 : void 0 }
        };
        const newData = isFacet ? facetData : facetData.length === 0 ? [] : data;
        const newScale = {
          color: { domain: facetDomainColor }
        };
        const newAxis = {
          x: createGuide(guideX, createGuideX2)(facet, newData),
          y: createGuide(guideY, createGuideY2)(facet, newData)
        };
        return Object.assign(Object.assign({
          key: `${key}-${i}`,
          data: newData,
          margin: 0,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          parentKey: viewKey,
          width,
          height,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: newData.length ? true : false,
          dataDomain: maxDataDomain,
          scale: deep_mix_default(defaultScale, scale4, newScale),
          axis: deep_mix_default({}, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false
        }, rest), childOptions);
      });
    });
  };
  return {
    children: createChildren
  };
});
function subLayoutRect(data) {
  const { points } = data;
  return calcBBox(points);
}
function createInnerGuide(guide, data) {
  return data.length ? deep_mix_default({
    title: false,
    tick: null,
    label: null
  }, guide) : deep_mix_default({
    title: false,
    tick: null,
    label: null,
    grid: null
  }, guide);
}
function createGuideXRect(guide) {
  return (facet, data) => {
    const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guide, data);
    const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
    const grid = data.length ? void 0 : null;
    return deep_mix_default({ title, grid }, guide);
  };
}
function createGuideYRect(guide) {
  return (facet, data) => {
    const { rowIndex, columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guide, data);
    const title = rowIndex !== 0 ? false : void 0;
    const grid = data.length ? void 0 : null;
    return deep_mix_default({ title, grid }, guide);
  };
}
function createGuide(guide, factory) {
  if (typeof guide === "function")
    return guide;
  if (guide === null || guide === false)
    return () => null;
  return factory(guide);
}
var FacetRect = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
    return [newOptions];
  };
};
FacetRect.props = {};

// node_modules/@antv/g2/esm/composition/repeatMatrix.js
var __rest66 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale2 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setChildren2 = useOverrideAdaptor((options) => {
  const { data, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
  const createChildren = (visualData, scale3, layout) => {
    const { x: scaleX, y: scaleY } = scale3;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index2 = indexOf(visualData);
    const bboxs = visualData.map(({ points }) => calcBBox(points));
    const values3 = visualData.map(({ x: x2, y: y2 }) => [
      scaleX.invert(x2),
      scaleY.invert(y2)
    ]);
    const facets = values3.map(([fx, fy]) => ({
      columnField: fx,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: fy,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index2.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const [fx, fy] = values3[i];
      const facet = facets[i];
      const children2 = normalizedChildren[i];
      return children2.map((d2) => {
        var _a, _b;
        const { scale: scale4, key, encode, axis, interaction } = d2, rest = __rest66(d2, ["scale", "key", "encode", "axis", "interaction"]);
        const guideY = (_a = scale4 === null || scale4 === void 0 ? void 0 : scale4.y) === null || _a === void 0 ? void 0 : _a.guide;
        const guideX = (_b = scale4 === null || scale4 === void 0 ? void 0 : scale4.x) === null || _b === void 0 ? void 0 : _b.guide;
        const defaultScale = {
          // Do not sync position scales among facets by default.
          x: { facet: false },
          // Do not sync position scales among facets by default.
          y: { facet: false }
        };
        const newAxis = {
          x: createGuideX(guideX)(facet, data),
          y: createGuideY(guideY)(facet, data)
        };
        const defaultAxis = {
          x: { tickCount: 5 },
          y: { tickCount: 5 }
        };
        return Object.assign({
          data,
          parentKey: viewKey,
          key: `${key}-${i}`,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          width,
          height,
          margin: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: true,
          scale: deep_mix_default(defaultScale, scale4),
          axis: deep_mix_default(defaultAxis, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false,
          encode: deep_mix_default({}, encode, {
            x: fx,
            y: fy
          }),
          interaction: deep_mix_default({}, interaction, {
            // Register this interaction in parent node.
            legendFilter: false
          })
        }, rest);
      });
    });
  };
  return {
    children: createChildren
  };
});
var setData2 = useOverrideAdaptor((options) => {
  const { encode } = options, rest = __rest66(options, ["encode"]);
  const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest66(encode, ["position", "x", "y"]);
  const data = [];
  for (const $x of [X].flat(1)) {
    for (const $y of [Y].flat(1)) {
      data.push({ $x, $y });
    }
  }
  return Object.assign(Object.assign({}, rest), { data, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
});
function createGuideX(guideX) {
  if (typeof guideX === "function")
    return guideX;
  if (guideX === null)
    return () => null;
  return (facet, data) => {
    const { rowIndex, rowValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guideX, data);
  };
}
function createGuideY(guideY) {
  if (typeof guideY === "function")
    return guideY;
  if (guideY === null)
    return () => null;
  return (facet, data) => {
    const { columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guideY, data);
  };
}
var RepeatMatrix = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/facetCircle.js
var __rest67 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale3 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setCoordinate = useDefaultAdaptor((options) => {
  return {
    coordinate: { type: "polar" }
  };
});
var setEncode = (options) => {
  const { encode } = options, rest = __rest67(options, ["encode"]);
  const { position } = encode;
  return Object.assign(Object.assign({}, rest), { encode: { x: position } });
};
function createGuideFacetCircle(guide) {
  return (facet) => null;
}
function subLayoutFacetCircle(data) {
  const { points } = data;
  const [p0, p1, p2, p3] = points;
  const sr = dist(p0, p3);
  const v0 = sub(p0, p3);
  const v1 = sub(p1, p2);
  const a01 = angleBetween(v0, v1);
  const t = 1 / Math.sin(a01 / 2);
  const ir = sr / (1 + t);
  const s2 = ir * Math.sqrt(2);
  const [x05, y05] = p2;
  const a0 = angleWithQuadrant(v0);
  const a3 = a0 + a01 / 2;
  const d2 = ir * t;
  const cx = x05 + d2 * Math.sin(a3);
  const cy = y05 - d2 * Math.cos(a3);
  return [cx - s2 / 2, cy - s2 / 2, s2, s2];
}
var FacetCircle = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/timingKeyframe.js
function range2(direction, iterationCount, keyframeCount) {
  const start = 0;
  const end = keyframeCount;
  const normal = [start, end];
  const reverse2 = [-end + 1, -start + 1];
  if (direction === "normal")
    return normal;
  if (direction === "reverse")
    return reverse2;
  if (direction === "alternate") {
    return iterationCount % 2 === 0 ? normal : reverse2;
  }
  if (direction === "reverse-alternate") {
    return iterationCount % 2 === 0 ? reverse2 : normal;
  }
}
function setAnimation2(node, duration, easing) {
  const discovered = [node];
  while (discovered.length) {
    const n = discovered.pop();
    n.animate = deep_mix_default({
      enter: {
        duration
      },
      update: {
        duration,
        easing,
        type: "morphing",
        fill: "both"
      },
      exit: {
        type: "fadeOut",
        duration
      }
    }, n.animate || {});
    const { children } = n;
    if (Array.isArray(children))
      discovered.push(...children);
  }
  return node;
}
var TimingKeyframe = () => {
  return (options) => {
    const { children = [], duration = 1e3, iterationCount = 1, direction = "normal", easing = "ease-in-out-sine" } = options;
    const n = children.length;
    if (!Array.isArray(children) || n === 0)
      return [];
    const { key } = children[0];
    const newChildren = children.map((d2) => Object.assign(Object.assign({}, d2), { key })).map((d2) => setAnimation2(d2, duration, easing));
    return function* () {
      let count4 = 0;
      let prevIndex;
      while (iterationCount === "infinite" || count4 < iterationCount) {
        const [start, end] = range2(direction, count4, n);
        for (let i = start; i < end; i += 1) {
          const index2 = Math.abs(i);
          if (prevIndex !== index2)
            yield newChildren[index2];
          prevIndex = index2;
        }
        count4++;
      }
    };
  };
};
TimingKeyframe.props = {};

// node_modules/@antv/g2/esm/composition/geoPath.js
var __rest68 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var GeoPath = () => {
  return (options) => {
    const { type, data, scale: scale3, encode, style, animate, key, state } = options, rest = __rest68(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state"]);
    return [
      Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
        {
          type: "geoPath",
          key: `${key}-0`,
          data: {
            value: data
          },
          scale: scale3,
          encode,
          style,
          animate,
          state
        }
      ] })
    ];
  };
};
GeoPath.props = {};

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi3 : Math.acos(x2);
}
function asin2(x2) {
  return x2 > 1 ? halfPi2 : x2 < -1 ? -halfPi2 : Math.asin(x2);
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian2(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a3, b) {
  return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
}
function cartesianCross(a3, b) {
  return [a3[1] * b[2] - a3[2] * b[1], a3[2] * b[0] - a3[0] * b[2], a3[0] * b[1] - a3[1] * b[0]];
}
function cartesianAddInPlace(a3, b) {
  a3[0] += b[0], a3[1] += b[1], a3[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d2) {
  var l = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l, d2[1] /= l, d2[2] /= l;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a3, b) {
  function compose3(x2, y2) {
    return x2 = a3(x2, y2), b(x2[0], x2[1]);
  }
  if (a3.invert && b.invert) compose3.invert = function(x2, y2) {
    return x2 = b.invert(x2, y2), x2 && a3.invert(x2[0], x2[1]);
  };
  return compose3;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x2 = cos2(lambda) * cosPhi, y2 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan22(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x2 = cos2(lambda) * cosPhi, y2 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan22(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate2) {
  rotate2 = rotateRadians(rotate2[0] * radians, rotate2[1] * radians, rotate2.length > 2 ? rotate2[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate2(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate2.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t02, t12) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t02 == null) {
    t02 = radius + direction * tau3;
    t12 = radius - step / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction > 0 ? t02 < t12 : t02 > t12) t02 += direction * tau3;
  }
  for (var point6, t = t02; direction > 0 ? t > t12 : t < t12; t -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian2(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius = acos2(-point6[1]);
  return ((-point6[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line3;
  return {
    point: function(x2, y2, m2) {
      line3.push([x2, y2, m2]);
    },
    lineStart: function() {
      lines.push(line3 = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line3 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a3, b) {
  return abs2(a3[0] - b[0]) < epsilon3 && abs2(a3[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p0 = segment[0], p1 = segment[n2], x2;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point6;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point6 = points[i])[0], point6[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point6 = points[i])[0], point6[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n = array2.length)) return;
  var n, i = 0, a3 = array2[0], b;
  while (++i < n) {
    a3.n = b = array2[i];
    b.p = a3;
    a3 = b;
  }
  a3.n = b = array2[0];
  b.p = a3;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi3 ? point6[0] : sign2(point6[0]) * ((abs2(point6[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1) phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1) phi2 = -halfPi2 - epsilon3;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length)) continue;
    var ring, m2, point0 = ring[m2 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m2; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon3 || angle2 < epsilon3 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(sink) {
    var line3 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line3.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line3.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line3.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i) sink.point((point7 = segment[i])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a3, b) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi2 - epsilon3 : halfPi2 - a3[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon3) lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3) lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate2(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c4 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point22 = intersect3(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect3(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect3(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c4 & c0) && (t = intersect3(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c4;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect3(a3, b, two) {
    var pa = cartesian2(a3), pb = cartesian2(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a3;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t = sqrt2(t22), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a3[0], lambda1 = b[0], phi0 = a3[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar2 = abs2(delta2 - pi3) < epsilon3, meridian = polar2 || delta2 < epsilon3;
    if (!polar2 && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q12 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q12, A5);
      return [q, spherical(q12)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi2 < -r) code2 |= 4;
    else if (phi2 > r) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a3, b, x05, y05, x12, y12) {
  var ax = a3[0], ay = a3[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x05 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t02) return;
    if (r < t12) t12 = r;
  } else if (dx > 0) {
    if (r > t12) return;
    if (r > t02) t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t12) return;
    if (r > t02) t02 = r;
  } else if (dx > 0) {
    if (r < t02) return;
    if (r < t12) t12 = r;
  }
  r = y05 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t02) return;
    if (r < t12) t12 = r;
  } else if (dy > 0) {
    if (r > t12) return;
    if (r > t02) t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t12) return;
    if (r > t02) t02 = r;
  } else if (dy > 0) {
    if (r < t02) return;
    if (r < t12) t12 = r;
  }
  if (t02 > 0) a3[0] = ax + t02 * dx, a3[1] = ay + t02 * dy;
  if (t12 < 1) b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x2, y2) {
    return x05 <= x2 && x2 <= x12 && y05 <= y2 && y2 <= y12;
  }
  function interpolate2(from, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x05 : x12, a3 > 1 ? y12 : y05);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs2(p2[0] - x05) < epsilon3 ? direction > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon3 ? direction > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a3, b) {
    return comparePoint(a3.x, b.x);
  }
  function comparePoint(a3, b) {
    var ca = corner(a3, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a3[1] : ca === 1 ? a3[0] - b[0] : ca === 2 ? a3[1] - b[1] : b[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x2, y2) {
      if (visible(x2, y2)) activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point7 = ring2[j], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x2, y2) {
      var v = visible(x2, y2);
      if (polygon) ring.push([x2, y2]);
      if (first3) {
        x__ = x2, y__ = y2, v__ = v;
        first3 = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_) activeStream.point(x2, y2);
        else {
          var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (line_default2(a3, b, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y05, y12, dy) {
  var y2 = range(y05, y12 - epsilon3, dy).concat(y12);
  return function(x2) {
    return y2.map(function(y3) {
      return [x2, y3];
    });
  };
}
function graticuleY(x05, x12, dx) {
  var x2 = range(x05, x12 - epsilon3, dx).concat(x12);
  return function(y2) {
    return x2.map(function(x3) {
      return [x3, y2];
    });
  };
}
function graticule() {
  var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil(x05 / dx) * dx, x12, dx).filter(function(x3) {
      return abs2(x3 % DX) > epsilon3;
    }).map(x2)).concat(range(ceil(y05 / dy) * dy, y12, dy).filter(function(y3) {
      return abs2(y3 % DY) > epsilon3;
    }).map(y2));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X02, Y02], [X12, Y12]];
    X02 = +_[0][0], X12 = +_[1][0];
    Y02 = +_[0][1], Y12 = +_[1][1];
    if (X02 > X12) _ = X02, X02 = X12, X12 = _;
    if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x05, y05], [x12, y12]];
    x05 = +_[0][0], x12 = +_[1][0];
    y05 = +_[0][1], y12 = +_[1][1];
    if (x05 > x12) _ = x05, x05 = x12, x12 = _;
    if (y05 > y12) _ = y05, y05 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x2 = graticuleX(y05, y12, 90);
    y2 = graticuleY(x05, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x2) => x2;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream2.point = areaPoint;
  x00 = x0 = x2, y00 = y0 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum2.add(y0 * x2 - x0 * y2);
  x0 = x2, y0 = y2;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x02) x02 = x2;
  if (x2 > x1) x1 = x2;
  if (y2 < y02) y02 = y2;
  if (y2 > y1) y1 = y2;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x2, y2) {
  X0 += x2;
  Y0 += y2;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x2, y03 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x03, dy = y2 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y2) / 2;
  Z1 += z;
  centroidPoint(x03 = x2, y03 = y2);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x2, y002 = y03 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x03, dy = y2 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y2) / 2;
  Z1 += z;
  z = y03 * x2 - x03 * y2;
  X2 += z * (x03 + x2);
  Y2 += z * (y03 + y2);
  Z2 += z * 3;
  centroidPoint(x03 = x2, y03 = y2);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new Adder();
    return length;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x2, y003 = y04 = y2;
}
function lengthPoint(x2, y2) {
  x04 -= x2, y04 -= y2;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x2, y04 = y2;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x2, y2) {
    switch (this._point) {
      case 0: {
        this._append`M${x2},${y2}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x2},${y2}`;
        break;
      }
      default: {
        this._append`M${x2},${y2}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d2 > 15) return append2;
  if (d2 !== cacheDigits) {
    const k2 = 10 ** d2;
    cacheDigits = d2;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_) {
    if (!arguments.length) return projection2;
    projectionStream = _ == null ? (projection2 = null, identity_default4) : (projection2 = _).stream;
    return path2;
  };
  path2.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path2;
  };
  path2.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    if (context === null) contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods) s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y2 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}
function fitSize(projection2, size3, object) {
  return fitExtent(projection2, [[0, 0], size3], object);
}
function fitWidth(projection2, width, object) {
  return fit(projection2, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x2 = (w - k2 * (b[1][0] + b[0][0])) / 2, y2 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}
function fitHeight(projection2, height, object) {
  return fit(projection2, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y2 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x2, y2) {
      x2 = project(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b = b0 + b1, c4 = c0 + c1, m2 = sqrt2(a3 * a3 + b * b + c4 * c4), phi2 = asin2(c4 /= m2), lambda2 = abs2(abs2(c4) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a3), p2 = project(lambda2, phi2), x2 = p2[0], y2 = p2[1], dx2 = x2 - x05, dy2 = y2 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x2, y2, lambda2, a3 /= m2, b /= m2, c4, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a3, b, c4, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x2, y2) {
      x2 = project(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c4 = cartesian2([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c4[0], b0 = c4[1], c0 = c4[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function transformRotate(rotate2) {
  return transformer({
    point: function(x2, y2) {
      var r = rotate2(x2, y2);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [dx + k2 * x2, dy - k2 * y2];
  }
  transform.invert = function(x2, y2) {
    return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
  };
  return transform;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [a3 * x2 - b * y2 + dx, dy - b * x2 - a3 * y2];
  }
  transform.invert = function(x2, y2) {
    return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
  };
  return transform;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection2(point6) {
    return projectRotateTransform(point6[0] * radians, point6[1] * radians);
  }
  function invert2(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees, point6[1] * degrees];
  }
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x12 = y12 = null, identity_default4) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, recenter()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi2 = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt2(delta2);
  };
  projection2.fitExtent = function(extent2, object) {
    return fitExtent(projection2, extent2, object);
  };
  projection2.fitSize = function(size3, object) {
    return fitSize(projection2, size3, object);
  };
  projection2.fitWidth = function(width, object) {
    return fitWidth(projection2, width, object);
  };
  projection2.fitHeight = function(height, object) {
    return fitHeight(projection2, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform = scaleTranslateRotate(k2, x2 - center2[0], y2 - center2[1], sx, sy, alpha);
    rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform);
    projectRotateTransform = compose_default(rotate2, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m2 = projectionMutator(projectAt), p2 = m2(phi0, phi1);
  p2.parallels = function(_) {
    return arguments.length ? m2(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p2;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi0, asin2(y2 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin2(y05), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon3) return cylindricalEqualAreaRaw(y05);
  var c4 = 1 + sy0 * (2 * n - sy0), r0 = sqrt2(c4) / n;
  function project(x2, y2) {
    var r = sqrt2(c4 - 2 * n * sin2(y2)) / n;
    return [r * sin2(x2 *= n), r0 - r * cos2(x2)];
  }
  project.invert = function(x2, y2) {
    var r0y = r0 - y2, l = atan22(x2, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x2) * sign2(r0y);
    return [l / n, asin2((c4 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x2, y2) {
      var i = -1;
      while (++i < n) streams[i].point(x2, y2);
    },
    sphere: function() {
      var i = -1;
      while (++i < n) streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n) streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x2, y2) {
    point6 = [x2, y2];
  } };
  function albersUsa(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    return point6 = null, (lower48Point.point(x2, y2), point6) || (alaskaPoint.point(x2, y2), point6) || (hawaiiPoint.point(x2, y2), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x2 = (coordinates[0] - t[0]) / k2, y2 = (coordinates[1] - t[1]) / k2;
    return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x2 = +_[0], y2 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x2 - 0.455 * k2, y2 - 0.238 * k2], [x2 + 0.455 * k2, y2 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k2, y2 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon3, y2 + 0.12 * k2 + epsilon3], [x2 - 0.214 * k2 - epsilon3, y2 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y2 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon3, y2 + 0.166 * k2 + epsilon3], [x2 - 0.115 * k2 - epsilon3, y2 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size3, object) {
    return fitSize(albersUsa, size3, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale3) {
  return function(x2, y2) {
    var cx = cos2(x2), cy = cos2(y2), k2 = scale3(cx * cy);
    if (k2 === Infinity) return [2, 0];
    return [
      k2 * cy * sin2(x2),
      k2 * sin2(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z = sqrt2(x2 * x2 + y2 * y2), c4 = angle2(z), sc = sin2(c4), cc = cos2(c4);
    return [
      atan22(x2 * sc, z * cc),
      asin2(z && y2 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c4) {
  return (c4 = acos2(c4)) && c4 / sin2(c4);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m2 = projection(project), center2 = m2.center, scale3 = m2.scale, translate2 = m2.translate, clipExtent = m2.clipExtent, x05 = null, y05, x12, y12;
  m2.scale = function(_) {
    return arguments.length ? (scale3(_), reclip()) : scale3();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate2(_), reclip()) : translate2();
  };
  m2.center = function(_) {
    return arguments.length ? (center2(_), reclip()) : center2();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x05 = y05 = x12 = y12 = null : (x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale3(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x12), y12]] : [[x05, Math.max(t[1] - k2, y05)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y2) {
  return tan((halfPi2 + y2) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos2(y05), n = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f = cy0 * pow(tany(y05), n) / n;
  if (!n) return mercatorRaw;
  function project(x2, y2) {
    if (f > 0) {
      if (y2 < -halfPi2 + epsilon3) y2 = -halfPi2 + epsilon3;
    } else {
      if (y2 > halfPi2 - epsilon3) y2 = halfPi2 - epsilon3;
    }
    var r = f / pow(tany(y2), n);
    return [r * sin2(n * x2), f - r * cos2(n * x2)];
  }
  project.invert = function(x2, y2) {
    var fy = f - y2, r = sign2(n) * sqrt2(x2 * x2 + fy * fy), l = atan22(x2, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x2) * sign2(fy);
    return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos2(y05), n = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n + y05;
  if (abs2(n) < epsilon3) return equirectangularRaw;
  function project(x2, y2) {
    var gy = g - y2, nx = n * x2;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x2, y2) {
    var gy = g - y2, l = atan22(x2, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x2) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt2(x2 * x2 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x2, y2) {
  var cy = cos2(y2), k2 = cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y2) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default5() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx2 = 1, ky2 = 1, transform = transformer({
    point: function(x2, y2) {
      var p2 = projection2([x2, y2]);
      this.stream.point(p2[0], p2[1]);
    }
  }), postclip = identity_default4, cache2, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection2;
  }
  function projection2(p2) {
    var x2 = p2[0] * kx2, y2 = p2[1] * ky2;
    if (alpha) {
      var t = y2 * ca - x2 * sa;
      x2 = x2 * ca + y2 * sa;
      y2 = t;
    }
    return [x2 + tx, y2 + ty];
  }
  projection2.invert = function(p2) {
    var x2 = p2[0] - tx, y2 = p2[1] - ty;
    if (alpha) {
      var t = y2 * ca + x2 * sa;
      x2 = x2 * ca - y2 * sa;
      y2 = t;
    }
    return [x2 / kx2, y2 / ky2];
  };
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x12 = y12 = null, identity_default4) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, reset()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object) {
    return fitExtent(projection2, extent2, object);
  };
  projection2.fitSize = function(size3, object) {
    return fitSize(projection2, size3, object);
  };
  projection2.fitWidth = function(width, object) {
    return fitWidth(projection2, width, object);
  };
  projection2.fitHeight = function(height, object) {
    return fitHeight(projection2, height, object);
  };
  return projection2;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi2 = y2, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon3 && --i > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x2, y2) {
  return [cos2(y2) * sin2(x2), sin2(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x2, y2) {
  var cy = cos2(y2), k2 = 1 + cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y2) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi2];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate2 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
  };
  return rotate2([0, 0, 90]).scale(159.155);
}

// node_modules/@antv/g2/esm/composition/d3Projection.js
var d3Projection_exports = {};
__export(d3Projection_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoIdentity: () => identity_default5,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoProjection: () => projection,
  geoProjectionMutator: () => projectionMutator,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});

// node_modules/@antv/g2/esm/composition/geoView.js
var __rest69 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function normalizeProjection(type) {
  if (typeof type === "function")
    return type;
  const name2 = `geo${upper_first_default(type)}`;
  const projection2 = d3Projection_exports[name2];
  if (!projection2)
    throw new Error(`Unknown coordinate: ${type}`);
  return projection2;
}
function mergeGeoJSON(gjs) {
  return {
    type: "FeatureCollection",
    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
  };
}
function normalizeGeoJSON(gj) {
  const types = {
    Point: "geometry",
    MultiPoint: "geometry",
    LineString: "geometry",
    MultiLineString: "geometry",
    Polygon: "geometry",
    MultiPolygon: "geometry",
    GeometryCollection: "geometry",
    Feature: "feature",
    FeatureCollection: "featureCollection"
  };
  if (!gj || !gj.type)
    return null;
  const type = types[gj.type];
  if (!type)
    return null;
  if (type === "geometry") {
    return {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          properties: {},
          geometry: gj
        }
      ]
    };
  } else if (type === "feature") {
    return {
      type: "FeatureCollection",
      features: [gj]
    };
  } else if (type === "featureCollection") {
    return gj;
  }
}
function setProjectionOptions(projection2, options) {
  var _a;
  for (const [key, value2] of Object.entries(options)) {
    (_a = projection2[key]) === null || _a === void 0 ? void 0 : _a.call(projection2, value2);
  }
}
function setProjectionSize(projection2, nodes, layout, options) {
  const defaultOutline = () => {
    const geoNodes = nodes.filter(isGeoPath);
    const sphere = geoNodes.find((d2) => d2.sphere);
    if (sphere)
      return { type: "Sphere" };
    return mergeGeoJSON(geoNodes.filter((d2) => !d2.sphere).flatMap((d2) => d2.data.value));
  };
  const { outline = defaultOutline() } = options;
  const { size: size3 = "fitExtent" } = options;
  if (size3 === "fitExtent") {
    return setFitExtent(projection2, outline, layout);
  } else if (size3 === "fitWidth") {
    return setFitWidth(projection2, outline, layout);
  }
}
function setFitExtent(projection2, object, layout) {
  const { x: x2, y: y2, width, height } = layout;
  projection2.fitExtent([
    [x2, y2],
    [width, height]
  ], object);
}
function setFitWidth(projection2, object, layout) {
  const { width, height } = layout;
  const [[x05, y05], [x12, y12]] = path_default2(projection2.fitWidth(width, object)).bounds(object);
  const dy = Math.ceil(y12 - y05);
  const l = Math.min(Math.ceil(x12 - x05), dy);
  const s2 = projection2.scale() * (l - 1) / l;
  const [tx, ty] = projection2.translate();
  const t = ty + (height - dy) / 2;
  projection2.scale(s2).translate([tx, t]).precision(0.2);
}
function normalizeDataSource(node) {
  const { data } = node;
  if (Array.isArray(data))
    return Object.assign(Object.assign({}, node), { data: { value: data } });
  const { type } = data;
  if (type === "graticule10") {
    return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
  } else if (type === "sphere") {
    return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
  }
  return node;
}
function isGeoPath(d2) {
  return d2.type === "geoPath";
}
var GeoView = () => {
  return (options) => {
    const { children, coordinate: projection2 = {} } = options;
    if (!Array.isArray(children))
      return [];
    const { type = "equalEarth" } = projection2, projectionOptions = __rest69(projection2, ["type"]);
    const createProjection = normalizeProjection(type);
    const nodes = children.map(normalizeDataSource);
    let path2;
    function Geo() {
      return [
        [
          "custom",
          (x2, y2, width, height) => {
            const visual = createProjection();
            const layout = { x: x2, y: y2, width, height };
            setProjectionSize(visual, nodes, layout, projectionOptions);
            setProjectionOptions(visual, projectionOptions);
            path2 = path_default2(visual);
            const scaleX = new Linear({
              domain: [x2, x2 + width]
            });
            const scaleY = new Linear({
              domain: [y2, y2 + height]
            });
            const normalize3 = (point6) => {
              const visualPoint = visual(point6);
              if (!visualPoint)
                return [null, null];
              const [vx, vy] = visualPoint;
              return [scaleX.map(vx), scaleY.map(vy)];
            };
            const normalizeInvert = (point6) => {
              if (!point6)
                return null;
              const [px, py] = point6;
              const visualPoint = [scaleX.invert(px), scaleY.invert(py)];
              return visual.invert(visualPoint);
            };
            return {
              transform: (point6) => normalize3(point6),
              untransform: (point6) => normalizeInvert(point6)
            };
          }
        ]
      ];
    }
    function GeoPath2(options2) {
      const { style, tooltip: tooltip2 = {} } = options2;
      return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
        title: "id",
        items: [{ channel: "color" }]
      }), style: Object.assign(Object.assign({}, style), { d: (d2) => path2(d2) || [] }) });
    }
    const t = (d2) => isGeoPath(d2) ? GeoPath2(d2) : d2;
    return [
      Object.assign(Object.assign({}, options), { type: "view", scale: {
        x: { type: "identity" },
        y: { type: "identity" }
      }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
    ];
  };
};
GeoView.props = {};

// node_modules/@antv/g2/esm/interaction/event.js
function dataOf(element, view) {
  const { __data__: datum } = element;
  const { markKey, index: index2, seriesIndex } = datum;
  const { markState } = view;
  const selectedMark = Array.from(markState.keys()).find((mark2) => mark2.key === markKey);
  if (!selectedMark)
    return;
  if (seriesIndex) {
    return seriesIndex.map((i) => selectedMark.data[i]);
  }
  return selectedMark.data[index2];
}
function maybeComponentRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "component");
}
function maybeElementRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "element");
}
function maybeLabelRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "label");
}
function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
  return (e) => {
    if (!predicate(e))
      return;
    emitter.emit(`plot:${eventType}`, e);
    const { target } = e;
    if (!target)
      return;
    const { className: className2 } = target;
    if (className2 === "plot")
      return;
    const elementRoot = maybeElementRoot(target);
    const componentRoot = maybeComponentRoot(target);
    const babelRoot = maybeLabelRoot(target);
    const root = elementRoot || componentRoot || babelRoot;
    if (!root)
      return;
    const { className: elementType, markType } = root;
    const e1 = Object.assign(Object.assign({}, e), { nativeEvent: true });
    if (elementType === "element") {
      e1["data"] = { data: dataOf(root, view) };
      emitter.emit(`element:${eventType}`, e1);
      emitter.emit(`${markType}:${eventType}`, e1);
    } else if (elementType === "label") {
      e1["data"] = { data: root.attributes.datum };
      emitter.emit(`label:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    } else {
      emitter.emit(`component:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    }
  };
}
function Event() {
  return (context, _, emitter) => {
    const { container, view } = context;
    const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e) => e.detail === 1);
    const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e) => e.detail === 2);
    const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
    const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
    const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
    const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
    const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
    const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
    const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
    const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
    const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
    const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
    const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
    const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
    const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
    const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
    const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
    const drop = bubblesEvent(ChartEvent.DROP, view, emitter);
    container.addEventListener("click", click);
    container.addEventListener("click", dblclick2);
    container.addEventListener("pointertap", pointertap);
    container.addEventListener("pointerdown", pointerdown);
    container.addEventListener("pointerup", pointerup);
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    container.addEventListener("pointermove", pointermove);
    container.addEventListener("pointerenter", pointerenter);
    container.addEventListener("pointerleave", pointerleave);
    container.addEventListener("pointerupoutside", pointerupoutside);
    container.addEventListener("dragstart", dragstart);
    container.addEventListener("drag", drag);
    container.addEventListener("dragend", dragend);
    container.addEventListener("dragenter", dragenter);
    container.addEventListener("dragleave", dragleave);
    container.addEventListener("dragover", dragover);
    container.addEventListener("drop", drop);
    return () => {
      container.removeEventListener("click", click);
      container.removeEventListener("click", dblclick2);
      container.removeEventListener("pointertap", pointertap);
      container.removeEventListener("pointerdown", pointerdown);
      container.removeEventListener("pointerup", pointerup);
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      container.removeEventListener("pointermove", pointermove);
      container.removeEventListener("pointerenter", pointerenter);
      container.removeEventListener("pointerleave", pointerleave);
      container.removeEventListener("pointerupoutside", pointerupoutside);
      container.removeEventListener("dragstart", dragstart);
      container.removeEventListener("drag", drag);
      container.removeEventListener("dragend", dragend);
      container.removeEventListener("dragenter", dragenter);
      container.removeEventListener("dragleave", dragleave);
      container.removeEventListener("dragover", dragover);
      container.removeEventListener("drop", drop);
    };
  };
}
Event.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/lib/builtinlib.js
function builtinlib() {
  return {
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "interaction.event": Event,
    "composition.mark": Mark,
    "composition.view": View,
    "shape.label.label": Label
  };
}

// node_modules/@antv/g2/esm/runtime/library.js
var __rest70 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function useLibrary(namespace, publicLibrary) {
  const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
  const create2 = (type) => {
    if (typeof type !== "string")
      return type;
    const key = `${namespace}.${type}`;
    return library3[key] || error(`Unknown Component: ${key}`);
  };
  const use = (options, context) => {
    const { type } = options, rest = __rest70(options, ["type"]);
    if (!type)
      error(`Plot type is required!`);
    const currentLibrary = create2(type);
    return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
  };
  return [use, create2];
}
function documentOf(library3) {
  const { canvas, group: group2 } = library3;
  return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group2 === null || group2 === void 0 ? void 0 : group2.ownerDocument) || error(`Cannot find library document`);
}

// node_modules/@antv/g2/esm/runtime/coordinate.js
var __rest71 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createCoordinate(layout, partialOptions, library3) {
  const [useCoordinate] = useLibrary("coordinate", library3);
  const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
  const { coordinates: partialTransform = [] } = partialOptions;
  const transform = inferCoordinate(partialTransform);
  const isCartesian3D = transform[0].type === "cartesian3D";
  const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform.flatMap(useCoordinate) });
  const coordinate = isCartesian3D ? (
    // @ts-ignore
    new Coordinate3D(options)
  ) : new Coordinate(options);
  return coordinate;
}
function coordinate2Transform(node, library3) {
  const { coordinate = {}, coordinates } = node, rest = __rest71(node, ["coordinate", "coordinates"]);
  if (coordinates)
    return node;
  const { type, transform = [] } = coordinate, options = __rest71(coordinate, ["type", "transform"]);
  if (!type)
    return Object.assign(Object.assign({}, rest), { coordinates: transform });
  const [, createCoordinate2] = useLibrary("coordinate", library3);
  const { transform: isTransform = false } = createCoordinate2(type).props || {};
  if (isTransform) {
    throw new Error(`Unknown coordinate: ${type}.`);
  }
  return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform] });
}
function coordOf(coordinates, type) {
  return coordinates.filter((d2) => d2.type === type);
}
function isPolar2(coordinates) {
  return coordOf(coordinates, "polar").length > 0;
}
function isHelix2(coordinates) {
  return coordOf(coordinates, "helix").length > 0;
}
function isTranspose2(coordinates) {
  return coordOf(coordinates, "transpose").length % 2 === 1;
}
function isParallel2(coordinates) {
  return coordOf(coordinates, "parallel").length > 0;
}
function isTheta2(coordinates) {
  return coordOf(coordinates, "theta").length > 0;
}
function isReflect(coordinates) {
  return coordOf(coordinates, "reflect").length > 0;
}
function isRadial2(coordinates) {
  return coordOf(coordinates, "radial").length > 0;
}
function isRadar2(coordinates) {
  return coordOf(coordinates, "radar").length > 0;
}
function isReflectY(coordinates) {
  return coordOf(coordinates, "reflectY").length > 0;
}
function inferCoordinate(coordinates) {
  if (coordinates.find((d2) => d2.type === "cartesian" || d2.type === "cartesian3D"))
    return coordinates;
  return [...coordinates, { type: "cartesian" }];
}

// node_modules/d3-scale-chromatic/src/index.js
var src_exports = {};
__export(src_exports, {
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateInferno: () => inferno,
  interpolateMagma: () => magma,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeObservable10: () => observable10_default,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend3(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color4() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color4, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a3) {
  if (a3 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a3);
}
function rgbConvert(o) {
  if (!(o instanceof Color4)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend3(Color4, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s2, l, a3) {
  if (a3 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a3);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color4)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min6 = Math.min(r, g, b), max6 = Math.max(r, g, b), h = NaN, s2 = max6 - min6, l = (max6 + min6) / 2;
  if (s2) {
    if (r === max6) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max6) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max6 + min6 : 2 - max6 - min6;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend3(Color4, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians2 = Math.PI / 180;
var degrees2 = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b) x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a3, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a3, b, opacity == null ? 1 : opacity);
}
function Lab(l, a3, b, opacity) {
  this.l = +l;
  this.a = +a3;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend3(Color4, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees2;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c4, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c4, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c4, l, opacity) {
  this.h = +h;
  this.c = +c4;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians2;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend3(Color4, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees2 - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend3(Color4, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians2, l = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a3 * (A * cosh2 + B * sinh2)),
      255 * (l + a3 * (C * cosh2 + D * sinh2)),
      255 * (l + a3 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values3) {
  var n = values3.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values3[i], v2 = values3[i + 1], v0 = i > 0 ? values3[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values3[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values3) {
  var n = values3.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values3[(i + n - 1) % n], v1 = values3[i % n], v2 = values3[(i + 1) % n], v3 = values3[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default4 = (x2) => () => x2;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d2) {
  return function(t) {
    return a3 + t * d2;
  };
}
function exponential(a3, b, y2) {
  return a3 = Math.pow(a3, y2), b = Math.pow(b, y2) - a3, y2 = 1 / y2, function(t) {
    return Math.pow(a3 + t * b, y2);
  };
}
function hue(a3, b) {
  var d2 = b - a3;
  return d2 ? linear(a3, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant_default4(isNaN(a3) ? b : a3);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a3, b) {
    return b - a3 ? exponential(a3, b, y2) : constant_default4(isNaN(a3) ? b : a3);
  };
}
function nogamma(a3, b) {
  var d2 = b - a3;
  return d2 ? linear(a3, d2) : constant_default4(isNaN(a3) ? b : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b) {
  return a3 = +a3, b = +b, function(t) {
    return a3 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees3 = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b, c4, d2, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b * b)) a3 /= scaleX, b /= scaleX;
  if (skewX = a3 * c4 + b * d2) c4 -= a3 * skewX, d2 -= b * skewX;
  if (scaleY = Math.sqrt(c4 * c4 + d2 * d2)) c4 /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a3 * d2 < b * c4) a3 = -a3, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a3) * degrees3,
    skewX: Math.atan(skewX) * degrees3,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m2.isIdentity ? identity3 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity3;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity3;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a3, b, s2, q) {
    if (a3 !== b) {
      if (a3 - b > 180) b += 360;
      else if (b - a3 > 180) a3 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a3, b, s2, q) {
    if (a3 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale3(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b) {
    var s2 = [], q = [];
    a3 = parse(a3), b = parse(b);
    translate2(a3.translateX, a3.translateY, b.translateX, b.translateY, s2, q);
    rotate2(a3.rotate, b.rotate, s2, q);
    skewX(a3.skewX, b.skewX, s2, q);
    scale3(a3.scaleX, a3.scaleY, b.scaleX, b.scaleY, s2, q);
    a3 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon23 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon23) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c4 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c4(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y2));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c2 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c2.h = 360 * t - 100;
  c2.s = 1.5 - 1.5 * ts;
  c2.l = 0.8 - 0.9 * ts;
  return c2 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c3 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x2;
  t = (0.5 - t) * Math.PI;
  c3.r = 255 * (x2 = Math.sin(t)) * x2;
  c3.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
  c3.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@antv/g2/esm/runtime/scale.js
function inferScale(name2, values3, options, coordinates, theme, library3) {
  const { guide = {} } = options;
  const type = inferScaleType(name2, values3, options);
  if (typeof type !== "string")
    return options;
  const expectedDomain = inferScaleDomain(type, name2, values3, options);
  const actualDomain = maybeRatio(type, expectedDomain, options);
  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values3, options, coordinates)), {
    domain: actualDomain,
    range: inferScaleRange(type, name2, values3, options, actualDomain, theme, library3),
    expectedDomain,
    guide,
    name: name2,
    type
  });
}
function applyScale(channels, scale3) {
  const scaledValue = {};
  for (const channel of channels) {
    const { values: values3, name: scaleName } = channel;
    const scaleInstance = scale3[scaleName];
    for (const value2 of values3) {
      const { name: name2, value: V } = value2;
      scaledValue[name2] = V.map((d2) => scaleInstance.map(d2));
    }
  }
  return scaledValue;
}
function groupTransform(markState, uidScale) {
  const channels = Array.from(markState.values()).flatMap((d2) => d2.channels);
  const scaleGroups = rollups(channels, (channels2) => channels2.map((d2) => uidScale.get(d2.scale.uid)), (d2) => d2.name).filter(([, scales]) => scales.some((d2) => typeof d2.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
  scales.every((d2) => d2.getTicks)).map((d2) => d2[1]);
  scaleGroups.forEach((group2) => {
    const groupTransform2 = group2.map((d2) => d2.getOptions().groupTransform)[0];
    groupTransform2(group2);
  });
}
function collectScales(states, options) {
  var _a;
  const { components = [] } = options;
  const NONE_STATIC_KEYS = [
    "scale",
    "encode",
    "axis",
    "legend",
    "data",
    "transform"
  ];
  const scales = Array.from(new Set(states.flatMap((d2) => d2.channels.map((d3) => d3.scale))));
  const nameScale = new Map(scales.map((scale3) => [scale3.name, scale3]));
  for (const component of components) {
    const channels = inferChannelsForComponent(component);
    for (const channel of channels) {
      const scale3 = nameScale.get(channel);
      const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};
      const { independent = false } = staticScale;
      if (scale3 && !independent) {
        const { guide } = scale3;
        const guide1 = typeof guide === "boolean" ? {} : guide;
        scale3.guide = deep_mix_default({}, guide1, component);
        Object.assign(scale3, staticScale);
      } else {
        const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
        scales.push(options1);
      }
    }
  }
  return scales;
}
function useRelation(relations) {
  if (!relations || !Array.isArray(relations))
    return [identity2, identity2];
  let map5;
  let invert2;
  const conditionalize = (scale3) => {
    var _a;
    map5 = scale3.map.bind(scale3);
    invert2 = (_a = scale3.invert) === null || _a === void 0 ? void 0 : _a.bind(scale3);
    const funcRelations = relations.filter(([v]) => typeof v === "function");
    const valueRelations = relations.filter(([v]) => typeof v !== "function");
    const valueOutput = new Map(valueRelations);
    scale3.map = (x2) => {
      for (const [verify, value2] of funcRelations) {
        if (verify(x2))
          return value2;
      }
      if (valueOutput.has(x2))
        return valueOutput.get(x2);
      return map5(x2);
    };
    if (!invert2)
      return scale3;
    const outputValue = new Map(valueRelations.map(([a3, b]) => [b, a3]));
    const outputFunc = new Map(funcRelations.map(([a3, b]) => [b, a3]));
    scale3.invert = (x2) => {
      if (outputFunc.has(x2))
        return x2;
      if (outputValue.has(x2))
        return outputValue.get(x2);
      return invert2(x2);
    };
    return scale3;
  };
  const deconditionalize = (scale3) => {
    if (map5 !== null)
      scale3.map = map5;
    if (invert2 !== null)
      scale3.invert = invert2;
    return scale3;
  };
  return [conditionalize, deconditionalize];
}
function assignScale(target, source) {
  const keys = Object.keys(target);
  for (const scale3 of Object.values(source)) {
    const { name: name2 } = scale3.getOptions();
    if (!(name2 in target))
      target[name2] = scale3;
    else {
      const I = keys.filter((d2) => d2.startsWith(name2)).map((d2) => +(d2.replace(name2, "") || 0));
      const index2 = max(I) + 1;
      const newKey = `${name2}${index2}`;
      target[newKey] = scale3;
      scale3.getOptions().key = newKey;
    }
  }
  return target;
}
function useRelationScale(options, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { relations } = options;
  const [conditionalize] = useRelation(relations);
  const scale3 = useScale(options);
  return conditionalize(scale3);
}
function syncFacetsScales(states) {
  const scales = states.flatMap((d2) => Array.from(d2.values())).flatMap((d2) => d2.channels.map((d3) => d3.scale));
  syncFacetsScaleByChannel(scales, "x");
  syncFacetsScaleByChannel(scales, "y");
}
function inferChannelsForComponent(component) {
  const { channels = [], type, scale: scale3 = {} } = component;
  const L = ["shape", "color", "opacity", "size"];
  if (channels.length !== 0)
    return channels;
  if (type === "axisX")
    return ["x"];
  if (type === "axisY")
    return ["y"];
  if (type === "legends")
    return Object.keys(scale3).filter((d2) => L.includes(d2));
  return [];
}
function syncFacetsScaleByChannel(scales, channel) {
  const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
  const D2 = S.flatMap((d2) => d2.domain);
  const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
  if (syncedD === null)
    return;
  for (const scale3 of S) {
    scale3.domain = syncedD;
  }
}
function maybeRatio(type, domain, options) {
  const { ratio } = options;
  if (ratio === void 0 || ratio === null)
    return domain;
  if (isQuantitativeScale({ type })) {
    return clampQuantitativeScale(domain, ratio, type);
  }
  if (isDiscreteScale({ type }))
    return clampDiscreteScale(domain, ratio);
  return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
  const D2 = domain.map(Number);
  const scale3 = new Linear({
    domain: D2,
    range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
  });
  if (type === "time")
    return domain.map((d2) => new Date(scale3.map(d2)));
  return domain.map((d2) => scale3.map(d2));
}
function clampDiscreteScale(domain, ratio) {
  const index2 = Math.round(domain.length * ratio);
  return domain.slice(0, index2);
}
function isQuantitativeScale(scale3) {
  const { type } = scale3;
  if (typeof type !== "string")
    return false;
  const names = ["linear", "log", "pow", "time"];
  return names.includes(type);
}
function isDiscreteScale(scale3) {
  const { type } = scale3;
  if (typeof type !== "string")
    return false;
  const names = ["band", "point", "ordinal"];
  return names.includes(type);
}
function inferScaleType(name2, values3, options) {
  const { type, domain, range: range3, quantitative, ordinal } = options;
  if (type !== void 0)
    return type;
  if (isObject3(values3))
    return "identity";
  if (typeof range3 === "string")
    return "linear";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(name2, ordinal);
  if (domain !== void 0) {
    if (isOrdinal([domain]))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values3))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  if (isOrdinal(values3))
    return asOrdinalType(name2, ordinal);
  if (isTemporal(values3))
    return "time";
  return asQuantitativeType(name2, range3, quantitative);
}
function inferScaleDomain(type, name2, values3, options) {
  const { domain } = options;
  if (domain !== void 0)
    return domain;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
    case "quantize":
    case "threshold":
      return maybeMinMax(inferDomainQ(values3, options), options);
    case "band":
    case "ordinal":
    case "point":
      return inferDomainC(values3);
    case "quantile":
      return inferDomainO(values3);
    case "sequential":
      return maybeMinMax(inferDomainS(values3), options);
    default:
      return [];
  }
}
function inferScaleRange(type, name2, values3, options, domain, theme, library3) {
  const { range: range3 } = options;
  if (typeof range3 === "string")
    return gradientColors(range3);
  if (range3 !== void 0)
    return range3;
  const { rangeMin, rangeMax } = options;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt": {
      const colors = categoricalColors(values3, options, domain, theme, library3);
      const [r0, r1] = inferRangeQ(name2, colors);
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
    }
    case "band":
    case "point": {
      const min6 = name2 === "size" ? 5 : 0;
      const max6 = name2 === "size" ? 10 : 1;
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min6, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max6];
    }
    case "ordinal": {
      return categoricalColors(values3, options, domain, theme, library3);
    }
    case "sequential":
      return void 0;
    case "constant":
      return [values3[0][0]];
    default:
      return [];
  }
}
function inferScaleOptions(type, name2, values3, options, coordinates) {
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
      return inferOptionsQ(coordinates, options);
    case "band":
    case "point":
      return inferOptionsC(type, name2, coordinates, options);
    case "sequential":
      return inferOptionsS(options);
    default:
      return options;
  }
}
function categoricalColors(values3, options, domain, theme, library3) {
  const [usePalette] = useLibrary("palette", library3);
  const { category10: c10, category20: c20 } = theme;
  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
  const { palette = defaultPalette, offset } = options;
  if (Array.isArray(palette))
    return palette;
  try {
    return usePalette({ type: palette });
  } catch (e) {
    const colors = interpolatedColors(palette, domain, offset);
    if (colors)
      return colors;
    throw new Error(`Unknown Component: ${palette} `);
  }
}
function gradientColors(range3) {
  return range3.split("-");
}
function interpolatedColors(palette, domain, offset = (d2) => d2) {
  if (!palette)
    return null;
  const fullName = upper_first_default(palette);
  const scheme28 = src_exports[`scheme${fullName}`];
  const interpolator = src_exports[`interpolate${fullName}`];
  if (!scheme28 && !interpolator)
    return null;
  if (scheme28) {
    if (!scheme28.some(Array.isArray))
      return scheme28;
    const schemeColors = scheme28[domain.length];
    if (schemeColors)
      return schemeColors;
  }
  return domain.map((_, i) => interpolator(offset(i / domain.length)));
}
function inferOptionsS(options) {
  const { palette = "ylGnBu", offset } = options;
  const name2 = upper_first_default(palette);
  const interpolator = src_exports[`interpolate${name2}`];
  if (!interpolator)
    throw new Error(`Unknown palette: ${name2}`);
  return {
    interpolator: offset ? (x2) => interpolator(offset(x2)) : interpolator
  };
}
function inferOptionsQ(coordinates, options) {
  const { interpolate: interpolate2 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
  return Object.assign(Object.assign({}, options), { interpolate: interpolate2, nice: nice2, tickCount });
}
function inferOptionsC(type, name2, coordinates, options) {
  if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
    return Object.assign(Object.assign({}, options), { unknown: NaN });
  }
  const padding = inferPadding(type, name2, coordinates);
  const { paddingInner = padding, paddingOuter = padding } = options;
  return Object.assign(Object.assign({}, options), {
    paddingInner,
    paddingOuter,
    padding,
    unknown: NaN
  });
}
function inferPadding(type, name2, coordinates) {
  if (name2 === "enterDelay" || name2 === "enterDuration")
    return 0;
  if (name2 === "size")
    return 0;
  if (type === "band")
    return isTheta2(coordinates) ? 0 : 0.1;
  if (type === "point")
    return 0.5;
  return 0;
}
function asOrdinalType(name2, defaults4) {
  if (defaults4)
    return defaults4;
  return isQuantitative(name2) ? "point" : "ordinal";
}
function asQuantitativeType(name2, range3, defaults4) {
  if (defaults4)
    return defaults4;
  if (name2 !== "color")
    return "linear";
  return range3 ? "linear" : "sequential";
}
function maybeMinMax(domain, options) {
  if (domain.length === 0)
    return domain;
  const { domainMin, domainMax } = options;
  const [d0, d1] = domain;
  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
}
function inferDomainQ(values3, options) {
  const { zero: zero2 = false } = options;
  let min6 = Infinity;
  let max6 = -Infinity;
  for (const value2 of values3) {
    for (const d2 of value2) {
      if (defined(d2)) {
        min6 = Math.min(min6, +d2);
        max6 = Math.max(max6, +d2);
      }
    }
  }
  if (min6 === Infinity)
    return [];
  return zero2 ? [Math.min(0, min6), max6] : [min6, max6];
}
function inferDomainC(values3) {
  return Array.from(new Set(values3.flat()));
}
function inferDomainO(values3) {
  return values3.flat().sort();
}
function inferDomainS(values3) {
  let min6 = Infinity;
  let max6 = -Infinity;
  for (const value2 of values3) {
    for (const d2 of value2) {
      if (defined(d2)) {
        min6 = Math.min(min6, +d2);
        max6 = Math.max(max6, +d2);
      }
    }
  }
  if (min6 === Infinity)
    return [];
  return [min6 < 0 ? -max6 : min6, max6];
}
function inferRangeQ(name2, palette) {
  if (name2 === "enterDelay")
    return [0, 1e3];
  if (name2 == "enterDuration")
    return [300, 1e3];
  if (name2.startsWith("y") || name2.startsWith("position"))
    return [1, 0];
  if (name2 === "color")
    return [firstOf(palette), lastOf(palette)];
  if (name2 === "opacity")
    return [0, 1];
  if (name2 === "size")
    return [1, 10];
  return [0, 1];
}
function isOrdinal(values3) {
  return some2(values3, (d2) => {
    const type = typeof d2;
    return type === "string" || type === "boolean";
  });
}
function isTemporal(values3) {
  return some2(values3, (d2) => d2 instanceof Date);
}
function isObject3(values3) {
  return some2(values3, isStrictObject);
}
function some2(values3, callback) {
  for (const V of values3) {
    if (V.some(callback))
      return true;
  }
  return false;
}
function isQuantitative(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
}
function isPosition(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
}
function isValidScale(scale3) {
  if (!scale3 || !scale3.type)
    return false;
  if (typeof scale3.type === "function")
    return true;
  const { type, domain, range: range3, interpolator } = scale3;
  const isValidDomain = domain && domain.length > 0;
  const isValidRange = range3 && range3.length > 0;
  if ([
    "linear",
    "sqrt",
    "log",
    "time",
    "pow",
    "threshold",
    "quantize",
    "quantile",
    "ordinal",
    "band",
    "point"
  ].includes(type) && isValidDomain && isValidRange) {
    return true;
  }
  if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
    return true;
  }
  if (["constant", "identity"].includes(type) && isValidRange)
    return true;
  return false;
}

// node_modules/@antv/g2/esm/runtime/types/scale.js
var ContinuousScale = {
  linear: "linear",
  identity: "identity",
  log: "log",
  pow: "pow",
  sqrt: "sqrt",
  sequential: "sequential"
};
var DistributionScale = {
  threshold: "threshold",
  quantize: "quantize",
  quantile: "quantile"
};
var DiscreteScale = {
  ordinal: "ordinal",
  band: "band",
  point: "point"
};
var ConstantScale = {
  constant: "constant"
};

// node_modules/@antv/g2/esm/runtime/component.js
var __rest72 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferComponent(scales, partialOptions, library3) {
  const { coordinates = [], title } = partialOptions;
  const [, createGuideComponent] = useLibrary("component", library3);
  const displayedScales = scales.filter(({ guide }) => {
    if (guide === null)
      return false;
    return true;
  });
  const components = [];
  const sliders = inferScrollableComponents(partialOptions, scales, library3);
  components.push(...sliders);
  if (title) {
    const { props } = createGuideComponent("title");
    const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
    const titleOptions = typeof title === "string" ? { title } : title;
    components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
  }
  const inferredComponents = inferComponentsType(displayedScales, coordinates);
  inferredComponents.forEach(([type, relativeScales]) => {
    const { props } = createGuideComponent(type);
    const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
    const scale3 = deep_mix_default({}, ...relativeScales);
    const { guide: guideOptions, field: field3 } = scale3;
    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
    for (const partialGuide of guides) {
      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
      if (!position && !orientation)
        continue;
      const isVertical2 = position === "left" || position === "right";
      const defaultPadding = isVertical2 ? DP[1] : DP[0];
      const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
      const { size: size3, order = defaultOrder, length = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
      components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
        defaultSize,
        length,
        position,
        plane: defaultPlane,
        orientation,
        padding,
        order,
        crossPadding,
        size: size3,
        type,
        scales: relativeScales
      }));
    }
  });
  return components;
}
function renderComponent(component, coordinate, theme, library3, markState) {
  const [useGuideComponent] = useLibrary("component", library3);
  const { scaleInstances: scales, scale: scale3, bbox } = component, options = __rest72(component, ["scaleInstances", "scale", "bbox"]);
  const value2 = { bbox, library: library3 };
  const render2 = useGuideComponent(options);
  return render2({
    coordinate,
    library: library3,
    markState,
    scales,
    theme,
    value: value2,
    scale: scale3
  });
}
function normalizeComponents(components) {
  return components.map((d2) => {
    const component = deep_mix_default(d2, d2.style);
    delete component.style;
    return component;
  });
}
function groupComponents(components, crossSize) {
  const P = ["left", "right", "bottom", "top"];
  const key = ({ type, position, group: group2 }) => {
    if (!P.includes(position))
      return Symbol("independent");
    if (group2 === void 0) {
      if (type.startsWith("legend"))
        return `legend-${position}`;
      return Symbol("independent");
    }
    if (group2 === "independent")
      return Symbol("independent");
    return group2;
  };
  const grouped = groups(components, key);
  return grouped.flatMap(([, components2]) => {
    if (components2.length === 1)
      return components2[0];
    if (crossSize !== void 0) {
      const DL = components2.filter((d2) => d2.length !== void 0).map((d2) => d2.length);
      const totalLength = sum(DL);
      if (totalLength > crossSize) {
        components2.forEach((d2) => d2.group = Symbol("independent"));
        return components2;
      }
      const emptyLength = crossSize - totalLength;
      const emptyCount = components2.length - DL.length;
      const length = emptyLength / emptyCount;
      components2.forEach((d2) => {
        if (d2.length !== void 0)
          return;
        d2.length = length;
      });
    }
    const size3 = max(components2, (d2) => d2.size);
    const order = max(components2, (d2) => d2.order);
    const crossPadding = max(components2, (d2) => d2.crossPadding);
    const position = components2[0].position;
    return {
      type: "group",
      size: size3,
      order,
      position,
      children: components2,
      crossPadding
    };
  });
}
function inferLegendComponentType(scales, coordinates) {
  const channels = ["shape", "size", "color", "opacity"];
  const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
  const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
  const constants = accepts.filter(({ type }) => type === "constant");
  const nonConstants = accepts.filter(({ type }) => type !== "constant");
  const groupKey = (d2) => d2.field ? d2.field : Symbol("independent");
  const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale3) => scale3.type !== "constant"));
  const scalesByField = new Map(fieldScales);
  if (scalesByField.size === 0)
    return [];
  const sort2 = (arr) => arr.sort(([a3], [b]) => a3.localeCompare(b));
  const components = Array.from(scalesByField).map(([, scs]) => {
    const combinations = combine(scs).sort((a3, b) => b.length - a3.length);
    const options = combinations.map((combination) => ({
      combination,
      option: combination.map((scale3) => [scale3.name, getScaleType(scale3)])
    }));
    for (const { option, combination } of options) {
      if (option.every((d2) => d2[1] === "constant"))
        continue;
      if (option.every((d2) => d2[1] === "discrete" || d2[1] === "constant")) {
        return ["legendCategory", combination];
      }
    }
    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
      for (const { option, combination } of options) {
        if (accords.some((accord) => is_equal_default(sort2(accord), sort2(option)))) {
          return [componentType, combination];
        }
      }
    }
    return null;
  }).filter(defined);
  return components;
}
function getScaleType(scale3) {
  const { type } = scale3;
  if (typeof type !== "string")
    return null;
  if (type in ContinuousScale)
    return "continuous";
  if (type in DiscreteScale)
    return "discrete";
  if (type in DistributionScale)
    return "distribution";
  if (type in ConstantScale)
    return "constant";
  return null;
}
function inferAxisComponentType(scales, coordinates) {
  return scales.map((scale3) => {
    const { name: name2 } = scale3;
    if (isHelix2(coordinates) || isTheta2(coordinates))
      return null;
    if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
      return null;
    if (name2.startsWith("x")) {
      if (isPolar2(coordinates))
        return ["axisArc", [scale3]];
      if (isRadial2(coordinates))
        return ["axisLinear", [scale3]];
      return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale3]];
    }
    if (name2.startsWith("y")) {
      if (isPolar2(coordinates))
        return ["axisLinear", [scale3]];
      if (isRadial2(coordinates))
        return ["axisArc", [scale3]];
      return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale3]];
    }
    if (name2.startsWith("z")) {
      return ["axisZ", [scale3]];
    }
    if (name2.startsWith("position")) {
      if (isRadar2(coordinates))
        return ["axisRadar", [scale3]];
      if (!isPolar2(coordinates))
        return ["axisY", [scale3]];
    }
    return null;
  }).filter(defined);
}
function inferComponentsType(scales, coordinates) {
  const availableScales = scales.filter((scale3) => isValidScale(scale3));
  return [
    ...inferLegendComponentType(availableScales, coordinates),
    ...inferAxisComponentType(availableScales, coordinates)
  ];
}
function angleOf3(coordinates) {
  const polar2 = coordOf(coordinates, "polar");
  if (polar2.length) {
    const lastPolar = polar2[polar2.length - 1];
    const { startAngle, endAngle } = getPolarOptions(lastPolar);
    return [startAngle, endAngle];
  }
  const radial = coordOf(coordinates, "radial");
  if (radial.length) {
    const lastRadial = radial[radial.length - 1];
    const { startAngle, endAngle } = getRadialOptions(lastRadial);
    return [startAngle, endAngle];
  }
  return [-Math.PI / 2, Math.PI / 2 * 3];
}
function matchPosition(name2) {
  const match = /position(\d*)/g.exec(name2);
  if (!match)
    return null;
  return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
  const { name: name2 } = relativeScales[0];
  if (type === "axisRadar") {
    const positions = scales.filter((scale3) => scale3.name.startsWith("position"));
    const index2 = matchPosition(name2);
    if (name2 === positions.slice(-1)[0].name || index2 === null)
      return [null, null];
    const [startAngle, endAngle] = angleOf3(coordinates);
    const angle2 = (endAngle - startAngle) / (positions.length - 1) * index2 + startAngle;
    return ["center", angle2];
  }
  if (type === "axisY" && isParallel2(coordinates)) {
    return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
  }
  if (type === "axisLinear") {
    const [startAngle] = angleOf3(coordinates);
    return ["center", startAngle];
  }
  if (type === "axisArc") {
    if (ordinalPosition[0] === "inner")
      return ["inner", null];
    return ["outer", null];
  }
  if (isPolar2(coordinates))
    return ["center", null];
  if (isRadial2(coordinates))
    return ["center", null];
  if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
    return ["top", null];
  }
  return ordinalPosition;
}
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
  const [startAngle] = angleOf3(coordinates);
  const ordinalPositionAndOrientation = [
    guide.position || defaultPosition,
    startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
  ];
  if (typeof type === "string" && type.startsWith("axis")) {
    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
  }
  if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
    if (guide.position === "center")
      return ["center", "vertical"];
  }
  return ordinalPositionAndOrientation;
}
function inferScrollableType(name2, type, coordinates = []) {
  if (name2 === "x")
    return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
  if (name2 === "y")
    return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
  return null;
}
function inferScrollableComponents(partialOptions, scales, library3) {
  const [, createGuideComponent] = useLibrary("component", library3);
  const { coordinates } = partialOptions;
  function normalized(type, channelName, scale3, options) {
    const componentType = inferScrollableType(channelName, type, coordinates);
    if (!options || !componentType)
      return;
    const { props } = createGuideComponent(componentType);
    const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
    return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale3] });
  }
  return scales.filter((d2) => d2.slider || d2.scrollbar).flatMap((scale3) => {
    const { slider, scrollbar, name: channelName } = scale3;
    return [
      normalized("slider", channelName, scale3, slider),
      normalized("scrollbar", channelName, scale3, scrollbar)
    ];
  }).filter((d2) => !!d2);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
  const { type } = component;
  const paddingAreas = ["left", "right", "bottom", "top"];
  if (!paddingAreas.includes(position))
    return;
  if (typeof type !== "string")
    return;
  const t = type;
  const createCompute = () => {
    if (t.startsWith("axis"))
      return computeAxisSize;
    if (t.startsWith("group"))
      return computeGroupSize;
    if (t.startsWith("legendContinuous"))
      return computeContinuousLegendSize;
    if (t === "legendCategory")
      return computeCategoryLegendSize;
    if (t.startsWith("slider"))
      return computeSliderSize;
    if (t === "title")
      return computeTitleSize;
    if (t.startsWith("scrollbar"))
      return computeScrollbarSize;
    return () => {
    };
  };
  return createCompute()(component, crossSize, crossPadding, position, theme, library3);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
  const { children } = component;
  const maxCrossPadding = max(children, (d2) => d2.crossPadding);
  children.forEach((d2) => d2.crossPadding = maxCrossPadding);
  children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
  const maxSize = max(children, (d2) => d2.size);
  component.size = maxSize;
  children.forEach((d2) => d2.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
  const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
  component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
  const _a = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a, style = __rest72(_a, ["title", "subtitle", "spacing"]);
  if (title) {
    const titleStyle = subObject(style, "title");
    const titleBBox = computeLabelSize(title, titleStyle);
    component.size = titleBBox.height;
  }
  if (subtitle) {
    const subtitleStyle = subObject(style, "subtitle");
    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
    component.size += spacing + subtitleBBox.height;
  }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { slider } = theme;
    return deep_mix_default({}, slider, component);
  };
  const { trackSize, handleIconSize } = styleOf2();
  const size3 = Math.max(trackSize, handleIconSize * 2.4);
  component.size = size3;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
  var _a;
  component.transform = component.transform || [{ type: "hide" }];
  const isVertical2 = position === "left" || position === "right";
  const style = styleOf(component, position, theme);
  const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest72(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
  const scale3 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale3);
  const paddingTick = tickLength + labelSpacing;
  if (labelBBoxes && labelBBoxes.length) {
    const maxLabelWidth = max(labelBBoxes, (d2) => d2.width);
    const maxLabelHeight = max(labelBBoxes, (d2) => d2.height);
    if (isVertical2) {
      component.size = maxLabelWidth + paddingTick;
    } else {
      const { tickFilter, labelTransform } = component;
      if (overflowX(scale3, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
        component.labelTransform = "rotate(90)";
        component.size = maxLabelWidth + paddingTick;
      } else {
        component.labelTransform = (_a = component.labelTransform) !== null && _a !== void 0 ? _a : "rotate(0)";
        component.size = maxLabelHeight + paddingTick;
      }
    }
  } else {
    component.size = tickLength;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size += titleSpacing + titleBBox.width;
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendContinuous } = theme;
    return deep_mix_default({}, legendContinuous, component);
  };
  const _a = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a, rest = __rest72(_a, ["labelSpacing", "titleSpacing"]);
  const isVertical2 = position === "left" || position === "right";
  const ribbonStyles = subObject(rest, "ribbon");
  const { size: ribbonSize } = ribbonStyles;
  const handleIconStyles = subObject(rest, "handleIcon");
  const { size: handleIconSize } = handleIconStyles;
  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
  component.size = mainSize;
  const scale3 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale3);
  if (labelBBoxes) {
    const key = isVertical2 ? "width" : "height";
    const size3 = max(labelBBoxes, (d2) => d2[key]);
    component.size += size3 + labelSpacing;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendCategory } = theme;
    const { title } = component;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
  };
  const _a = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a, rest = __rest72(_a, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
  const { cols, length } = component;
  const getRows = (rows) => Math.min(rows, maxRows);
  const getCols = (cols2) => Math.min(cols2, maxCols);
  const isVertical2 = position === "left" || position === "right";
  const crossSize = length === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length;
  const titleBBox = computeTitleBBox(rest);
  const scale3 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale3, "itemLabel");
  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
  const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;
  const computeVerticalSize = () => {
    let maxSize = -Infinity;
    let pos = 0;
    let cols2 = 1;
    let rows = 0;
    let maxRows2 = -Infinity;
    let maxPos = -Infinity;
    const titleHeight = titleBBox ? titleBBox.height : 0;
    const maxHeight = crossSize - titleHeight;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      maxSize = Math.max(maxSize, w);
      if (pos + height > maxHeight) {
        cols2++;
        maxRows2 = Math.max(maxRows2, rows);
        maxPos = Math.max(maxPos, pos);
        rows = 1;
        pos = height;
      } else {
        pos += height;
        rows++;
      }
    }
    if (cols2 <= 1) {
      maxRows2 = rows;
      maxPos = pos;
    }
    component.size = maxSize * getCols(cols2);
    component.length = maxPos + titleHeight;
    deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
  };
  const computeHorizontalGrid = () => {
    const rows = Math.ceil(labelBBoxes.length / cols);
    const maxWidth = max(labelBBoxes, (d2) => widthOf(d2.width)) * cols;
    component.size = height * getRows(rows) - rowPadding;
    component.length = Math.min(maxWidth, crossSize);
  };
  const computeHorizontalFlex = () => {
    let rows = 1;
    let pos = 0;
    let maxPos = -Infinity;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      if (pos + w > crossSize) {
        maxPos = Math.max(maxPos, pos);
        pos = w;
        rows++;
      } else {
        pos += w;
      }
    }
    if (rows === 1)
      maxPos = pos;
    component.size = height * getRows(rows) - rowPadding;
    component.length = maxPos;
  };
  if (isVertical2)
    computeVerticalSize();
  else if (typeof cols === "number")
    computeHorizontalGrid();
  else
    computeHorizontalFlex();
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function createScale(component, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { scales, tickCount, tickMethod } = component;
  const scaleOptions = scales.find((d2) => d2.type !== "constant" && d2.type !== "identity");
  if (tickCount !== void 0)
    scaleOptions.tickCount = tickCount;
  if (tickMethod !== void 0)
    scaleOptions.tickMethod = tickMethod;
  return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale3, key = "label") {
  const { labelFormatter, tickFilter, label = true } = component, style = __rest72(component, ["labelFormatter", "tickFilter", "label"]);
  if (!label)
    return null;
  const labels = labelsOf(scale3, labelFormatter, tickFilter);
  const labelStyle = subObject(style, key);
  const labelStyles = labels.map((d2, i) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
    key2,
    typeof value2 === "function" ? value2(d2, i) : value2
  ])));
  const labelBBoxes = labels.map((d2, i) => {
    const normalizeStyle = labelStyles[i];
    return computeLabelSize(d2, normalizeStyle);
  });
  const hasTransform = labelStyles.some((d2) => d2.transform);
  if (!hasTransform) {
    const I = labels.map((_, i) => i);
    component.indexBBox = new Map(I.map((i) => [i, [labels[i], labelBBoxes[i]]]));
  }
  return labelBBoxes;
}
function computeTitleBBox(component) {
  const isFalsy = (x2) => x2 === false || x2 === null;
  const { title } = component, style = __rest72(component, ["title"]);
  if (isFalsy(title) || title === void 0)
    return null;
  const titleStyle = subObject(style, "title");
  const { direction, transform } = titleStyle;
  const titleText = Array.isArray(title) ? title.join(",") : title;
  if (typeof titleText !== "string")
    return null;
  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform || (direction === "vertical" ? "rotate(-90)" : "") }));
  return titleBBox;
}
function styleOf(axis, position, theme) {
  const { title } = axis;
  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
  const {
    axis: baseStyle,
    // @ts-ignore
    [`axis${capitalizeFirst(position)}`]: positionStyle
  } = theme;
  return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
}
function ticksOf2(scale3, tickFilter) {
  const ticks2 = scale3.getTicks ? scale3.getTicks() : scale3.getOptions().domain;
  if (!tickFilter)
    return ticks2;
  return ticks2.filter(tickFilter);
}
function labelsOf(scale3, labelFormatter, tickFilter) {
  const T = ticksOf2(scale3, tickFilter);
  const ticks2 = T.map((d2) => typeof d2 === "number" ? prettyNumber(d2) : d2);
  const formatter = labelFormatter ? typeof labelFormatter === "string" ? format(labelFormatter) : labelFormatter : scale3.getFormatter ? scale3.getFormatter() : (d2) => `${d2}`;
  return ticks2.map(formatter);
}
function offsetOf(scale3, d2) {
  if (!scale3.getBandWidth)
    return 0;
  const offset = scale3.getBandWidth(d2) / 2;
  return offset;
}
function overflowX(scale3, labelBBoxes, crossSize, crossPadding, tickFilter) {
  const totalSize = sum(labelBBoxes, (d2) => d2.width);
  if (totalSize > crossSize)
    return true;
  const scaleX = scale3.clone();
  scaleX.update({ range: [0, crossSize] });
  const ticks2 = ticksOf2(scale3, tickFilter);
  const X = ticks2.map((d2) => scaleX.map(d2) + offsetOf(scaleX, d2));
  const I = ticks2.map((_, i) => i);
  const startX = -crossPadding[0];
  const endX = crossSize + crossPadding[1];
  const extent2 = (x2, bbox) => {
    const { width } = bbox;
    return [x2 - width / 2, x2 + width / 2];
  };
  for (let i = 0; i < I.length; i++) {
    const x2 = X[i];
    const [x05, x12] = extent2(x2, labelBBoxes[i]);
    if (x05 < startX || x12 > endX)
      return true;
    const y2 = X[i + 1];
    if (y2) {
      const [y05] = extent2(y2, labelBBoxes[i + 1]);
      if (x12 > y05)
        return true;
    }
  }
  return false;
}
function computeLabelSize(d2, style) {
  const shape23 = normalizeLabel(d2);
  const { filter: filter2 } = style, rest = __rest72(style, ["filter"]);
  shape23.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
  const bbox = shape23.getBBox();
  return bbox;
}
function normalizeLabel(d2) {
  if (d2 instanceof DisplayObject)
    return d2;
  return new Text({ style: { text: `${d2}` } });
}

// node_modules/@antv/g2/esm/runtime/layout.js
function processAxisZ(components) {
  const axisX = components.find(({ type }) => type === "axisX");
  const axisY = components.find(({ type }) => type === "axisY");
  const axisZ = components.find(({ type }) => type === "axisZ");
  if (axisX && axisY && axisZ) {
    axisX.plane = "xy";
    axisY.plane = "xy";
    axisZ.plane = "yz";
    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
    axisZ.eulerAngles = [0, -90, 0];
    axisZ.bbox.x = axisX.bbox.x;
    axisZ.bbox.y = axisX.bbox.y;
    components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
    components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
    components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
  }
}
function computeLayout(components, options, theme, library3) {
  var _a, _b;
  const { width, height, depth, x: x2 = 0, y: y2 = 0, z = 0, inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
  const MIN_CONTENT_RATIO = 1 / 4;
  const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
    const { marks } = options;
    if (marks.length === 0)
      return [pl02, pr02];
    const contentSize = viewWidth2 - pl02 - pr02;
    const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
    if (diff > 0)
      return [pl02, pr02];
    const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
    return [
      paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
      paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
    ];
  };
  const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
  const rpt = roughPadding(paddingTop);
  const rpb = roughPadding(paddingBottom);
  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
  const viewWidth = width - marginLeft - marginRight;
  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
  const iw = viewWidth - pl - pr;
  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
  const viewHeight = height - marginBottom - marginTop;
  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
  const ih = viewHeight - pb - pt;
  return {
    width,
    height,
    depth,
    insetLeft,
    insetTop,
    insetBottom,
    insetRight,
    innerWidth: iw,
    innerHeight: ih,
    paddingLeft: pl,
    paddingRight: pr,
    paddingTop: pt,
    paddingBottom: pb,
    marginLeft,
    marginBottom,
    marginTop,
    marginRight,
    x: x2,
    y: y2,
    z
  };
}
function computeRoughPlotSize(options) {
  const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
  const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
  return { width: finalWidth, height: finalHeight };
}
function computeInset(components, options, theme, library3) {
  const { coordinates } = options;
  if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
    return options;
  }
  const axes = components.filter((d2) => typeof d2.type === "string" && d2.type.startsWith("axis"));
  if (axes.length === 0)
    return options;
  const styles = axes.map((component) => {
    const key = component.type === "axisArc" ? "arc" : "linear";
    return styleOf(component, key, theme);
  });
  const maxLabelSpacing = max(styles, (d2) => {
    var _a;
    return (_a = d2.labelSpacing) !== null && _a !== void 0 ? _a : 0;
  });
  const labelBBoxes = axes.flatMap((component, i) => {
    const style = styles[i];
    const scale3 = createScale(component, library3);
    const labels = computeLabelsBBox(style, scale3);
    return labels;
  }).filter(defined);
  const size3 = max(labelBBoxes, (d2) => d2.height) + maxLabelSpacing;
  const titleBBoxes = axes.flatMap((_, i) => {
    const style = styles[i];
    return computeTitleBBox(style);
  }).filter((d2) => d2 !== null);
  const titleSize = titleBBoxes.length === 0 ? 0 : max(titleBBoxes, (d2) => d2.height);
  const { inset = size3, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
  return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
}
function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
  const positionComponents = group(components, (d2) => d2.position);
  const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
  const layout = {
    paddingBottom,
    paddingLeft,
    paddingTop,
    paddingRight
  };
  for (const position of positions) {
    const key = `padding${capitalizeFirst(camelCase(position))}`;
    const components2 = positionComponents.get(position) || [];
    const value2 = layout[key];
    const defaultSizeOf = (d2) => {
      if (d2.size === void 0)
        d2.size = d2.defaultSize;
    };
    const sizeOf3 = (d2) => {
      if (d2.type === "group") {
        d2.children.forEach(defaultSizeOf);
        d2.size = max(d2.children, (d3) => d3.size);
      } else {
        d2.size = d2.defaultSize;
      }
    };
    const autoSizeOf = (d2) => {
      if (d2.size)
        return;
      if (value2 !== "auto")
        sizeOf3(d2);
      else {
        computeComponentSize(d2, crossSize, crossPadding, position, theme, library3);
        defaultSizeOf(d2);
      }
    };
    const maybeHide = (d2) => {
      if (!d2.type.startsWith("axis"))
        return;
      if (d2.labelAutoHide === void 0)
        d2.labelAutoHide = true;
    };
    const isHorizontal2 = position === "bottom" || position === "top";
    const minOrder = min(components2, (d2) => d2.order);
    const axes = components2.filter((d2) => d2.type.startsWith("axis") && d2.order == minOrder);
    if (axes.length)
      axes[0].crossPadding = 0;
    if (typeof value2 === "number") {
      components2.forEach(defaultSizeOf);
      components2.forEach(maybeHide);
    } else {
      if (components2.length === 0) {
        layout[key] = 0;
      } else {
        const size3 = isHorizontal2 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
        const grouped = groupComponents(components2, size3);
        grouped.forEach(autoSizeOf);
        const totalSize = grouped.reduce((sum4, { size: size4, crossPadding: crossPadding2 = 12 }) => sum4 + size4 + crossPadding2, 0);
        layout[key] = totalSize;
      }
    }
  }
  return layout;
}
function placeComponents(components, coordinate, layout) {
  const positionComponents = group(components, (d2) => `${d2.plane || "xy"}-${d2.position}`);
  const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
  const planes = {
    xy: createSection({
      width,
      height,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginLeft,
      marginTop,
      marginBottom,
      marginRight,
      innerHeight,
      innerWidth,
      insetBottom,
      insetLeft,
      insetRight,
      insetTop
    }),
    yz: createSection({
      width: depth,
      height,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: depth,
      innerHeight: height,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    }),
    xz: createSection({
      width,
      height: depth,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: width,
      innerHeight: depth,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    })
  };
  for (const [key, components2] of positionComponents.entries()) {
    const [plane, position] = key.split("-");
    const area2 = planes[plane][position];
    const [nonEntityComponents, entityComponents] = divide(components2, (component) => {
      if (typeof component.type !== "string")
        return false;
      if (position === "center")
        return true;
      if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
        return true;
      }
      return false;
    });
    if (nonEntityComponents.length) {
      placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
    }
    if (entityComponents.length) {
      placePaddingArea(components2, coordinate, area2);
    }
  }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
  const pl = paddingLeft + marginLeft;
  const pt = paddingTop + marginTop;
  const pr = paddingRight + marginRight;
  const pb = paddingBottom + marginBottom;
  const plotWidth = width - marginLeft - marginRight;
  const centerSection = [
    pl + insetLeft,
    pt + insetTop,
    innerWidth - insetLeft - insetRight,
    innerHeight - insetTop - insetBottom,
    "center",
    null,
    null
  ];
  const xySection = {
    top: [
      pl,
      0,
      innerWidth,
      pt,
      "vertical",
      true,
      ascending,
      marginLeft,
      plotWidth
    ],
    right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
    bottom: [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending,
      marginLeft,
      plotWidth
    ],
    left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
    "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "bottom-left": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    "bottom-right": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    center: centerSection,
    inner: centerSection,
    outer: centerSection
  };
  return xySection;
}
function placeNonEntityComponents(components, coordinate, area2, position) {
  const [axisComponents, nonAxisComponents] = divide(components, (component) => {
    if (typeof component.type === "string" && component.type.startsWith("axis")) {
      return true;
    }
    return false;
  });
  placeNonEntityAxis(axisComponents, coordinate, area2, position);
  placeCenter(nonAxisComponents, coordinate, area2);
}
function placeNonEntityAxis(components, coordinate, area2, position) {
  if (position === "center") {
    if (isRadar(coordinate)) {
      placeAxisRadar(components, coordinate, area2, position);
    } else if (isPolar(coordinate)) {
      placeArcLinear(components, coordinate, area2);
    } else if (isParallel(coordinate)) {
      placeAxisParallel(components, coordinate, area2, components[0].orientation);
    }
  } else if (position === "inner") {
    placeAxisArcInner(components, coordinate, area2);
  } else if (position === "outer") {
    placeAxisArcOuter(components, coordinate, area2);
  }
}
function placeAxisArcInner(components, coordinate, area2) {
  const [x2, y2, , height] = area2;
  const [cx, cy] = coordinate.getCenter();
  const [innerRadius] = radiusOf(coordinate);
  const r = height / 2;
  const size3 = innerRadius * r;
  const x05 = cx - size3;
  const y05 = cy - size3;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = {
      x: x2 + x05,
      y: y2 + y05,
      width: size3 * 2,
      height: size3 * 2
    };
  }
}
function placeAxisArcOuter(components, coordinate, area2) {
  const [x2, y2, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y2, width, height };
  }
}
function placeArcLinear(components, coordinate, area2) {
  const [x2, y2, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y2, width, height };
  }
}
function placeAxisParallel(components, coordinate, area2, orientation) {
  if (orientation === "horizontal") {
    placeAxisParallelHorizontal(components, coordinate, area2);
  } else if (orientation === "vertical") {
    placeAxisParallelVertical(components, coordinate, area2);
  }
}
function placeAxisParallelVertical(components, coordinate, area2) {
  const [x2, y2, , height] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const X = points.filter((_, i) => i % 2 === 0).map((d2) => d2 + x2);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const x3 = X[i];
    const width = X[i + 1] - x3;
    component.bbox = { x: x3, y: y2, width, height };
  }
}
function placeAxisParallelHorizontal(components, coordinate, area2) {
  const [x2, y2, width] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const Y = points.filter((_, i) => i % 2 === 1).map((d2) => d2 + y2);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const y3 = Y[i];
    const height = Y[i + 1] - y3;
    component.bbox = { x: x2, y: y3, width, height };
  }
}
function placeAxisRadar(components, coordinate, area2, position) {
  const [x2, y2, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y2, width, height };
    component.radar = {
      index: components.indexOf(component),
      count: components.length
    };
  }
}
function placePaddingArea(components, coordinate, area2) {
  const [x2, y2, width, height, direction, reverse2, comparator, minX, totalSize] = area2;
  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction === "vertical" ? ["y", y2, "x", x2, "height", height, "width", width] : ["x", x2, "y", y2, "width", width, "height", height];
  components.sort((a3, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a3.order, b.order));
  const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
  const crossSizeOf = (type, small, bigger) => {
    if (bigger === void 0)
      return small;
    if (isLarge(type))
      return bigger;
    return small;
  };
  const crossStartOf = (type, x3, minX2) => {
    if (minX2 === void 0)
      return x3;
    if (isLarge(type))
      return minX2;
    return x3;
  };
  const startValue = reverse2 ? mainStartValue + mainSizeValue : mainStartValue;
  for (let i = 0, start = startValue; i < components.length; i++) {
    const component = components[i];
    const { crossPadding = 0, type } = component;
    const { size: size3 } = component;
    component.bbox = {
      [mainStartKey]: reverse2 ? start - size3 - crossPadding : start + crossPadding,
      [crossStartKey]: crossStartOf(type, crossStartValue, minX),
      [mainSizeKey]: size3,
      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
    };
    start += (size3 + crossPadding) * (reverse2 ? -1 : 1);
  }
  const groupComponents2 = components.filter((d2) => d2.type === "group");
  for (const group2 of groupComponents2) {
    const { bbox, children } = group2;
    const size3 = bbox[crossSizeKey];
    const step = size3 / children.length;
    const justifyContent = children.reduce((j, child) => {
      var _a;
      const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;
      return j0 ? j0 : j;
    }, "flex-start");
    const L = children.map((d2, i) => {
      const { length = step, padding = 0 } = d2;
      return length + (i === children.length - 1 ? 0 : padding);
    });
    const totalLength = sum(L);
    const diff = size3 - totalLength;
    const offset = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
    for (let i = 0, start = bbox[crossStartKey] + offset; i < children.length; i++) {
      const component = children[i];
      const { padding = 0 } = component;
      const interval = i === children.length - 1 ? 0 : padding;
      component.bbox = {
        [mainSizeKey]: bbox[mainSizeKey],
        [mainStartKey]: bbox[mainStartKey],
        [crossStartKey]: start,
        [crossSizeKey]: L[i] - interval
      };
      deep_mix_default(component, { layout: { justifyContent } });
      start += L[i];
    }
  }
}
function placeCenter(components, coordinate, area2) {
  if (components.length === 0)
    return;
  const [x2, y2, width, height] = area2;
  const [innerRadius] = radiusOf(coordinate);
  const r = height / 2 * innerRadius / Math.sqrt(2);
  const cx = x2 + width / 2;
  const cy = y2 + height / 2;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
  }
}

// node_modules/@antv/g2/esm/runtime/transform.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest73 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function applyDefaults(I, mark2, context) {
  const { encode = {}, scale: scale3 = {}, transform = [] } = mark2, rest = __rest73(mark2, ["encode", "scale", "transform"]);
  return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale3, transform })];
}
function applyDataTransform(I, mark2, context) {
  return __awaiter3(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { data } = mark2;
    const [useData] = useLibrary("data", library3);
    const descriptor = normalizedDataSource(data);
    const { transform: T = [] } = descriptor, connector = __rest73(descriptor, ["transform"]);
    const transform = [connector, ...T];
    const transformFunctions = transform.map((t) => useData(t, context));
    const transformedData = yield composeAsync(transformFunctions)(data);
    const newData = data && !Array.isArray(data) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
    return [
      Array.isArray(transformedData) ? indexOf(transformedData) : [],
      Object.assign(Object.assign({}, mark2), { data: newData })
    ];
  });
}
function flatEncode(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const flattenEncode = {};
  for (const [key, value2] of Object.entries(encode)) {
    if (Array.isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        const name2 = `${key}${i === 0 ? "" : i}`;
        flattenEncode[name2] = value2[i];
      }
    } else {
      flattenEncode[key] = value2;
    }
  }
  return [I, Object.assign(Object.assign({}, mark2), { encode: flattenEncode })];
}
function inferChannelsType(I, mark2, context) {
  const { encode, data } = mark2;
  if (!encode)
    return [I, mark2];
  const typedEncode = mapObject(encode, (channel) => {
    if (isTypedChannel(channel))
      return channel;
    const type = inferChannelType(data, channel);
    return { type, value: channel };
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: typedEncode })];
}
function maybeVisualChannel(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const newEncode = mapObject(encode, (channel, name2) => {
    const { type } = channel;
    if (type !== "constant" || isPosition(name2))
      return channel;
    return Object.assign(Object.assign({}, channel), { constant: true });
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: newEncode })];
}
function extractColumns(I, mark2, context) {
  const { encode, data } = mark2;
  if (!encode)
    return [I, mark2];
  const { library: library3 } = context;
  const columnOf2 = createColumnOf(library3);
  const valuedEncode = mapObject(encode, (channel) => columnOf2(data, channel));
  return [I, Object.assign(Object.assign({}, mark2), { encode: valuedEncode })];
}
function normalizeTooltip(I, mark2, context) {
  const { tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  if (Array.isArray(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: tooltip2 } })];
  }
  if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: tooltip2 })];
  }
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: [tooltip2] } })];
}
function extractTooltip(I, mark2, context) {
  const { data, encode, tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  const valueOf4 = (item) => {
    if (!item)
      return item;
    if (typeof item === "string") {
      return I.map((i) => ({ name: item, value: data[i][item] }));
    }
    if (isStrictObject(item)) {
      const { field: field3, channel, color: color2, name: name2 = field3, valueFormatter = (d2) => d2 } = item;
      const normalizedValueFormatter = typeof valueFormatter === "string" ? format(valueFormatter) : valueFormatter;
      const definedChannel = channel && encode[channel];
      const channelField = definedChannel && encode[channel].field;
      const name1 = name2 || channelField || channel;
      const values3 = [];
      for (const i of I) {
        const value1 = field3 ? data[i][field3] : definedChannel ? encode[channel].value[i] : null;
        values3[i] = {
          name: name1,
          color: color2,
          value: normalizedValueFormatter(value1)
        };
      }
      return values3;
    }
    if (typeof item === "function") {
      const values3 = [];
      for (const i of I) {
        const v = item(data[i], i, data, encode);
        if (isStrictObject(v))
          values3[i] = v;
        else
          values3[i] = { value: v };
      }
      return values3;
    }
    return item;
  };
  const { title, items = [] } = tooltip2, rest = __rest73(tooltip2, ["title", "items"]);
  const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: newTooltip })];
}
function maybeArrayField(I, mark2, context) {
  const { encode } = mark2, rest = __rest73(mark2, ["encode"]);
  if (!encode)
    return [I, mark2];
  const columns = Object.entries(encode);
  const arrayColumns = columns.filter(([, channel]) => {
    const { value: V } = channel;
    return Array.isArray(V[0]);
  }).flatMap(([key, V]) => {
    const columns2 = [[key, new Array(I.length).fill(void 0)]];
    const { value: rows } = V, rest2 = __rest73(V, ["value"]);
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (Array.isArray(row)) {
        for (let j = 0; j < row.length; j++) {
          const column2 = columns2[j] || [
            `${key}${j}`,
            new Array(I).fill(void 0)
          ];
          column2[1][i] = row[j];
          columns2[j] = column2;
        }
      }
    }
    return columns2.map(([key2, value2]) => [
      key2,
      Object.assign({ type: "column", value: value2 }, rest2)
    ]);
  });
  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
  return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
}
function addGuideToScale(I, mark2, context) {
  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark2;
  const normalize3 = (guide, channel) => {
    if (typeof guide === "boolean")
      return guide ? {} : null;
    const eachGuide = guide[channel];
    return eachGuide === void 0 || eachGuide ? eachGuide : null;
  };
  const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
  deep_mix_default(mark2, {
    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
      const scrollbarOptions = normalize3(scrollbar, channel);
      return [
        channel,
        Object.assign({ guide: normalize3(axis, channel), slider: normalize3(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
          ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
        })
      ];
    }))), {
      color: { guide: normalize3(legend, "color") },
      size: { guide: normalize3(legend, "size") },
      shape: { guide: normalize3(legend, "shape") },
      // fixme: opacity is conflict with DisplayObject.opacity
      // to be confirm.
      opacity: { guide: normalize3(legend, "opacity") }
    })
  });
  return [I, mark2];
}
function maybeNonAnimate(I, mark2, context) {
  const { animate } = mark2;
  if (animate || animate === void 0)
    return [I, mark2];
  deep_mix_default(mark2, {
    animate: {
      enter: { type: null },
      exit: { type: null },
      update: { type: null }
    }
  });
  return [I, mark2];
}
function isTypedChannel(channel) {
  if (typeof channel !== "object" || channel instanceof Date || channel === null) {
    return false;
  }
  const { type } = channel;
  return defined(type);
}
function inferChannelType(data, channel) {
  if (typeof channel === "function")
    return "transform";
  if (typeof channel === "string" && isField(data, channel))
    return "field";
  return "constant";
}
function isField(data, value2) {
  if (!Array.isArray(data))
    return false;
  return data.some((d2) => d2[value2] !== void 0);
}
function normalizedDataSource(data) {
  if (isNumber(data))
    return { type: "inline", value: data };
  if (!data)
    return { type: "inline", value: null };
  if (Array.isArray(data))
    return { type: "inline", value: data };
  const { type = "inline" } = data, rest = __rest73(data, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}

// node_modules/@antv/g2/esm/runtime/mark.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest74 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function initializeMark(partialMark, partialProps, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
    const { encode, scale: scale3, data, tooltip: tooltip2 } = transformedMark;
    if (Array.isArray(data) === false) {
      return null;
    }
    const { channels: channelDescriptors } = partialProps;
    const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values3) => values3.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
      var _a;
      const prefix = (_a = /([^\d]+)\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
      const descriptor = channelDescriptors.find((d2) => d2.name === prefix);
      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
        return key;
      return prefix;
    });
    const channels = channelDescriptors.filter((descriptor) => {
      const { name: name2, required: required2 } = descriptor;
      if (nameChannels.find(([d2]) => d2 === name2))
        return true;
      if (required2)
        throw new Error(`Missing encoding for channel: ${name2}.`);
      return false;
    }).flatMap((descriptor) => {
      const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
      return valuesArray.map(([channel, values3], i) => {
        const visual = values3.some((d2) => d2.visual);
        const constant4 = values3.some((d2) => d2.constant);
        const _a = scale3[channel] || {}, {
          independent = false,
          // Use channel name as default scale key.
          key = scaleKey || channel,
          // Visual channel use identity scale.
          type = constant4 ? "constant" : visual ? "identity" : scaleType
        } = _a, scaleOptions = __rest74(_a, ["independent", "key", "type"]);
        const isConstant = type === "constant";
        const finalRange = isConstant ? void 0 : range3;
        return {
          name: channel,
          values: values3,
          // Generate a unique key for independent channel,
          // which will not group with any other channels.
          scaleKey: independent || isConstant ? Symbol("independent") : key,
          scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
            quantitative,
            ordinal
          })
        };
      });
    });
    return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
  });
}
function createColumnOf(library3) {
  const [useEncode] = useLibrary("encode", library3);
  return (data, encode) => {
    if (encode === void 0)
      return null;
    if (data === void 0)
      return null;
    return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data), field: fieldOf(encode) });
  };
}
function applyMarkTransform(mark2, props, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTransform] = useLibrary("transform", library3);
    const { preInference = [], postInference = [] } = props;
    const { transform = [] } = mark2;
    const transforms = [
      applyDefaults,
      applyDataTransform,
      flatEncode,
      inferChannelsType,
      maybeVisualChannel,
      extractColumns,
      maybeArrayField,
      maybeNonAnimate,
      addGuideToScale,
      normalizeTooltip,
      ...preInference.map(useTransform),
      ...transform.map(useTransform),
      ...postInference.map(useTransform),
      extractTooltip
    ];
    let index2 = [];
    let transformedMark = mark2;
    for (const t of transforms) {
      [index2, transformedMark] = yield t(index2, transformedMark, context);
    }
    return [index2, transformedMark];
  });
}
function fieldOf(encode) {
  const { type, value: value2 } = encode;
  if (type === "field" && typeof value2 === "string")
    return value2;
  return null;
}

// node_modules/@antv/g2/esm/runtime/plot.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest75 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function plot(options, selection, context) {
  var _a;
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useComposition] = useLibrary("composition", library3);
    const [useInteraction] = useLibrary("interaction", library3);
    const marks = new Set(Object.keys(library3).map((d2) => {
      var _a2;
      return (_a2 = /mark\.(.*)/.exec(d2)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const staticMarks = new Set(Object.keys(library3).map((d2) => {
      var _a2;
      return (_a2 = /component\.(.*)/.exec(d2)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const typeOf = (node) => {
      const { type } = node;
      if (typeof type === "function") {
        const { props = {} } = type;
        const { composite = true } = props;
        if (composite)
          return "mark";
      }
      if (typeof type !== "string")
        return type;
      if (marks.has(type) || staticMarks.has(type))
        return "mark";
      return type;
    };
    const isMark2 = (node) => typeOf(node) === "mark";
    const isStandardView = (node) => typeOf(node) === "standardView";
    const isStaticMark = (node) => {
      const { type } = node;
      if (typeof type !== "string")
        return false;
      if (staticMarks.has(type))
        return true;
      return false;
    };
    const transform = (node) => {
      if (isStandardView(node))
        return [node];
      const type = typeOf(node);
      const composition = useComposition({ type, static: isStaticMark(node) });
      return composition(node);
    };
    const views = [];
    const viewNode = /* @__PURE__ */ new Map();
    const nodeState = /* @__PURE__ */ new Map();
    const discovered = [options];
    const nodeGenerators = [];
    while (discovered.length) {
      const node = discovered.shift();
      if (isStandardView(node)) {
        const state = nodeState.get(node);
        const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
        viewNode.set(view, node);
        views.push(view);
        const transformedNodes = children.flatMap(transform).map((d2) => coordinate2Transform(d2, library3));
        discovered.push(...transformedNodes);
        if (transformedNodes.every(isStandardView)) {
          const states = yield Promise.all(transformedNodes.map((d2) => initializeMarks(d2, context)));
          syncFacetsScales(states);
          for (let i = 0; i < transformedNodes.length; i++) {
            const nodeT = transformedNodes[i];
            const state2 = states[i];
            nodeState.set(nodeT, state2);
          }
        }
      } else {
        const n = isMark2(node) ? node : yield applyTransform(node, context);
        const N = transform(n);
        if (Array.isArray(N))
          discovered.push(...N);
        else if (typeof N === "function")
          nodeGenerators.push(N());
      }
    }
    context.emitter.emit(ChartEvent.BEFORE_PAINT);
    const enterContainer = /* @__PURE__ */ new Map();
    const updateContainer = /* @__PURE__ */ new Map();
    const transitions = [];
    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d2) => d2.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, context);
      enterContainer.set(view, element);
    }), (update) => update.call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, context);
      updateContainer.set(view, element);
    }), (exit) => exit.each(function(d2, i, element) {
      const interactions = element["nameInteraction"].values();
      for (const interaction of interactions) {
        interaction.destroy();
      }
    }).remove());
    const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
      return Array.from(viewContainer.entries()).map(([view, container]) => {
        const store = oldStore || /* @__PURE__ */ new Map();
        const setState = (key, reducer = (x2) => x2) => store.set(key, reducer);
        const options2 = viewNode.get(view);
        const update = createUpdateView(select(container), options2, context);
        return {
          view,
          container,
          options: options2,
          setState,
          update: (from, updateTypes) => __awaiter5(this, void 0, void 0, function* () {
            const reducer = compose(Array.from(store.values()));
            const newOptions = reducer(options2);
            return yield update(newOptions, from, () => {
              if (isArray(updateTypes)) {
                updateInteractions2(viewContainer, updateTypes, store);
              }
            });
          })
        };
      });
    };
    const updateInteractions = (container = updateContainer, updateType, oldStore) => {
      var _a2;
      const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
      for (const target of updateViewInstances) {
        const { options: options2, container: container2 } = target;
        const nameInteraction = container2["nameInteraction"];
        let typeOptions = inferInteraction(options2);
        if (updateType) {
          typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
        }
        for (const typeOption of typeOptions) {
          const [type, option] = typeOption;
          const prevInteraction = nameInteraction.get(type);
          if (prevInteraction)
            (_a2 = prevInteraction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(prevInteraction);
          if (option) {
            const interaction = useThemeInteraction(target.view, type, option, useInteraction);
            const destroy2 = interaction(target, updateViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy2 });
          }
        }
      }
    };
    const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
    for (const target of enterViewInstances) {
      const { options: options2 } = target;
      const nameInteraction = /* @__PURE__ */ new Map();
      target.container["nameInteraction"] = nameInteraction;
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, enterViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    updateInteractions();
    const { width, height } = options;
    const keyframes = [];
    for (const nodeGenerator of nodeGenerators) {
      const keyframe = new Promise((resolve) => __awaiter5(this, void 0, void 0, function* () {
        for (const node of nodeGenerator) {
          const sizedNode = Object.assign({ width, height }, node);
          yield plot(sizedNode, selection, context);
        }
        resolve();
      }));
      keyframes.push(keyframe);
    }
    context.views = views;
    (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
    context.animations = transitions;
    context.emitter.emit(ChartEvent.AFTER_PAINT);
    const finished = transitions.filter(defined).map(cancel).map((d2) => d2.finished);
    return Promise.all([...finished, ...keyframes]);
  });
}
function applyTranslate(selection) {
  selection.style("transform", (d2) => `translate(${d2.layout.x}, ${d2.layout.y})`);
}
function definedInteraction(library3) {
  const [, createInteraction] = useLibrary("interaction", library3);
  return (d2) => {
    const [name2, options] = d2;
    try {
      return [name2, createInteraction(name2)];
    } catch (_a) {
      return [name2, options.type];
    }
  };
}
function createUpdateView(selection, options, context) {
  const { library: library3 } = context;
  const createDefinedInteraction = definedInteraction(library3);
  const filter2 = (d2) => d2[1] && d2[1].props && d2[1].props.reapplyWhenUpdate;
  const interactions = inferInteraction(options);
  const updates = interactions.map(createDefinedInteraction).filter(filter2).map((d2) => d2[0]);
  return (newOptions, source, callback) => __awaiter5(this, void 0, void 0, function* () {
    const transitions = [];
    const [newView, newChildren] = yield initializeView(newOptions, context);
    plotView(newView, selection, transitions, context);
    for (const name2 of updates.filter((d2) => d2 !== source)) {
      updateInteraction(name2, selection, newOptions, newView, context);
    }
    for (const child of newChildren) {
      plot(child, selection, context);
    }
    callback();
    return { options: newOptions, view: newView };
  });
}
function updateInteraction(name2, selection, options, view, context) {
  var _a;
  const { library: library3 } = context;
  const [useInteraction] = useLibrary("interaction", library3);
  const container = selection.node();
  const nameInteraction = container["nameInteraction"];
  const interactionOptions = inferInteraction(options).find(([d2]) => d2 === name2);
  const interaction = nameInteraction.get(name2);
  if (!interaction)
    return;
  (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);
  if (!interactionOptions[1])
    return;
  const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
  const target = {
    options,
    view,
    container: selection.node(),
    update: (options2) => Promise.resolve(options2)
  };
  const destroy2 = applyInteraction(target, [], context.emitter);
  nameInteraction.set(name2, { destroy: destroy2 });
}
function initializeView(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const flattenOptions = yield transformMarks(options, context);
    const mergedOptions = bubbleOptions(flattenOptions);
    options.interaction = mergedOptions.interaction;
    options.coordinate = mergedOptions.coordinate;
    options.marks = [...mergedOptions.marks, ...mergedOptions.components];
    const transformedOptions = coordinate2Transform(mergedOptions, library3);
    const state = yield initializeMarks(transformedOptions, context);
    return initializeState(state, transformedOptions, library3);
  });
}
function bubbleOptions(options) {
  const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest75(options, ["coordinate", "interaction", "style", "marks"]);
  const markCoordinates = marks.map((d2) => d2.coordinate || {});
  const markInteractions = marks.map((d2) => d2.interaction || {});
  const markViewStyles = marks.map((d2) => d2.viewStyle || {});
  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
}
function transformMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useMark, createMark] = useLibrary("mark", library3);
    const staticMarks = new Set(Object.keys(library3).map((d2) => {
      var _a;
      return (_a = /component\.(.*)/.exec(d2)) === null || _a === void 0 ? void 0 : _a[1];
    }).filter(defined));
    const { marks } = options;
    const flattenMarks = [];
    const components = [];
    const discovered = [...marks];
    const { width, height } = computeRoughPlotSize(options);
    const markOptions = { options, width, height };
    while (discovered.length) {
      const [node] = discovered.splice(0, 1);
      const mark2 = yield applyTransform(node, context);
      const { type = error("G2Mark type is required."), key } = mark2;
      if (staticMarks.has(type))
        components.push(mark2);
      else {
        const { props = {} } = createMark(type);
        const { composite = true } = props;
        if (!composite)
          flattenMarks.push(mark2);
        else {
          const { data } = mark2;
          const newMark = Object.assign(Object.assign({}, mark2), { data: data ? Array.isArray(data) ? data : data.value : data });
          const marks2 = yield useMark(newMark, markOptions);
          const M2 = Array.isArray(marks2) ? marks2 : [marks2];
          discovered.unshift(...M2.map((d2, i) => Object.assign(Object.assign({}, d2), { key: `${key}-${i}` })));
        }
      }
    }
    return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
  });
}
function initializeMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTheme] = useLibrary("theme", library3);
    const [, createMark] = useLibrary("mark", library3);
    const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const markState = /* @__PURE__ */ new Map();
    for (const markOptions of partialMarks) {
      const { type } = markOptions;
      const { props = {} } = createMark(type);
      const markAndState = yield initializeMark(markOptions, props, context);
      if (markAndState) {
        const [initializedMark, state] = markAndState;
        markState.set(initializedMark, state);
      }
    }
    const scaleChannels = group(Array.from(markState.values()).flatMap((d2) => d2.channels), ({ scaleKey }) => scaleKey);
    for (const channels of scaleChannels.values()) {
      const scaleOptions = channels.reduce((total, { scale: scale4 }) => deep_mix_default(total, scale4), {});
      const { scaleKey } = channels[0];
      const { values: FV } = channels[0];
      const fields = Array.from(new Set(FV.map((d2) => d2.field).filter(defined)));
      const options2 = deep_mix_default({
        guide: { title: fields.length === 0 ? void 0 : fields },
        field: fields[0]
      }, scaleOptions);
      const { name: name2 } = channels[0];
      const values3 = channels.flatMap(({ values: values4 }) => values4.map((d2) => d2.value));
      const scale3 = Object.assign(Object.assign({}, inferScale(name2, values3, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
      channels.forEach((channel) => channel.scale = scale3);
    }
    return markState;
  });
}
function useThemeInteraction(view, type, option, useInteraction) {
  const theme = view.theme;
  const defaults4 = typeof type === "string" ? theme[type] || {} : {};
  const interaction = useInteraction(deep_mix_default(defaults4, Object.assign({ type }, option)));
  return interaction;
}
function initializeState(markState, options, library3) {
  var _a;
  const [useMark] = useLibrary("mark", library3);
  const [useTheme] = useLibrary("theme", library3);
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { key, frame = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
  const theme = useTheme(inferTheme(partialTheme));
  const states = Array.from(markState.values());
  const scales = collectScales(states, options);
  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
  const layout = computeLayout(components, options, theme, library3);
  const coordinate = createCoordinate(layout, options, library3);
  const framedStyle = frame ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
  placeComponents(groupComponents(components), coordinate, layout);
  processAxisZ(components);
  const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
    const { channels } = state;
    return channels.map(({ scale: scale3 }) => [
      scale3.uid,
      useRelationScale(scale3, library3)
    ]);
  }));
  groupTransform(markState, uidScale);
  const scaleInstance = {};
  for (const component of components) {
    const { scales: scaleDescriptors = [] } = component;
    const scales2 = [];
    for (const descriptor of scaleDescriptors) {
      const { name: name2, uid } = descriptor;
      const scale3 = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : useRelationScale(descriptor, library3);
      scales2.push(scale3);
      if (name2 === "y") {
        scale3.update(Object.assign(Object.assign({}, scale3.getOptions()), { xScale: scaleInstance.x }));
      }
      assignScale(scaleInstance, { [name2]: scale3 });
    }
    component.scaleInstances = scales2;
  }
  const children = [];
  for (const [mark2, state] of markState.entries()) {
    const {
      // scale,
      // Callback to create children options based on this mark.
      children: createChildren,
      // The total count of data (both show and hide)for this facet.
      // This is for unit visualization to sync data domain.
      dataDomain,
      modifier,
      key: markKey
    } = mark2;
    const { index: index2, channels, tooltip: tooltip2 } = state;
    const scale3 = Object.fromEntries(channels.map(({ name: name2, scale: scale4 }) => [name2, scale4]));
    const markScaleInstance = mapObject(scale3, ({ uid }) => uidScale.get(uid));
    assignScale(scaleInstance, markScaleInstance);
    const value2 = applyScale(channels, markScaleInstance);
    const calcPoints = useMark(mark2);
    const [I, P, S] = filterValid(calcPoints(index2, markScaleInstance, value2, coordinate));
    const count4 = dataDomain || I.length;
    const T = modifier ? modifier(P, count4, layout) : [];
    const titleOf = (i) => {
      var _a2, _b;
      return (_b = (_a2 = tooltip2.title) === null || _a2 === void 0 ? void 0 : _a2[i]) === null || _b === void 0 ? void 0 : _b.value;
    };
    const itemsOf2 = (i) => tooltip2.items.map((V) => V[i]);
    const visualData = I.map((d2, i) => {
      const datum = Object.assign({ points: P[i], transform: T[i], index: d2, markKey, viewKey: key }, tooltip2 && {
        title: titleOf(d2),
        items: itemsOf2(d2)
      });
      for (const [k2, V] of Object.entries(value2)) {
        datum[k2] = V[d2];
        if (S)
          datum[`series${upper_first_default(k2)}`] = S[i].map((i2) => V[i2]);
      }
      if (S)
        datum["seriesIndex"] = S[i];
      if (S && tooltip2) {
        datum["seriesItems"] = S[i].map((si) => itemsOf2(si));
        datum["seriesTitle"] = S[i].map((si) => titleOf(si));
      }
      return datum;
    });
    state.data = visualData;
    state.index = I;
    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
    children.push(...markChildren || []);
  }
  const view = {
    layout,
    theme,
    coordinate,
    markState,
    key,
    clip,
    scale: scaleInstance,
    style: framedStyle,
    components,
    labelTransform: compose(labelTransform.map(useLabelTransform))
  };
  return [view, children];
}
function plotView(view, selection, transitions, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale3 } = view;
    const { x: x2, y: y2, width, height } = layout, rest = __rest75(layout, ["x", "y", "width", "height"]);
    const areaKeys = ["view", "plot", "main", "content"];
    const I = areaKeys.map((_, i) => i);
    const sizeKeys = ["a", "margin", "padding", "inset"];
    const areaStyles = areaKeys.map((d2) => maybeSubObject(Object.assign({}, theme.view, style), d2));
    const areaSizes = sizeKeys.map((d2) => subObject(rest, d2));
    const styleArea = (selection2) => selection2.style("x", (i) => areaLayouts[i].x).style("y", (i) => areaLayouts[i].y).style("width", (i) => areaLayouts[i].width).style("height", (i) => areaLayouts[i].height).each(function(i, d2, element) {
      applyStyle2(select(element), areaStyles[i]);
    });
    let px = 0;
    let py = 0;
    let pw = width;
    let ph = height;
    const areaLayouts = I.map((i) => {
      const size3 = areaSizes[i];
      const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size3;
      px += left2;
      py += top;
      pw -= left2 + right2;
      ph -= top + bottom;
      return {
        x: px,
        y: py,
        width: pw,
        height: ph
      };
    });
    selection.selectAll(className(AREA_CLASS_NAME)).data(
      // Only render area with defined style.
      I.filter((i) => defined(areaStyles[i])),
      (i) => areaKeys[i]
    ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update) => update.call(styleArea), (exit) => exit.remove());
    const animationExtent = computeAnimationExtent(markState);
    const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
    for (const [, C2] of groups(components, (d2) => `${d2.type}-${d2.position}`)) {
      C2.forEach((d2, i) => d2.index = i);
    }
    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d2) => `${d2.type}-${d2.position}-${d2.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale3 }, options), coordinate, theme, library3, markState)), (update) => update.transition(function(options, i, element) {
      const { preserve = false } = options;
      if (preserve)
        return;
      const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale3 }, options), coordinate, theme, library3, markState);
      const { attributes } = newComponent;
      const [node] = element.childNodes;
      return node.update(attributes, false);
    })).transitions();
    transitions.push(...componentsTransitions.flat().filter(defined));
    const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update) => update.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
      return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
    }).call(applyClip, clip)).transitions();
    transitions.push(...T.flat());
    for (const [mark2, state] of markState.entries()) {
      const { data } = state;
      const { key: key2, class: cls, type } = mark2;
      const viewNode = selection.select(`#${key2}`);
      const shapeFunction = createMarkShapeFunction(mark2, state, view, context);
      const enterFunction = createEnterFunction(mark2, state, view, library3);
      const updateFunction = createUpdateFunction(mark2, state, view, library3);
      const exitFunction = createExitFunction(mark2, state, view, library3);
      const facetElements = selectFacetElements(selection, viewNode, cls, "element");
      const T2 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data, (d2) => d2.key, (d2) => d2.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data2, i, element) {
        return enterFunction(data2, [element]);
      }), (update) => update.call((selection2) => {
        const parent = selection2.parent();
        const origin = useMemo((node) => {
          const [x3, y3] = node.getBounds().min;
          return [x3, y3];
        });
        selection2.transition(function(data2, index2, element) {
          maybeFacetElement(element, parent, origin);
          const node = shapeFunction(data2, index2);
          const animation = updateFunction(data2, [element], [node]);
          if (animation !== null)
            return animation;
          if (element.nodeName === node.nodeName && node.nodeName !== "g") {
            copyAttributes(element, node);
          } else {
            element.parentNode.replaceChild(node, element);
            node.className = ELEMENT_CLASS_NAME;
            node.markType = type;
            node.__data__ = element.__data__;
          }
          return animation;
        }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
      }), (exit) => {
        return exit.each(function(d2, i, element) {
          element.__removed__ = true;
        }).transition(function(data2, i, element) {
          return exitFunction(data2, [element]);
        }).remove();
      }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data2, i, element) {
        const { __fromElements__: fromElements } = element;
        const transition = updateFunction(data2, fromElements, [element]);
        const exit = new Selection(fromElements, null, element.parentNode);
        exit.transition(transition).remove();
        return transition;
      }), (split) => split.transition(function(data2, i, element) {
        const enter = new Selection([], element.__toData__, element.parentNode);
        const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
        return updateFunction(data2, [element], toElements);
      }).remove()).transitions();
      transitions.push(...T2.flat());
    }
    plotLabel(view, selection, transitions, library3, context);
  });
}
function plotLabel(view, selection, transitions, library3, context) {
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { markState, labelTransform } = view;
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  const labelShapeFunction = /* @__PURE__ */ new Map();
  const labelDescriptor = /* @__PURE__ */ new Map();
  const labels = Array.from(markState.entries()).flatMap(([mark2, state]) => {
    const { labels: labelOptions = [], key } = mark2;
    const shapeFunction = createLabelShapeFunction(mark2, state, view, library3, context);
    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n) => !n.__removed__);
    return labelOptions.flatMap((labelOption, i) => {
      const { transform = [] } = labelOption, options = __rest75(labelOption, ["transform"]);
      return elements.flatMap((e) => {
        const L = getLabels(options, i, e);
        L.forEach((l) => {
          labelShapeFunction.set(l, (data) => shapeFunction(Object.assign(Object.assign({}, data), { element: e })));
          labelDescriptor.set(l, labelOption);
        });
        return L;
      });
    });
  });
  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d2) => d2.key).join((enter) => enter.append((d2) => labelShapeFunction.get(d2)(d2)).attr("className", LABEL_CLASS_NAME), (update) => update.each(function(d2, i, element) {
    const shapeFunction = labelShapeFunction.get(d2);
    const node = shapeFunction(d2);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
  const labelGroups = group(labelShapes, (d2) => labelDescriptor.get(d2.__data__));
  const { coordinate, layout } = view;
  const labelTransformContext = {
    canvas: context.canvas,
    coordinate,
    layout
  };
  for (const [label, shapes] of labelGroups) {
    const { transform = [] } = label;
    const transformFunction = compose(transform.map(useLabelTransform));
    transformFunction(shapes, labelTransformContext);
  }
  if (labelTransform) {
    labelTransform(labelShapes, labelTransformContext);
  }
}
function getLabels(label, labelIndex, element) {
  const { seriesIndex: SI, seriesKey, points, key, index: index2 } = element.__data__;
  const bounds = getLocalBounds(element);
  if (!SI) {
    return [
      Object.assign(Object.assign({}, label), {
        key: `${key}-${labelIndex}`,
        bounds,
        index: index2,
        points,
        dependentElement: element
      })
    ];
  }
  const selector = normalizeLabelSelector(label);
  const F = SI.map((index3, i) => Object.assign(Object.assign({}, label), {
    key: `${seriesKey[i]}-${labelIndex}`,
    bounds: [points[i]],
    index: index3,
    points,
    dependentElement: element
  }));
  return selector ? selector(F) : F;
}
function filterValid([I, P, S]) {
  if (S)
    return [I, P, S];
  const definedIndex = [];
  const definedPoints = [];
  for (let i = 0; i < I.length; i++) {
    const d2 = I[i];
    const p2 = P[i];
    if (p2.every(([x2, y2]) => defined(x2) && defined(y2))) {
      definedIndex.push(d2);
      definedPoints.push(p2);
    }
  }
  return [definedIndex, definedPoints];
}
function normalizeLabelSelector(label) {
  const { selector } = label;
  if (!selector)
    return null;
  if (typeof selector === "function")
    return selector;
  if (selector === "first")
    return (I) => [I[0]];
  if (selector === "last")
    return (I) => [I[I.length - 1]];
  throw new Error(`Unknown selector: ${selector}`);
}
function getLocalBounds(element) {
  const cloneElement = element.cloneNode();
  const animations = element.getAnimations();
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    cloneElement.attr(keyframes[keyframes.length - 1]);
  });
  element.parentNode.appendChild(cloneElement);
  const bounds = cloneElement.getLocalBounds();
  cloneElement.destroy();
  const { min: min6, max: max6 } = bounds;
  return [min6, max6];
}
function createLabelShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { data: visualData, defaultLabelShape } = state;
  const point2d = visualData.map((d2) => d2.points);
  const channel = mapObject(encode, (d2) => d2.value);
  const { theme, coordinate } = view;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    theme,
    coordinate
  });
  return (options) => {
    const { index: index2, points } = options;
    const datum = abstractData[index2];
    const { formatter = (d2) => `${d2}`, transform, style: abstractStyle, render: render2, selector, element } = options, abstractOptions = __rest75(options, ["formatter", "transform", "style", "render", "selector", "element"]);
    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d2) => valueOf2(d2, datum, index2, abstractData, {
      channel,
      element
    }));
    const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest75(visualOptions, ["shape", "text"]);
    const f = typeof formatter === "string" ? format(formatter) : formatter;
    const value2 = Object.assign(Object.assign({}, style), { text: f(text, datum, index2, abstractData), datum });
    const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render2 }, style);
    const shapeFunction = useShape(shapeOptions, shapeContext);
    const defaults4 = getDefaultsStyle(theme, "label", shape23, "label");
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function valueOf2(value2, datum, i, data, options) {
  if (typeof value2 === "function")
    return value2(datum, i, data, options);
  if (typeof value2 !== "string")
    return value2;
  if (isStrictObject(datum) && datum[value2] !== void 0)
    return datum[value2];
  return value2;
}
function computeAnimationExtent(markState) {
  let maxDuration = -Infinity;
  let minDelay = Infinity;
  for (const [mark2, state] of markState) {
    const { animate = {} } = mark2;
    const { data } = state;
    const { enter = {}, update = {}, exit = {} } = animate;
    const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update;
    const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
    const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
    for (const d2 of data) {
      const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d2;
      if (updateType === void 0 || updateType) {
        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
        minDelay = Math.min(minDelay, updateDelay);
      }
      if (exitType === void 0 || exitType) {
        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
        minDelay = Math.min(minDelay, exitDelay);
      }
      if (enterType === void 0 || enterType) {
        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
        minDelay = Math.min(minDelay, enterDelay);
      }
    }
  }
  if (maxDuration === -Infinity)
    return null;
  return [minDelay, maxDuration - minDelay];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
  const group2 = selection.node().parentElement;
  return group2.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
}
function maybeFacetElement(element, parent, originOf) {
  if (!element.__facet__)
    return;
  const prePlot = element.parentNode.parentNode;
  const newPlot = parent.parentNode;
  const [px, py] = originOf(prePlot);
  const [x2, y2] = originOf(newPlot);
  const translate2 = `translate(${px - x2}, ${py - y2})`;
  appendTransform(element, translate2);
  parent.append(element);
}
function createMarkShapeFunction(mark2, state, view, context) {
  const { library: library3 } = context;
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { defaultShape, data, shape: shapeLibrary } = state;
  const channel = mapObject(encode, (d2) => d2.value);
  const point2d = data.map((d2) => d2.points);
  const { theme, coordinate } = view;
  const { type: markType, style = {} } = mark2;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    coordinate,
    theme
  });
  return (data2) => {
    const { shape: styleShape = defaultShape } = style;
    const { shape: shape23 = styleShape, points, seriesIndex, index: i } = data2, v = __rest75(data2, ["shape", "points", "seriesIndex", "index"]);
    const value2 = Object.assign(Object.assign({}, v), { index: i });
    const abstractDatum = seriesIndex ? seriesIndex.map((i2) => abstractData[i2]) : abstractData[i];
    const I = seriesIndex ? seriesIndex : i;
    const visualStyle = mapObject(style, (d2) => valueOf2(d2, abstractDatum, I, abstractData, { channel }));
    const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark2, shape23) }), shapeContext);
    const defaults4 = getDefaultsStyle(theme, markType, shape23, defaultShape);
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function getDefaultsStyle(theme, mark2, shape23, defaultShape) {
  if (typeof mark2 !== "string")
    return;
  const { color: color2 } = theme;
  const markTheme = theme[mark2] || {};
  const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
  return Object.assign({ color: color2 }, shapeTheme);
}
function createAnimationFunction(type, mark2, state, view, library3) {
  var _a, _b;
  const [, createShape] = useLibrary("shape", library3);
  const [useAnimation] = useLibrary("animation", library3);
  const { defaultShape, shape: shapeLibrary } = state;
  const { theme, coordinate } = view;
  const upperType = upper_first_default(type);
  const key = `default${upperType}Animation`;
  const { [key]: defaultAnimation } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark2, defaultShape)).props;
  const { [type]: defaultEffectTiming = {} } = theme;
  const animate = ((_b = mark2.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
  const context = { coordinate };
  return (data, from, to) => {
    const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data;
    const options = Object.assign({ type: animation || defaultAnimation }, animate);
    if (!options.type)
      return null;
    const animateFunction = useAnimation(options, context);
    const value2 = { delay, duration, easing };
    const A5 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
    if (!Array.isArray(A5))
      return [A5];
    return A5;
  };
}
function createEnterFunction(mark2, state, view, library3) {
  return createAnimationFunction("enter", mark2, state, view, library3);
}
function cancel(animation) {
  animation.finished.then(() => {
    animation.cancel();
  });
  return animation;
}
function createUpdateFunction(mark2, state, view, library3) {
  return createAnimationFunction("update", mark2, state, view, library3);
}
function createExitFunction(mark2, state, view, library3) {
  return createAnimationFunction("exit", mark2, state, view, library3);
}
function inferTheme(theme = {}) {
  if (typeof theme === "string")
    return { type: theme };
  const { type = "light" } = theme, rest = __rest75(theme, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}
function inferInteraction(view) {
  const defaults4 = {
    event: true,
    tooltip: true,
    // @todo Inferred by slider self.
    sliderFilter: true,
    legendFilter: true,
    scrollbarFilter: true
  };
  const { interaction = {} } = view;
  return Object.entries(deep_mix_default(defaults4, interaction)).reverse();
}
function applyTransform(node, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { data } = node, rest = __rest75(node, ["data"]);
    if (data == void 0)
      return node;
    const [, { data: newData }] = yield applyDataTransform([], { data }, context);
    return Object.assign({ data: newData }, rest);
  });
}
function updateBBox(selection) {
  selection.style("transform", (d2) => `translate(${d2.paddingLeft + d2.marginLeft}, ${d2.paddingTop + d2.marginTop})`).style("width", (d2) => d2.innerWidth).style("height", (d2) => d2.innerHeight);
}
function animateBBox(selection, extent2) {
  const [delay, duration] = extent2;
  selection.transition(function(data, i, element) {
    const { transform, width, height } = element.style;
    const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data;
    const keyframes = [
      {
        transform,
        width,
        height
      },
      {
        transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
        width: innerWidth,
        height: innerHeight
      }
    ];
    return element.animate(keyframes, { delay, duration, fill: "both" });
  });
}
function shapeName(mark2, name2) {
  const { type } = mark2;
  if (typeof name2 === "string")
    return `${type}.${name2}`;
  return name2;
}
function updateLayers(selection, marks) {
  const facet = (d2) => d2.class !== void 0 ? `${d2.class}` : "";
  const nodes = selection.nodes();
  if (nodes.length === 0)
    return;
  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d2) => d2.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d2) => d2.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
    var _a;
    return (_a = d2.zIndex) !== null && _a !== void 0 ? _a : 0;
  }), (update) => update.style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
    var _a;
    return (_a = d2.zIndex) !== null && _a !== void 0 ? _a : 0;
  }), (exit) => exit.remove());
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  if (labelLayer)
    return;
  selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
}
function className(...names) {
  return names.map((d2) => `.${d2}`).join("");
}
function applyClip(selection, clip) {
  if (!selection.node())
    return;
  selection.style("clipPath", (data) => {
    if (!clip)
      return null;
    const { paddingTop: y2, paddingLeft: x2, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data;
    return new Rect({ style: { x: x2 + x12, y: y2 + y12, width, height } });
  });
}
function inferComponentScales(scales, states, markState) {
  var _a;
  for (const [key] of markState.entries()) {
    if (key.type === "cell") {
      return scales.filter((scale3) => scale3.name !== "shape");
    }
  }
  if (states.length !== 1 || scales.some((scale3) => scale3.name === "shape")) {
    return scales;
  }
  const { defaultShape: shape23 } = states[0];
  const acceptMarkTypes = ["point", "line", "rect", "hollow"];
  if (!acceptMarkTypes.includes(shape23))
    return scales;
  const shapeMap = {
    point: "point",
    line: "hyphen",
    rect: "square",
    hollow: "hollow"
  };
  const field3 = ((_a = scales.find((scale3) => scale3.name === "color")) === null || _a === void 0 ? void 0 : _a.field) || null;
  const shapeScale = {
    field: field3,
    name: "shape",
    type: "constant",
    domain: [],
    range: [shapeMap[shape23]]
  };
  return [...scales, shapeScale];
}
function applyStyle2(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}

// node_modules/@antv/g2/esm/utils/flow.js
function flow(...flows) {
  return (param) => {
    return flows.reduce((result, f) => {
      return f(result);
    }, param);
  };
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/style.js
function columnWidthRatio(options) {
  const { style, scale: scale3, type } = options;
  const scaleOption = {};
  const columnWidthRatio2 = get_default(style, "columnWidthRatio");
  if (columnWidthRatio2 && type === "interval") {
    scaleOption.x = Object.assign(Object.assign({}, scale3 === null || scale3 === void 0 ? void 0 : scale3.x), { padding: 1 - columnWidthRatio2 });
  }
  return Object.assign(Object.assign({}, options), { scale: Object.assign(Object.assign({}, scale3), scaleOption) });
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/index.js
function preprocessOption(options) {
  const convertedOptions = adapter(options);
  if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
    convertedOptions.children = convertedOptions.children.map((child) => preprocessOption(child));
  }
  return convertedOptions;
}
function adapter(options) {
  return flow(columnWidthRatio)(options);
}

// node_modules/@antv/g2/esm/runtime/render.js
function inferKeys(options) {
  const root = deep_mix_default({}, options);
  const nodeParent = /* @__PURE__ */ new Map([[root, null]]);
  const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
  const discovered = [root];
  while (discovered.length) {
    const node = discovered.shift();
    if (node.key === void 0) {
      const parent = nodeParent.get(node);
      const index2 = nodeIndex.get(node);
      const key = parent === null ? `${0}` : `${parent.key}-${index2}`;
      node.key = key;
    }
    const { children = [] } = node;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; i++) {
        const child = deep_mix_default({}, children[i]);
        children[i] = child;
        nodeParent.set(child, node);
        nodeIndex.set(child, i);
        discovered.push(child);
      }
    }
  }
  return root;
}
function Canvas2(width, height) {
  const renderer = new Renderer();
  renderer.registerPlugin(new Plugin());
  return new Canvas({
    width,
    height,
    container: document.createElement("div"),
    renderer
  });
}
function render(options, context = {}, resolve = () => {
}, reject = (e) => {
  throw e;
}) {
  const { width = 640, height = 480, depth = 0 } = options;
  const preprocessedOption = preprocessOption(options);
  const keyed2 = inferKeys(preprocessedOption);
  const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
  context.canvas = canvas;
  context.emitter = emitter;
  const { width: prevWidth, height: prevHeight } = canvas.getConfig();
  if (prevWidth !== width || prevHeight !== height) {
    canvas.resize(width, height);
  }
  emitter.emit(ChartEvent.BEFORE_RENDER);
  const selection = select(canvas.document.documentElement);
  canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
    if (depth) {
      const [x2, y2] = canvas.document.documentElement.getPosition();
      canvas.document.documentElement.setPosition(x2, y2, -depth / 2);
    }
    canvas.requestAnimationFrame(() => {
      canvas.requestAnimationFrame(() => {
        emitter.emit(ChartEvent.AFTER_RENDER);
        resolve === null || resolve === void 0 ? void 0 : resolve();
      });
    });
  }).catch((e) => {
    reject === null || reject === void 0 ? void 0 : reject(e);
  });
  return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = () => {
}, reject = (e) => {
  throw e;
}) {
  var _a;
  const { width = 640, height = 480 } = options;
  const keyed2 = inferKeys(options);
  const { group: group2 = new Group(), emitter = new esm_default(), library: library3 } = context;
  if (!(group2 === null || group2 === void 0 ? void 0 : group2.parentElement)) {
    error(`renderToMountedElement can't render chart to unmounted group.`);
  }
  const selection = select(group2);
  context.group = group2;
  context.emitter = emitter;
  context.canvas = context.canvas || ((_a = group2 === null || group2 === void 0 ? void 0 : group2.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
  emitter.emit(ChartEvent.BEFORE_RENDER);
  plot(Object.assign(Object.assign({}, keyed2), { width, height }), selection, context).then(() => {
    var _a2;
    (_a2 = context.canvas) === null || _a2 === void 0 ? void 0 : _a2.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e) => {
    reject === null || reject === void 0 ? void 0 : reject(e);
  });
  return group2;
}
function destroy(options, context = {}, isDestroyCanvas = false) {
  const { canvas, emitter } = context;
  if (canvas) {
    destroyAllInteractions(canvas);
    isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
  }
  emitter.off();
}
function destroyAllInteractions(canvas) {
  const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
  viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group2) => {
    const { nameInteraction = /* @__PURE__ */ new Map() } = group2;
    if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
      Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
        value2 === null || value2 === void 0 ? void 0 : value2.destroy();
      });
    }
  });
}
function normalizeContainer(container) {
  return typeof container === "string" ? document.getElementById(container) : container;
}

// node_modules/@antv/g2/esm/utils/style.js
var defaultStyle = {
  visibility: "visible",
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1
};
function getStyle(element, key) {
  var _a;
  return (_a = element.style[key]) !== null && _a !== void 0 ? _a : defaultStyle[key];
}
function setStyle2(element, key, value2, recursive) {
  element.style[key] = value2;
  if (recursive) {
    element.children.forEach((child) => setStyle2(child, key, value2, recursive));
  }
}
function hide(element) {
  setStyle2(element, "visibility", "hidden", true);
}
function show(element) {
  setStyle2(element, "visibility", "visible", true);
}

// node_modules/@antv/g2/esm/interaction/utils.js
var __rest76 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function selectG2Elements(root) {
  return select(root).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d2) => !d2.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
  return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
  return viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
}
function selectPlotArea(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
function bboxOf(element) {
  if (element.tagName === "g")
    return element.getRenderBounds();
  const bounds = element.getGeometryBounds();
  const aabb = new AABB();
  aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
  return aabb;
}
function mousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const bbox = bboxOf(target);
  const { min: [x2, y2], max: [x12, y12] } = bbox;
  const isOutX = offsetX < x2 || offsetX > x12;
  const isOutY = offsetY < y2 || offsetY > y12;
  if (isOutX || isOutY)
    return null;
  return [offsetX - x2, offsetY - y2];
}
function brushMousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const [x2, y2, x12, y12] = boundsOfBrushArea(target);
  return [
    Math.min(x12, Math.max(x2, offsetX)) - x2,
    Math.min(y12, Math.max(y2, offsetY)) - y2
  ];
}
function boundsOfBrushArea(target) {
  const bbox = target.getRenderBounds();
  const { min: [x05, y05], max: [x12, y12] } = bbox;
  return [x05, y05, x12, y12];
}
function createColorKey(view) {
  return (element) => element.__data__.color;
}
function createXKey(view) {
  return (element) => element.__data__.x;
}
function createDatumof(view) {
  const views = Array.isArray(view) ? view : [view];
  const keyData = new Map(views.flatMap((view2) => {
    const marks = Array.from(view2.markState.keys());
    return marks.map((mark2) => [keyed(view2.key, mark2.key), mark2.data]);
  }));
  return (element) => {
    const { index: index2, markKey, viewKey } = element.__data__;
    const data = keyData.get(keyed(viewKey, markKey));
    return data[index2];
  };
}
function useState(style, valueof2 = (d2, element) => d2, setAttribute = (element, key, v) => element.setAttribute(key, v)) {
  const STATES = "__states__";
  const ORIGINAL = "__ordinal__";
  const updateState = (element) => {
    const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
    const stateStyle = states.reduce((mixedStyle, state) => Object.assign(Object.assign({}, mixedStyle), style[state]), original);
    if (Object.keys(stateStyle).length === 0)
      return;
    for (const [key, value2] of Object.entries(stateStyle)) {
      const currentValue = getStyle(element, key);
      const v = valueof2(value2, element);
      setAttribute(element, key, v);
      if (!(key in original))
        original[key] = currentValue;
    }
    element[ORIGINAL] = original;
  };
  const initState = (element) => {
    if (element[STATES])
      return;
    element[STATES] = [];
    return;
  };
  const setState = (element, ...states) => {
    initState(element);
    element[STATES] = [...states];
    updateState(element);
  };
  const removeState = (element, ...states) => {
    initState(element);
    for (const state of states) {
      const index2 = element[STATES].indexOf(state);
      if (index2 !== -1) {
        element[STATES].splice(index2, 1);
      }
    }
    updateState(element);
  };
  const hasState = (element, state) => {
    initState(element);
    return element[STATES].indexOf(state) !== -1;
  };
  return {
    setState,
    removeState,
    hasState
  };
}
function isEmptyObject(obj) {
  if (obj === void 0)
    return true;
  if (typeof obj !== "object")
    return false;
  return Object.keys(obj).length === 0;
}
function keyed(viewKey, markKey) {
  return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
  const views = Array.isArray(options) ? options : [options];
  const markState = views.flatMap((view) => view.marks.map((mark2) => [keyed(view.key, mark2.key), mark2.state]));
  const state = {};
  for (const descriptor of states) {
    const [key, defaults4] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
    state[key] = markState.reduce((merged, mark2) => {
      const [markKey, markState2 = {}] = mark2;
      const selectedState = isEmptyObject(markState2[key]) ? defaults4 : markState2[key];
      for (const [attr, value2] of Object.entries(selectedState)) {
        const oldValue = merged[attr];
        const newValue = (data, index2, array2, element) => {
          const k2 = keyed(element.__data__.viewKey, element.__data__.markKey);
          if (markKey !== k2)
            return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data, index2, array2, element);
          if (typeof value2 !== "function")
            return value2;
          return value2(data, index2, array2, element);
        };
        merged[attr] = newValue;
      }
      return merged;
    }, {});
  }
  return state;
}
function createValueof(elements, datum) {
  const elementIndex = new Map(elements.map((d2, i) => [d2, i]));
  const fa = datum ? elements.map(datum) : elements;
  return (d2, e) => {
    if (typeof d2 !== "function")
      return d2;
    const i = elementIndex.get(e);
    const fe = datum ? datum(e) : e;
    return d2(fe, i, fa, e);
  };
}
function renderLink(_a) {
  var { link: link3 = false, valueof: valueof2 = (d2, element) => d2, coordinate } = _a, style = __rest76(_a, ["link", "valueof", "coordinate"]);
  const LINK_CLASS_NAME = "element-link";
  if (!link3)
    return [() => {
    }, () => {
    }];
  const pointsOf = (element) => element.__data__.points;
  const pathPointsOf = (P0, P1) => {
    const [, p1, p2] = P0;
    const [p0, , , p3] = P1;
    const P = [p1, p0, p3, p2];
    return P;
  };
  const append3 = (elements) => {
    var _a2;
    if (elements.length <= 1)
      return;
    const sortedElements = sort(elements, (e0, e1) => {
      const { x: x05 } = e0.__data__;
      const { x: x12 } = e1.__data__;
      const dx = x05 - x12;
      return dx;
    });
    for (let i = 1; i < sortedElements.length; i++) {
      const p2 = path();
      const e0 = sortedElements[i - 1];
      const e1 = sortedElements[i];
      const [p0, p1, p22, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
      p2.moveTo(...p0);
      p2.lineTo(...p1);
      p2.lineTo(...p22);
      p2.lineTo(...p3);
      p2.closePath();
      const _b = mapObject(style, (d2) => valueof2(d2, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest76(_b, ["fill"]);
      const link4 = new Path({
        className: LINK_CLASS_NAME,
        style: Object.assign({ d: p2.toString(), fill, zIndex: -2 }, rest)
      });
      (_a2 = e0.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
      e0.parentNode.appendChild(link4);
      e0.link = link4;
    }
  };
  const remove2 = (element) => {
    var _a2;
    (_a2 = element.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
    element.link = null;
  };
  return [append3, remove2];
}
function offsetTransform(element, offset, coordinate) {
  const append3 = (t) => {
    const { transform } = element.style;
    return transform ? `${transform} ${t}` : t;
  };
  if (isPolar(coordinate)) {
    const { points } = element.__data__;
    const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
    const center2 = coordinate.getCenter();
    const v0 = sub(p0, center2);
    const v1 = sub(p1, center2);
    const a0 = angle(v0);
    const da = angleBetween(v0, v1);
    const amid = a0 + da / 2;
    const dx = offset * Math.cos(amid);
    const dy = offset * Math.sin(amid);
    return append3(`translate(${dx}, ${dy})`);
  }
  if (isTranspose(coordinate))
    return append3(`translate(${offset}, 0)`);
  return append3(`translate(0, ${-offset})`);
}
function renderBackground(_a) {
  var { document: document2, background, scale: scale3, coordinate, valueof: valueof2 } = _a, rest = __rest76(_a, ["document", "background", "scale", "coordinate", "valueof"]);
  const BACKGROUND_CLASS_NAME = "element-background";
  if (!background)
    return [() => {
    }, () => {
    }];
  const extentOf2 = (scale4, x2, padding) => {
    const ax = scale4.invert(x2);
    const mid2 = x2 + scale4.getBandWidth(ax) / 2;
    const half = scale4.getStep(ax) / 2;
    const offset = half * padding;
    return [mid2 - half + offset, mid2 + half - offset];
  };
  const sizeXOf = (element, padding) => {
    const { x: scaleX } = scale3;
    if (!isOrdinalScale(scaleX))
      return [0, 1];
    const { __data__: data } = element;
    const { x: x2 } = data;
    const [e1, e22] = extentOf2(scaleX, x2, padding);
    return [e1, e22];
  };
  const sizeYOf = (element, padding) => {
    const { y: scaleY } = scale3;
    if (!isOrdinalScale(scaleY))
      return [0, 1];
    const { __data__: data } = element;
    const { y: y2 } = data;
    const [e1, e22] = extentOf2(scaleY, y2, padding);
    return [e1, e22];
  };
  const bandShapeOf = (element, style) => {
    const { padding } = style;
    const [x12, x2] = sizeXOf(element, padding);
    const [y12, y2] = sizeYOf(element, padding);
    const points = [
      [x12, y12],
      [x2, y12],
      [x2, y2],
      [x12, y2]
    ].map((d2) => coordinate.map(d2));
    const { __data__: data } = element;
    const { y: dy, y1: dy1 } = data;
    return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
  };
  const cloneShapeOf = (element, style) => {
    const { transform = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest76(style, ["transform", "transformOrigin", "stroke"]);
    const finalStyle = Object.assign({ transform, transformOrigin, stroke: stroke2 }, rest2);
    const shape23 = element.cloneNode(true);
    for (const [key, value2] of Object.entries(finalStyle)) {
      shape23.style[key] = value2;
    }
    return shape23;
  };
  const isOrdinalShape = () => {
    const { x: x2, y: y2 } = scale3;
    return [x2, y2].some(isOrdinalScale);
  };
  const append3 = (element) => {
    if (element.background)
      element.background.remove();
    const _a2 = mapObject(rest, (d2) => valueof2(d2, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a2, style = __rest76(_a2, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
    const finalStyle = Object.assign(Object.assign({}, style), {
      fill,
      fillOpacity,
      zIndex,
      padding,
      lineWidth
    });
    const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
    const shape23 = shapeOf(element, finalStyle);
    shape23.className = BACKGROUND_CLASS_NAME;
    element.parentNode.parentNode.appendChild(shape23);
    element.background = shape23;
  };
  const remove2 = (element) => {
    var _a2;
    (_a2 = element.background) === null || _a2 === void 0 ? void 0 : _a2.remove();
    element.background = null;
  };
  const is = (element) => {
    return element.className === BACKGROUND_CLASS_NAME;
  };
  return [append3, remove2, is];
}
function setCursor(root, cursor) {
  const canvas = root.getRootNode().defaultView;
  const dom2 = canvas.getContextService().getDomElement();
  if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
    root.cursor = dom2.style.cursor;
    dom2.style.cursor = cursor;
  }
}
function restoreCursor(root) {
  setCursor(root, root.cursor);
}
function selectElementByData(elements, data, datum) {
  return elements.find((d2) => Object.entries(data).every(([key, value2]) => datum(d2)[key] === value2));
}
function getPointsR(point6, nextPoint) {
  return Math.sqrt(Math.pow(point6[0] - nextPoint[0], 2) + Math.pow(point6[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
  const path2 = filter_default(points, (d2) => !!d2).map((d2, i) => {
    return [i === 0 ? "M" : "L", ...d2];
  });
  if (isClose) {
    path2.push(["Z"]);
  }
  return path2;
}
function getElements(plot2) {
  return plot2.querySelectorAll(".element");
}
function getThetaPath(center2, points, isBig = 0) {
  const path2 = [["M", ...points[1]]];
  const innerRadius = getPointsR(center2, points[1]);
  const outerRadius = getPointsR(center2, points[0]);
  if (innerRadius === 0) {
    path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  } else {
    path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  }
  return path2;
}
function maybeRoot(node, rootOf) {
  if (rootOf(node))
    return node;
  let root = node.parent;
  while (root && !rootOf(root))
    root = root.parent;
  return root;
}

// node_modules/@antv/g2/esm/interaction/elementHighlight.js
var __rest77 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function elementHighlight(root, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d2) => d2,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  background = false,
  // draw background or not
  delay = 60,
  // delay to unhighlighted element
  scale: scale3,
  coordinate,
  emitter,
  state = {}
}) {
  var _a;
  const elements = elementsof(root);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    elements,
    valueof: valueof2,
    link: link3,
    coordinate
  }, subObject(state.active, "link")));
  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
    document: root.ownerDocument,
    scale: scale3,
    coordinate,
    background,
    valueof: valueof2
  }, subObject(state.active, "background")));
  const elementStyle = deep_mix_default(state, {
    active: Object.assign({}, ((_a = state.active) === null || _a === void 0 ? void 0 : _a.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.active.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  let out;
  const pointerover = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const k2 = groupKey(element);
    const group2 = keyGroup.get(k2);
    const groupSet = new Set(group2);
    for (const e of elements) {
      if (groupSet.has(e)) {
        if (!hasState(e, "active"))
          setState(e, "active");
      } else {
        setState(e, "inactive");
        removeLink(e);
      }
      if (e !== element)
        removeBackground(e);
    }
    appendBackground(element);
    appendLink(group2);
    if (!nativeEvent)
      return;
    emitter.emit("element:highlight", {
      nativeEvent,
      data: {
        data: datum(element),
        group: group2.map(datum)
      }
    });
  };
  const delayUnhighlighted = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      unhighlighted();
      out = null;
    }, delay);
  };
  const unhighlighted = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "active", "inactive");
      removeBackground(e);
      removeLink(e);
    }
    if (nativeEvent) {
      emitter.emit("element:unhighlight", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    const { target: element } = event;
    if (background && !isBackground(element))
      return;
    if (!background && !elementSet.has(element))
      return;
    if (delay > 0)
      delayUnhighlighted();
    else
      unhighlighted();
  };
  const pointerleave = () => {
    unhighlighted();
  };
  root.addEventListener("pointerover", pointerover);
  root.addEventListener("pointerout", pointerout);
  root.addEventListener("pointerleave", pointerleave);
  const onRest = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    unhighlighted(false);
  };
  const onHighlight = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    const { data } = e.data;
    const element = selectElementByData(elements, data, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:highlight", onHighlight);
  emitter.on("element:unhighlight", onRest);
  return () => {
    root.removeEventListener("pointerover", pointerover);
    root.removeEventListener("pointerout", pointerout);
    root.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:highlight", onHighlight);
    emitter.off("element:unhighlight", onRest);
    for (const e of elements) {
      removeBackground(e);
      removeLink(e);
    }
  };
}
function ElementHighlight(_a) {
  var { delay, createGroup, background = false, link: link3 = false } = _a, rest = __rest77(_a, ["delay", "createGroup", "background", "link"]);
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const { scale: scale3, coordinate } = view;
    const plotArea = selectPlotArea(container);
    return elementHighlight(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate,
      scale: scale3,
      state: mergeState(options, [
        ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "inactive"
      ]),
      background,
      link: link3,
      delay,
      emitter
    }, rest));
  };
}
ElementHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
function ElementHighlightByX(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementHighlightByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
function ElementHighlightByColor(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementHighlightByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelect.js
var __rest78 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function elementSelect(root, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d2) => d2,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  single = false,
  // single select or not
  coordinate,
  background = false,
  scale: scale3,
  emitter,
  state = {}
}) {
  var _a;
  const elements = elementsof(root);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    link: link3,
    elements,
    valueof: valueof2,
    coordinate
  }, subObject(state.selected, "link")));
  const [appendBackground, removeBackground] = renderBackground(Object.assign({
    document: root.ownerDocument,
    background,
    coordinate,
    scale: scale3,
    valueof: valueof2
  }, subObject(state.selected, "background")));
  const elementStyle = deep_mix_default(state, {
    selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.selected.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  const clear = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "selected", "unselected");
      removeLink(e);
      removeBackground(e);
    }
    if (nativeEvent)
      emitter.emit("element:unselect", { nativeEvent: true });
    return;
  };
  const singleSelect = (event, element, nativeEvent = true) => {
    if (hasState(element, "selected"))
      clear();
    else {
      const k2 = groupKey(element);
      const group2 = keyGroup.get(k2);
      const groupSet = new Set(group2);
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else {
          setState(e, "unselected");
          removeLink(e);
        }
        if (e !== element)
          removeBackground(e);
      }
      appendLink(group2);
      appendBackground(element);
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: [datum(element), ...group2.map(datum)]
      } }));
    }
  };
  const multipleSelect = (event, element, nativeEvent = true) => {
    const k2 = groupKey(element);
    const group2 = keyGroup.get(k2);
    const groupSet = new Set(group2);
    if (!hasState(element, "selected")) {
      const hasSelectedGroup = group2.some((e) => hasState(e, "selected"));
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else if (!hasState(e, "selected"))
          setState(e, "unselected");
      }
      if (!hasSelectedGroup && link3)
        appendLink(group2);
      appendBackground(element);
    } else {
      const hasSelected = elements.some((e) => !groupSet.has(e) && hasState(e, "selected"));
      if (!hasSelected)
        return clear();
      for (const e of group2) {
        setState(e, "unselected");
        removeLink(e);
        removeBackground(e);
      }
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
      data: elements.filter((e) => hasState(e, "selected")).map(datum)
    } }));
  };
  const click = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return clear();
    if (single)
      return singleSelect(event, element, nativeEvent);
    return multipleSelect(event, element, nativeEvent);
  };
  root.addEventListener("click", click);
  const onSelect = (e) => {
    const { nativeEvent, data } = e;
    if (nativeEvent)
      return;
    const selectedData = single ? data.data.slice(0, 1) : data.data;
    for (const d2 of selectedData) {
      const element = selectElementByData(elements, d2, datum);
      click({ target: element, nativeEvent: false });
    }
  };
  const onUnSelect = () => {
    clear(false);
  };
  emitter.on("element:select", onSelect);
  emitter.on("element:unselect", onUnSelect);
  return () => {
    for (const e of elements)
      removeLink(e);
    root.removeEventListener("click", click);
    emitter.off("element:select", onSelect);
    emitter.off("element:unselect", onUnSelect);
  };
}
function ElementSelect(_a) {
  var { createGroup, background = false, link: link3 = false } = _a, rest = __rest78(_a, ["createGroup", "background", "link"]);
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const { coordinate, scale: scale3 } = view;
    const plotArea = selectPlotArea(container);
    return elementSelect(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate,
      scale: scale3,
      state: mergeState(options, [
        ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "unselected"
      ]),
      background,
      link: link3,
      emitter
    }, rest));
  };
}
ElementSelect.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByX.js
function ElementSelectByX(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementSelectByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
function ElementSelectByColor(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementSelectByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/chartIndex.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest79 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function maybeTransform(options) {
  const { transform = [] } = options;
  const normalizeY = transform.find((d2) => d2.type === "normalizeY");
  if (normalizeY)
    return normalizeY;
  const newNormalizeY = { type: "normalizeY" };
  transform.push(newNormalizeY);
  options.transform = transform;
  return newNormalizeY;
}
function markValue2(markState, markName, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === markName).map(([mark2]) => {
    const { encode } = mark2;
    const channel = (name2) => {
      const channel2 = encode[name2];
      return [name2, channel2 ? channel2.value : void 0];
    };
    return Object.fromEntries(channels.map(channel));
  });
  return value2;
}
function ChartIndex(_a) {
  var { wait = 20, leading, trailing = false, labelFormatter = (date) => `${date}` } = _a, style = __rest79(_a, ["wait", "leading", "trailing", "labelFormatter"]);
  return (context) => {
    const { view, container, update, setState } = context;
    const { markState, scale: scale3, coordinate } = view;
    const value2 = markValue2(markState, "line", ["x", "y", "series"]);
    if (!value2)
      return;
    const { y: Y, x: X, series: S = [] } = value2;
    const I = Y.map((_, i) => i);
    const sortedX = sort(I.map((i) => X[i]));
    const plotArea = selectPlotArea(container);
    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
    const keyofLabel = (d2) => d2.__data__.key.split("-")[0];
    const keyLabels = group(labels, keyofLabel);
    const rule = new Line({
      style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
    });
    const text = new Text({
      style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
    });
    rule.append(text);
    plotArea.appendChild(rule);
    const dateByFocus = (coordinate2, scaleX, focus) => {
      const [normalizedX] = coordinate2.invert(focus);
      const date = scaleX.invert(normalizedX);
      return sortedX[bisectCenter(sortedX, date)];
    };
    const updateRule = (focus, date) => {
      rule.setAttribute("x1", focus[0]);
      rule.setAttribute("x2", focus[0]);
      text.setAttribute("text", labelFormatter(date));
    };
    let newView;
    const updateBasisByRerender = (focus) => __awaiter6(this, void 0, void 0, function* () {
      const { x: scaleX } = scale3;
      const date = dateByFocus(coordinate, scaleX, focus);
      updateRule(focus, date);
      setState("chartIndex", (options) => {
        const clonedOptions = deep_mix_default({}, options);
        const lineMark = clonedOptions.marks.find((d2) => d2.type === "line");
        const r = (I2) => max(I2, (i) => +Y[i]) / min(I2, (i) => +Y[i]);
        const k2 = max(rollup(I, r, (i) => S[i]).values());
        const domainY = [1 / k2, k2];
        deep_mix_default(lineMark, {
          scale: { y: { domain: domainY } }
        });
        const normalizeY = maybeTransform(lineMark);
        normalizeY.groupBy = "color";
        normalizeY.basis = (I2, Y3) => {
          const i = I2[bisector((i2) => X[+i2]).center(I2, date)];
          return Y3[i];
        };
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        return clonedOptions;
      });
      const newState = yield update("chartIndex");
      newView = newState.view;
    });
    const updateBasisByTranslate = (focus) => {
      const { scale: scale4, coordinate: coordinate2 } = newView;
      const { x: scaleX, y: scaleY } = scale4;
      const date = dateByFocus(coordinate2, scaleX, focus);
      updateRule(focus, date);
      for (const line3 of lines) {
        const { seriesIndex: SI, key } = line3.__data__;
        const i = SI[bisector((i2) => X[+i2]).center(SI, date)];
        const p0 = [0, scaleY.map(1)];
        const p1 = [0, scaleY.map(Y[i] / Y[SI[0]])];
        const [, y05] = coordinate2.map(p0);
        const [, y12] = coordinate2.map(p1);
        const dy = y05 - y12;
        line3.setAttribute("transform", `translate(0, ${dy})`);
        const labels2 = keyLabels.get(key) || [];
        for (const label of labels2) {
          label.setAttribute("dy", dy);
        }
      }
    };
    const updateBasis = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus)
        return;
      updateBasisByTranslate(focus);
    }, wait, { leading, trailing });
    updateBasisByRerender([0, 0]);
    plotArea.addEventListener("pointerenter", updateBasis);
    plotArea.addEventListener("pointermove", updateBasis);
    plotArea.addEventListener("pointerleave", updateBasis);
    return () => {
      rule.remove();
      plotArea.removeEventListener("pointerenter", updateBasis);
      plotArea.removeEventListener("pointermove", updateBasis);
      plotArea.removeEventListener("pointerleave", updateBasis);
    };
  };
}
ChartIndex.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/fisheye.js
function maybeCoordinate(options) {
  const { coordinate = {} } = options;
  const { transform = [] } = coordinate;
  const fisheye2 = transform.find((d2) => d2.type === "fisheye");
  if (fisheye2)
    return fisheye2;
  const newFisheye = { type: "fisheye" };
  transform.push(newFisheye);
  coordinate.transform = transform;
  options.coordinate = coordinate;
  return newFisheye;
}
function Fisheye2({ wait = 30, leading, trailing = false }) {
  return (context) => {
    const { options, update, setState, container } = context;
    const plotArea = selectPlotArea(container);
    const updateFocus = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus) {
        setState("fisheye");
        update();
        return;
      }
      setState("fisheye", (options2) => {
        const clonedOptions = deep_mix_default({}, options2, {
          interaction: { tooltip: { preserve: true } }
        });
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        const [x2, y2] = focus;
        const fisheye2 = maybeCoordinate(clonedOptions);
        fisheye2.focusX = x2;
        fisheye2.focusY = y2;
        fisheye2.visual = true;
        return clonedOptions;
      });
      update();
    }, wait, { leading, trailing });
    plotArea.addEventListener("pointerenter", updateFocus);
    plotArea.addEventListener("pointermove", updateFocus);
    plotArea.addEventListener("pointerleave", updateFocus);
    return () => {
      plotArea.removeEventListener("pointerenter", updateFocus);
      plotArea.removeEventListener("pointermove", updateFocus);
      plotArea.removeEventListener("pointerleave", updateFocus);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/tooltip.js
var __rest80 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getContainer(group2, mount) {
  if (mount) {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  }
  const canvas = group2.ownerDocument.defaultView.getContextService().getDomElement();
  return canvas.parentElement;
}
function getBounding(root) {
  const bbox = root.getRenderBounds();
  const { min: [x12, y12], max: [x2, y2] } = bbox;
  return {
    x: x12,
    y: y12,
    width: x2 - x12,
    height: y2 - y12
  };
}
function getContainerOffset(container1, container2) {
  const r1 = container1.getBoundingClientRect();
  const r2 = container2.getBoundingClientRect();
  return {
    x: r1.x - r2.x,
    y: r1.y - r2.y
  };
}
function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css = {}, offset = [10, 10]) {
  const defaults4 = {
    ".g2-tooltip": {},
    ".g2-tooltip-title": {
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }
  };
  const tooltipElement = new Tooltip({
    className: "tooltip",
    style: {
      x: x05,
      y: y05,
      container: containerOffset,
      data: [],
      bounding,
      position,
      enterable,
      title: "",
      offset,
      template: {
        prefixCls: "g2-"
      },
      style: deep_mix_default(defaults4, css)
    }
  });
  container.appendChild(tooltipElement.HTMLTooltipElement);
  return tooltipElement;
}
function showTooltip({ root, data, x: x2, y: y2, render: render2, event, single, position = "right-bottom", enterable = false, css, mount, bounding, offset }) {
  const container = getContainer(root, mount);
  const canvasContainer = getContainer(root);
  const parent = single ? canvasContainer : root;
  const b = bounding || getBounding(root);
  const containerOffset = getContainerOffset(canvasContainer, container);
  const { tooltipElement = createTooltip(container, x2, y2, position, enterable, b, containerOffset, css, offset) } = parent;
  const { items, title = "" } = data;
  tooltipElement.update(Object.assign({
    x: x2,
    y: y2,
    data: items,
    title,
    position,
    enterable,
    container: containerOffset
  }, render2 !== void 0 && {
    content: render2(event, { items, title })
  }));
  parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root, single, emitter, nativeEvent = true, event = null }) {
  if (nativeEvent) {
    emitter.emit("tooltip:hide", { nativeEvent });
  }
  const container = getContainer(root);
  const parent = single ? container : root;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
  }
  hideRuleY(root);
  hideRuleX(root);
  hideMarker(root);
}
function destroyTooltip({ root, single }) {
  const container = getContainer(root);
  const parent = single ? container : root;
  if (!parent)
    return;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.destroy();
    parent.tooltipElement = void 0;
  }
  hideRuleY(root);
  hideRuleX(root);
  hideMarker(root);
}
function showUndefined(item) {
  const { value: value2 } = item;
  return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
}
function singleItem(element) {
  const { __data__: datum } = element;
  const { title, items = [] } = datum;
  const newItems = items.filter(defined).map((_a) => {
    var { color: color2 = itemColorOf(element) } = _a, item = __rest80(_a, ["color"]);
    return Object.assign(Object.assign({}, item), { color: color2 });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, title && { title }), { items: newItems });
}
function groupNameOf(scale3, datum) {
  const { color: scaleColor, series: scaleSeries, facet = false } = scale3;
  const { color: color2, series } = datum;
  const invertAble = (scale4) => {
    return scale4 && scale4.invert && !(scale4 instanceof Band) && !(scale4 instanceof Constant);
  };
  if (invertAble(scaleSeries)) {
    const cloned = scaleSeries.clone();
    return cloned.invert(series);
  }
  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color2 && !facet) {
    return scaleSeries.invert(series);
  }
  if (invertAble(scaleColor)) {
    const name2 = scaleColor.invert(color2);
    if (Array.isArray(name2))
      return null;
    return name2;
  }
  return null;
}
function itemColorOf(element) {
  const fill = element.getAttribute("fill");
  const stroke2 = element.getAttribute("stroke");
  const { __data__: datum } = element;
  const { color: color2 = fill && fill !== "transparent" ? fill : stroke2 } = datum;
  return color2;
}
function unique2(items, key = (d2) => d2) {
  const valueName = new Map(items.map((d2) => [key(d2), d2]));
  return Array.from(valueName.values());
}
function groupItems(elements, scale3, groupName, data = elements.map((d2) => d2["__data__"]), theme = {}) {
  const key = (d2) => d2 instanceof Date ? +d2 : d2;
  const T = unique2(data.map((d2) => d2.title), key).filter(defined);
  const newItems = data.flatMap((datum, i) => {
    const element = elements[i];
    const { items = [], title } = datum;
    const definedItems = items.filter(defined);
    const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
    return definedItems.map((_a) => {
      var { color: color2 = itemColorOf(element) || theme.color, name: name2 } = _a, item = __rest80(_a, ["color", "name"]);
      const groupName2 = groupNameOf(scale3, datum);
      const name1 = useGroupName ? groupName2 || name2 : name2 || groupName2;
      return Object.assign(Object.assign({}, item), { color: color2, name: name1 || title });
    });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, T.length > 0 && { title: T.join(",") }), { items: unique2(newItems, (d2) => `(${key(d2.name)}, ${key(d2.value)}, ${key(d2.color)})`) });
}
function updateRuleX(root, points, mouse, _a) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a, rest = __rest80(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const createCircle = (cx, cy, r) => {
    const circle2 = new Circle({
      style: Object.assign({
        cx,
        cy,
        r
      }, defaults4)
    });
    root.appendChild(circle2);
    return circle2;
  };
  const createLine = (x12, x2, y12, y2) => {
    const line3 = new Line({
      style: Object.assign({
        x1: x12,
        x2,
        y1: y12,
        y2
      }, defaults4)
    });
    root.appendChild(line3);
    return line3;
  };
  const minDistPoint = (mouse2, points2) => {
    if (points2.length === 1) {
      return points2[0];
    }
    const dists = points2.map((p2) => dist(p2, mouse2));
    const minDistIndex = minIndex(dists, (d2) => d2);
    return points2[minDistIndex];
  };
  const target = minDistPoint(mouse, points);
  const pointsOf = () => {
    if (transposed)
      return [
        startX + target[0],
        startX + target[0],
        startY,
        startY + plotHeight
      ];
    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
  };
  const pointsOfPolar = () => {
    const cx = startX + insetLeft + mainWidth / 2;
    const cy = startY + insetTop + mainHeight / 2;
    const cdist = dist([cx, cy], target);
    return [cx, cy, cdist];
  };
  if (polar2) {
    const [cx, cy, r] = pointsOfPolar();
    const ruleX = root.ruleX || createCircle(cx, cy, r);
    ruleX.style.cx = cx;
    ruleX.style.cy = cy;
    ruleX.style.r = r;
    root.ruleX = ruleX;
  } else {
    const [x12, x2, y12, y2] = pointsOf();
    const ruleX = root.ruleX || createLine(x12, x2, y12, y2);
    ruleX.style.x1 = x12;
    ruleX.style.x2 = x2;
    ruleX.style.y1 = y12;
    ruleX.style.y2 = y2;
    root.ruleX = ruleX;
  }
}
function updateRuleY(root, points, _a) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a, rest = __rest80(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const Y = points.map((p2) => p2[1]);
  const X = points.map((p2) => p2[0]);
  const y2 = mean(Y);
  const x2 = mean(X);
  const pointsOf = () => {
    if (polar2) {
      const r = Math.min(mainWidth, mainHeight) / 2;
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const a3 = angle(sub([x2, y2], [cx, cy]));
      const x05 = cx + r * Math.cos(a3);
      const y05 = cy + r * Math.sin(a3);
      return [cx, x05, cy, y05];
    }
    if (transposed)
      return [startX, startX + plotWidth, y2 + startY, y2 + startY];
    return [x2 + startX, x2 + startX, startY, startY + plotHeight];
  };
  const [x12, x22, y12, y22] = pointsOf();
  const createLine = () => {
    const line3 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root.appendChild(line3);
    return line3;
  };
  if (X.length > 0) {
    const ruleY = root.ruleY || createLine();
    ruleY.style.x1 = x12;
    ruleY.style.x2 = x22;
    ruleY.style.y1 = y12;
    ruleY.style.y2 = y22;
    root.ruleY = ruleY;
  }
}
function hideRuleY(root) {
  if (root.ruleY) {
    root.ruleY.remove();
    root.ruleY = void 0;
  }
}
function hideRuleX(root) {
  if (root.ruleX) {
    root.ruleX.remove();
    root.ruleX = void 0;
  }
}
function updateMarker(root, { data, style, theme }) {
  if (root.markers)
    root.markers.forEach((d2) => d2.remove());
  const { type = "" } = style;
  const markers = data.filter((d2) => {
    const [{ x: x2, y: y2 }] = d2;
    return defined(x2) && defined(y2);
  }).map((d2) => {
    const [{ color: color2, element }, point6] = d2;
    const originColor = color2 || // encode value
    element.style.fill || element.style.stroke || theme.color;
    const fill = type === "hollow" ? "transparent" : originColor;
    const stroke2 = type === "hollow" ? originColor : "#fff";
    const shape23 = new Circle({
      className: "g2-tooltip-marker",
      style: Object.assign({ cx: point6[0], cy: point6[1], fill, r: 4, stroke: stroke2, lineWidth: 2 }, style)
    });
    return shape23;
  });
  for (const marker of markers)
    root.appendChild(marker);
  root.markers = markers;
}
function hideMarker(root) {
  if (root.markers) {
    root.markers.forEach((d2) => d2.remove());
    root.markers = [];
  }
}
function interactionKeyof(markState, key) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d2) => {
      var _a;
      return (_a = d2.interaction) === null || _a === void 0 ? void 0 : _a[key];
    }
  );
}
function maybeValue(specified, defaults4) {
  return specified === void 0 ? defaults4 : specified;
}
function isEmptyTooltipData(data) {
  const { title, items } = data;
  if (items.length === 0 && title === void 0)
    return true;
  return false;
}
function hasSeries(markState) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d2) => {
      var _a;
      return ((_a = d2.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d2.tooltip;
    }
  );
}
function seriesTooltip(root, _a) {
  var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale3, coordinate, crosshairs, crosshairsX, crosshairsY, render: render2, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {} } = _a, rest = __rest80(_a, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css"]);
  const elements = elementsof(root);
  const transposed = isTranspose(coordinate);
  const polar2 = isPolar(coordinate);
  const style = deep_mix_default(_style, rest);
  const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
  const seriesElements = [];
  const itemElements = [];
  for (const element of elements) {
    const { __data__: data } = element;
    const { seriesX, title, items } = data;
    if (seriesX)
      seriesElements.push(element);
    else if (title || items)
      itemElements.push(element);
  }
  const inInterval = (d2) => d2.markType === "interval";
  const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
  const xof = (d2) => d2.__data__.x;
  const isBandScale = !!scale3.x.getBandWidth;
  const closest = isBandScale && itemElements.length > 0;
  seriesElements.sort((a3, b) => {
    const index2 = transposed ? 0 : 1;
    const minY = (d2) => d2.getBounds().min[index2];
    return transposed ? minY(b) - minY(a3) : minY(a3) - minY(b);
  });
  const extent2 = (d2) => {
    const index2 = transposed ? 1 : 0;
    const { min: min6, max: max6 } = d2.getLocalBounds();
    return sort([min6[index2], max6[index2]]);
  };
  if (isBar)
    elements.sort((a3, b) => xof(a3) - xof(b));
  else {
    itemElements.sort((a3, b) => {
      const [minA, maxA] = extent2(a3);
      const [minB, maxB] = extent2(b);
      const midA = (minA + maxA) / 2;
      const midB = (minB + maxB) / 2;
      return transposed ? midB - midA : midA - midB;
    });
  }
  const elementSortedX = new Map(seriesElements.map((element) => {
    const { __data__: data } = element;
    const { seriesX } = data;
    const seriesIndex = seriesX.map((_, i) => i);
    const sortedIndex = sort(seriesIndex, (i) => seriesX[+i]);
    return [element, [sortedIndex, seriesX]];
  }));
  const { x: scaleX } = scale3;
  const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
  const abstractX = (focus) => {
    const [normalizedX] = coordinate.invert(focus);
    return normalizedX - offsetX;
  };
  const indexByFocus = (event, focus, I, X) => {
    const { _x } = event;
    const finalX = _x !== void 0 ? scaleX.map(_x) : abstractX(focus);
    const DX = X.filter(defined);
    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);
    const isOnlyOneElement = minX === maxX;
    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
      return null;
    const search = bisector((i2) => X[+i2]).center;
    const i = search(I, finalX);
    return I[i];
  };
  const elementsByFocus = isBar ? (focus, elements2) => {
    const search = bisector(xof).center;
    const i = search(elements2, abstractX(focus));
    const find2 = elements2[i];
    const groups2 = group(elements2, xof);
    const selected = groups2.get(xof(find2));
    return selected;
  } : (focus, elements2) => {
    const index2 = transposed ? 1 : 0;
    const x2 = focus[index2];
    const filtered = elements2.filter((element) => {
      const [min6, max6] = extent2(element);
      return x2 >= min6 && x2 <= max6;
    });
    if (!closest || filtered.length > 0)
      return filtered;
    const search = bisector((element) => {
      const [min6, max6] = extent2(element);
      return (min6 + max6) / 2;
    }).center;
    const i = search(elements2, x2);
    return [elements2[i]].filter(defined);
  };
  const seriesData = (element, index2) => {
    const { __data__: data } = element;
    return Object.fromEntries(Object.entries(data).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
      const d2 = V[index2];
      return [lower_first_default(key.replace("series", "")), d2];
    }));
  };
  const update = throttle_default((event) => {
    var _a2;
    const mouse = mousePosition(root, event);
    if (!mouse)
      return;
    const bbox = bboxOf(root);
    const x2 = bbox.min[0];
    const y2 = bbox.min[1];
    const focus = [mouse[0] - startX, mouse[1] - startY];
    if (!focus)
      return;
    const selectedItems = elementsByFocus(focus, itemElements);
    const selectedSeriesElements = [];
    const selectedSeriesData = [];
    for (const element of seriesElements) {
      const [sortedIndex, X] = elementSortedX.get(element);
      const index2 = indexByFocus(event, focus, sortedIndex, X);
      if (index2 !== null) {
        selectedSeriesElements.push(element);
        const d2 = seriesData(element, index2);
        const { x: x3, y: y3 } = d2;
        const p2 = coordinate.map([(x3 || 0) + offsetX, y3 || 0]);
        selectedSeriesData.push([Object.assign(Object.assign({}, d2), { element }), p2]);
      }
    }
    const SX = Array.from(new Set(selectedSeriesData.map((d2) => d2[0].x)));
    const closestX = SX[minIndex(SX, (x3) => Math.abs(x3 - abstractX(focus)))];
    const filteredSeriesData = selectedSeriesData.filter((d2) => d2[0].x === closestX);
    const selectedData = [
      ...filteredSeriesData.map((d2) => d2[0]),
      ...selectedItems.map((d2) => d2.__data__)
    ];
    const selectedElements = [...selectedSeriesElements, ...selectedItems];
    const tooltipData = groupItems(selectedElements, scale3, groupName, selectedData, theme);
    if (sortFunction) {
      tooltipData.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
    }
    if (filterFunction) {
      tooltipData.items = tooltipData.items.filter(filterFunction);
    }
    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
      hide2(event);
      return;
    }
    if (body) {
      showTooltip({
        root,
        data: tooltipData,
        x: mouse[0] + x2,
        y: mouse[1] + y2,
        render: render2,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset
      });
    }
    if (crosshairs || crosshairsX || crosshairsY) {
      const ruleStyle = subObject(style, "crosshairs");
      const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
      const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
      const points = filteredSeriesData.map((d2) => d2[1]);
      if (crosshairsX) {
        updateRuleX(root, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
      if (crosshairsY) {
        updateRuleY(root, points, Object.assign(Object.assign({}, ruleStyleY), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
    }
    if (marker) {
      const markerStyles = subObject(style, "marker");
      updateMarker(root, {
        data: filteredSeriesData,
        style: markerStyles,
        theme
      });
    }
    const firstX = (_a2 = filteredSeriesData[0]) === null || _a2 === void 0 ? void 0 : _a2[0].x;
    const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, tooltipData), { data: { x: invert(scale3.x, transformedX, true) } }) }));
  }, wait, { leading, trailing });
  const hide2 = (event) => {
    hideTooltip({ root, single, emitter, event });
  };
  const destroy2 = () => {
    destroyTooltip({ root, single });
  };
  const onTooltipShow = (_a2) => {
    var _b;
    var { nativeEvent, data, offsetX: offsetX2, offsetY } = _a2, rest2 = __rest80(_a2, ["nativeEvent", "data", "offsetX", "offsetY"]);
    if (nativeEvent)
      return;
    const x2 = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.x;
    const scaleX2 = scale3.x;
    const x12 = scaleX2.map(x2);
    const [x22, y2] = coordinate.map([x12, 0.5]);
    const rootBounds = root.getRenderBounds();
    const minX = rootBounds.min[0];
    const minY = rootBounds.min[1];
    update(Object.assign(Object.assign({}, rest2), { offsetX: offsetX2 !== void 0 ? offsetX2 : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y2, _x: x2 }));
  };
  const onTooltipHide = () => {
    hideTooltip({ root, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroy2();
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root.addEventListener("pointerenter", update);
      root.addEventListener("pointermove", update);
      root.addEventListener("pointerleave", (e) => {
        if (mousePosition(root, e))
          return;
        hide2(e);
      });
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root.removeEventListener("pointerenter", update);
      root.removeEventListener("pointermove", update);
      root.removeEventListener("pointerleave", hide2);
    }
  };
  addEventListeners();
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:disable", onTooltipDisable);
  emitter.on("tooltip:enable", onTooltipEnable);
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:disable", onTooltipDisable);
    emitter.off("tooltip:enable", onTooltipEnable);
    if (preserve) {
      hideTooltip({ root, single, emitter, nativeEvent: false });
    } else {
      destroy2();
    }
  };
}
function tooltip(root, {
  elements: elementsof,
  coordinate,
  scale: scale3,
  render: render2,
  groupName,
  sort: sortFunction,
  filter: filterFunction,
  emitter,
  wait = 50,
  leading = true,
  trailing = false,
  groupKey = (d2) => d2,
  // group elements by specified key
  single = true,
  position,
  enterable,
  datum,
  view,
  mount,
  bounding,
  theme,
  offset,
  shared = false,
  body = true,
  disableNative = false,
  preserve = false,
  css = {}
}) {
  var _a, _b;
  const elements = elementsof(root);
  const keyGroup = group(elements, groupKey);
  const inInterval = (d2) => d2.markType === "interval";
  const isBar = elements.every(inInterval) && !isPolar(coordinate);
  const scaleX = scale3.x;
  const scaleSeries = scale3.series;
  const bandWidth3 = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
  const xof = scaleSeries ? (d2) => {
    const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
    return d2.__data__.x + d2.__data__.series * bandWidth3 + bandWidth3 / (seriesCount * 2);
  } : (d2) => d2.__data__.x + bandWidth3 / 2;
  if (isBar)
    elements.sort((a3, b) => xof(a3) - xof(b));
  const findElementByTarget = (event) => {
    const { target } = event;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      return node.classList.includes("element");
    });
  };
  const findElement = isBar ? (event) => {
    const mouse = mousePosition(root, event);
    if (!mouse)
      return;
    const [abstractX] = coordinate.invert(mouse);
    const search = bisector(xof).center;
    const i = search(elements, abstractX);
    const target = elements[i];
    if (!shared) {
      const isGrouped = elements.find((d2) => d2 !== target && xof(d2) === xof(target));
      if (isGrouped)
        return findElementByTarget(event);
    }
    return target;
  } : findElementByTarget;
  const pointermove = throttle_default((event) => {
    const element = findElement(event);
    if (!element) {
      hideTooltip({ root, single, emitter, event });
      return;
    }
    const k2 = groupKey(element);
    const group2 = keyGroup.get(k2);
    if (!group2) {
      return;
    }
    const data = group2.length === 1 && !shared ? singleItem(group2[0]) : groupItems(group2, scale3, groupName, void 0, theme);
    if (sortFunction) {
      data.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
    }
    if (filterFunction) {
      data.items = data.items.filter(filterFunction);
    }
    if (isEmptyTooltipData(data)) {
      hideTooltip({ root, single, emitter, event });
      return;
    }
    const { offsetX, offsetY } = event;
    if (body) {
      showTooltip({
        root,
        data,
        x: offsetX,
        y: offsetY,
        render: render2,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, data), { data: dataOf(element, view) }) }));
  }, wait, { leading, trailing });
  const pointerleave = (event) => {
    hideTooltip({ root, single, emitter, event });
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root.addEventListener("pointermove", pointermove);
      root.addEventListener("pointerleave", pointerleave);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root.removeEventListener("pointermove", pointermove);
      root.removeEventListener("pointerleave", pointerleave);
    }
  };
  const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
    if (nativeEvent)
      return;
    const { data } = raw;
    const element = selectElementByData(elements, data, datum);
    if (!element)
      return;
    const bbox = element.getBBox();
    const { x: x2, y: y2, width, height } = bbox;
    const rootBBox = root.getBBox();
    pointermove({
      target: element,
      offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x2 + width / 2,
      offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y2 + height / 2
    });
  };
  const onTooltipHide = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    hideTooltip({ root, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroyTooltip({ root, single });
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:enable", onTooltipEnable);
  emitter.on("tooltip:disable", onTooltipDisable);
  addEventListeners();
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    if (preserve) {
      hideTooltip({ root, single, emitter, nativeEvent: false });
    } else {
      destroyTooltip({ root, single });
    }
  };
}
function Tooltip2(options) {
  const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest80(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
  return (target, viewInstances, emitter) => {
    const { container, view } = target;
    const { scale: scale3, markState, coordinate, theme } = view;
    const defaultSeries = interactionKeyof(markState, "seriesTooltip");
    const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
    const plotArea = selectPlotArea(container);
    const isSeries = maybeValue(series, defaultSeries);
    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
    if (isSeries && hasSeries(markState) && !facet) {
      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
        theme,
        elements: selectG2Elements,
        scale: scale3,
        coordinate,
        crosshairs: crosshairsSetting,
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        // crosshairsY default depend on the crossharisSettings
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        emitter
      }));
    }
    if (isSeries && facet) {
      const facetInstances = viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
      const elements = selectFacetG2Elements(target, viewInstances);
      const scale4 = facetInstances[0].view.scale;
      const bbox = plotArea.getBounds();
      const startX = bbox.min[0];
      const startY = bbox.min[1];
      Object.assign(scale4, { facet: true });
      return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
        theme,
        elements: () => elements,
        scale: scale4,
        coordinate,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        startX,
        startY,
        emitter
      }));
    }
    return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
      datum: createDatumof(view),
      elements: selectG2Elements,
      scale: scale3,
      coordinate,
      groupKey: shared ? createXKey(view) : void 0,
      item,
      emitter,
      view,
      theme,
      shared
    }));
  };
}
Tooltip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/legendFilter.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
var LEGEND_ITEMS_CLASS_NAME = "items-item";
var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
function markerOf(item) {
  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function itemsOf(root) {
  return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root) {
  return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root) {
  return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root, setState) {
  const legends = [...legendsOf(root), ...legendsContinuousOf(root)];
  legends.forEach((legend) => {
    setState(legend, (v) => v);
  });
}
function dataOf2(root) {
  let parent = root.parentNode;
  while (parent && !parent.__data__) {
    parent = parent.parentNode;
  }
  return parent.__data__;
}
function legendFilterOrdinal(root, {
  legends,
  // given the root of chart returns legends to be manipulated
  marker: markerOf2,
  // given the legend returns the marker
  label: labelOf2,
  // given the legend returns the label
  datum,
  // given the legend returns the value
  filter: filter2,
  // invoke when dispatch filter event,
  emitter,
  channel,
  state = {}
  // state options
}) {
  const itemClick = /* @__PURE__ */ new Map();
  const itemPointerenter = /* @__PURE__ */ new Map();
  const itemPointerout = /* @__PURE__ */ new Map();
  const { unselected = {
    markerStroke: "#aaa",
    markerFill: "#aaa",
    labelFill: "#aaa"
  } } = state;
  const markerStyle = { unselected: subObject(unselected, "marker") };
  const labelStyle = { unselected: subObject(unselected, "label") };
  const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
  const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
  const items = Array.from(legends(root));
  let selectedValues = items.map(datum);
  const updateLegendState = () => {
    for (const item of items) {
      const value2 = datum(item);
      const marker = markerOf2(item);
      const label = labelOf2(item);
      if (!selectedValues.includes(value2)) {
        setM(marker, "unselected");
        setL(label, "unselected");
      } else {
        removeM(marker, "unselected");
        removeL(label, "unselected");
      }
    }
  };
  for (const item of items) {
    const pointerenter = () => {
      setCursor(root, "pointer");
    };
    const pointerout = () => {
      restoreCursor(root);
    };
    const click = (event) => __awaiter7(this, void 0, void 0, function* () {
      const value2 = datum(item);
      const index2 = selectedValues.indexOf(value2);
      if (index2 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index2, 1);
      yield filter2(selectedValues);
      updateLegendState();
      const { nativeEvent = true } = event;
      if (!nativeEvent)
        return;
      if (selectedValues.length === items.length) {
        emitter.emit("legend:reset", { nativeEvent });
      } else {
        emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          channel,
          values: selectedValues
        } }));
      }
    });
    item.addEventListener("click", click);
    item.addEventListener("pointerenter", pointerenter);
    item.addEventListener("pointerout", pointerout);
    itemClick.set(item, click);
    itemPointerenter.set(item, pointerenter);
    itemPointerout.set(item, pointerout);
  }
  const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data } = event;
    const { channel: specifiedChannel, values: values3 } = data;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values3;
    yield filter2(selectedValues);
    updateLegendState();
  });
  const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = items.map(datum);
    yield filter2(selectedValues);
    updateLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:reset", onEnd);
  return () => {
    for (const item of items) {
      item.removeEventListener("click", itemClick.get(item));
      item.removeEventListener("pointerenter", itemPointerenter.get(item));
      item.removeEventListener("pointerout", itemPointerout.get(item));
      emitter.off("legend:filter", onFilter);
      emitter.off("legend:reset", onEnd);
    }
  };
}
function legendFilterContinuous(_, { legend, filter: filter2, emitter, channel }) {
  const onValueChange = ({ detail: { value: value2 } }) => {
    filter2(value2);
    emitter.emit({
      nativeEvent: true,
      data: {
        channel,
        values: value2
      }
    });
  };
  legend.addEventListener("valuechange", onValueChange);
  return () => {
    legend.removeEventListener("valuechange", onValueChange);
  };
}
function filterView(context, {
  legend,
  // Legend instance.
  channel,
  // Filter Channel.
  value: value2,
  // Filtered Values.
  ordinal,
  // Data type of the legend.
  channels,
  // Channels for this legend.
  allChannels,
  // Channels for all legends.
  facet = false
  // For facet.
}) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { view, update, setState } = context;
    setState(legend, (viewOptions) => {
      const { marks } = viewOptions;
      const newMarks = marks.map((mark2) => {
        if (mark2.type === "legends")
          return mark2;
        const { transform = [], data = [] } = mark2;
        const index2 = transform.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
        const newTransform = [...transform];
        if (data.length) {
          newTransform.splice(index2 + 1, 0, {
            type: "filter",
            [channel]: { value: value2, ordinal }
          });
        }
        const newScale = Object.fromEntries(channels.map((channel2) => [
          channel2,
          { domain: view.scale[channel2].getOptions().domain }
        ]));
        return deep_mix_default({}, mark2, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d2) => [d2, { preserve: true }])) }));
      });
      return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
    });
    yield update();
  });
}
function filterFacets(facets, options) {
  for (const facet of facets) {
    filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
  }
}
function LegendFilter() {
  return (context, contexts, emitter) => {
    const { container } = context;
    const facets = contexts.filter((d2) => d2 !== context);
    const isFacet = facets.length > 0;
    const channelsOf = (legend) => {
      return dataOf2(legend).scales.map((d2) => d2.name);
    };
    const legends = [
      ...legendsOf(container),
      ...legendsContinuousOf(container)
    ];
    const allChannels = legends.flatMap(channelsOf);
    const filter2 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
    const removes = legends.map((legend) => {
      const { name: channel, domain } = dataOf2(legend).scales[0];
      const channels = channelsOf(legend);
      const common = {
        legend,
        channel,
        channels,
        allChannels
      };
      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
        return legendFilterOrdinal(container, {
          legends: itemsOf,
          marker: markerOf,
          label: labelOf,
          datum: (d2) => {
            const { __data__: datum } = d2;
            const { index: index2 } = datum;
            return domain[index2];
          },
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter2(facets, options);
            else
              filter2(context, options);
          },
          state: legend.attributes.state,
          channel,
          emitter
        });
      } else {
        return legendFilterContinuous(container, {
          legend,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
            if (isFacet)
              filter2(facets, options);
            else
              filter2(context, options);
          },
          emitter,
          channel
        });
      }
    });
    return () => {
      removes.forEach((remove2) => remove2());
    };
  };
}

// node_modules/@antv/g2/esm/interaction/legendHighlight.js
function LegendHighlight() {
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const legends = legendsOf(container);
    const elements = selectG2Elements(container);
    const channelOf = (legend) => {
      return dataOf2(legend).scales[0].name;
    };
    const scaleOf2 = (channel) => {
      const { scale: { [channel]: scale3 } } = view;
      return scale3;
    };
    const markState = mergeState(options, ["active", "inactive"]);
    const valueof2 = createValueof(elements, createDatumof(view));
    const destroys = [];
    for (const legend of legends) {
      const datumOf = (item) => {
        const { data } = legend.attributes;
        const { __data__: datum } = item;
        const { index: index2 } = datum;
        return data[index2].label;
      };
      const channel = channelOf(legend);
      const items = itemsOf(legend);
      const scale3 = scaleOf2(channel);
      const elementGroup = group(elements, (d2) => scale3.invert(d2.__data__[channel]));
      const { state: legendState = {} } = legend.attributes;
      const { inactive = {} } = legendState;
      const { setState, removeState } = useState(markState, valueof2);
      const markerStyle = { inactive: subObject(inactive, "marker") };
      const labelStyle = { inactive: subObject(inactive, "label") };
      const { setState: setM, removeState: removeM } = useState(markerStyle);
      const { setState: setL, removeState: removeL } = useState(labelStyle);
      const updateLegendState = (highlight) => {
        for (const item of items) {
          const marker = markerOf(item);
          const label = labelOf(item);
          if (item === highlight || highlight === null) {
            removeM(marker, "inactive");
            removeL(label, "inactive");
          } else {
            setM(marker, "inactive");
            setL(label, "inactive");
          }
        }
      };
      const highlightItem = (event, item) => {
        const value2 = datumOf(item);
        const elementSet = new Set(elementGroup.get(value2));
        for (const e of elements) {
          if (elementSet.has(e))
            setState(e, "active");
          else
            setState(e, "inactive");
        }
        updateLegendState(item);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
      };
      const itemPointerover = /* @__PURE__ */ new Map();
      for (const item of items) {
        const pointerover = (event) => {
          highlightItem(event, item);
        };
        item.addEventListener("pointerover", pointerover);
        itemPointerover.set(item, pointerover);
      }
      const pointerleave = (event) => {
        for (const e of elements)
          removeState(e, "inactive", "active");
        updateLegendState(null);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:unhighlight", { nativeEvent });
      };
      const onHighlight = (event) => {
        const { nativeEvent, data } = event;
        if (nativeEvent)
          return;
        const { channel: specifiedChannel, value: value2 } = data;
        if (specifiedChannel !== channel)
          return;
        const item = items.find((d2) => datumOf(d2) === value2);
        if (!item)
          return;
        highlightItem({ nativeEvent: false }, item);
      };
      const onUnHighlight = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        pointerleave({ nativeEvent: false });
      };
      legend.addEventListener("pointerleave", pointerleave);
      emitter.on("legend:highlight", onHighlight);
      emitter.on("legend:unhighlight", onUnHighlight);
      const destroy2 = () => {
        legend.removeEventListener(pointerleave);
        emitter.off("legend:highlight", onHighlight);
        emitter.off("legend:unhighlight", onUnHighlight);
        for (const [item, pointerover] of itemPointerover) {
          item.removeEventListener(pointerover);
        }
      };
      destroys.push(destroy2);
    }
    return () => destroys.forEach((d2) => d2());
  };
}

// node_modules/@antv/g2/esm/interaction/brushHighlight.js
var __rest81 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function intersect2(bbox1, bbox2) {
  const [minX1, minY1, maxX1, maxY1] = bbox1;
  const [minX2, minY2, maxX2, maxY2] = bbox2;
  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x2, y2, x12, y12, extent2) {
  const [minX, minY, maxX, maxY2] = extent2;
  return [
    Math.max(minX, Math.min(x2, x12)),
    Math.max(minY, Math.min(y2, y12)),
    Math.min(maxX, Math.max(x2, x12)),
    Math.min(maxY2, Math.max(y2, y12))
  ];
}
function bboxOf2(root) {
  const { width, height } = root.getBBox();
  return [0, 0, width, height];
}
function applyStyle3(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
var ResizableMask = createElement((g) => {
  const _a = g.attributes, { x: x2, y: y2, width, height, class: className2, renders = {}, handleSize: size3 = 10, document: document2 } = _a, style = __rest81(_a, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
  if (!document2 || width === void 0 || height === void 0 || x2 === void 0 || y2 === void 0)
    return;
  const half = size3 / 2;
  const renderRect = (g2, options, document3) => {
    if (!g2.handle) {
      g2.handle = document3.createElement("rect");
      g2.append(g2.handle);
    }
    const { handle } = g2;
    handle.attr(options);
    return handle;
  };
  const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest81(_b, ["render"]);
  const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest81(_c, ["render"]);
  const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest81(_d, ["render"]);
  const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest81(_e, ["render"]);
  const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest81(_f, ["render"]);
  const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest81(_g, ["render"]);
  const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest81(_h, ["render"]);
  const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest81(_j, ["render"]);
  const renderHandle = (g2, renderNode) => {
    const { id: id2 } = g2;
    const handle = renderNode(g2, g2.attributes, document2);
    handle.id = id2;
    handle.style.draggable = true;
  };
  const appendHandle = (handleRender) => {
    return () => {
      const Node4 = createElement((g2) => renderHandle(g2, handleRender));
      return new Node4({});
    };
  };
  const container = select(g).attr("className", className2).style("transform", `translate(${x2}, ${y2})`).style("draggable", true);
  container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
    width,
    height
  }, omitPrefixObject(style, "handle")), { transform: void 0 }));
  container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNStyle);
  container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleEStyle);
  container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSStyle);
  container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleWStyle);
  container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNWStyle);
  container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNEStyle);
  container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSEStyle);
  container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSWStyle);
});
function brush(root, _a) {
  var { brushed = () => {
  }, brushended = () => {
  }, brushcreated = () => {
  }, brushstarted = () => {
  }, brushupdated = () => {
  }, extent: extent2 = bboxOf2(root), brushRegion = (x2, y2, x12, y12, extent3) => [x2, y2, x12, y12], reverse: reverse2 = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
    "handle-n",
    "handle-e",
    "handle-s",
    "handle-w",
    "handle-nw",
    "handle-ne",
    "handle-se",
    "handle-sw"
  ] } = _a, style = __rest81(_a, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
  let start = null;
  let end = null;
  let moveStart = null;
  let mask = null;
  let background = null;
  let creating = false;
  const [originX, originY, width, height] = extent2;
  setCursor(root, "crosshair");
  root.style.draggable = true;
  const initMask = (x2, y2, event) => {
    brushstarted(event);
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = [x2, y2];
    if (reverse2)
      return initReverseMask();
    initNormalMask();
  };
  const initReverseMask = () => {
    background = new Path({
      style: Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        pointerEvents: "none"
      })
    });
    mask = new ResizableMask({
      // @ts-ignore
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        draggable: true,
        document: root.ownerDocument
      },
      className: "mask"
    });
    root.appendChild(background);
    root.appendChild(mask);
  };
  const initNormalMask = () => {
    mask = new ResizableMask({
      // @ts-ignore
      style: Object.assign(Object.assign({ document: root.ownerDocument, x: 0, y: 0 }, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        draggable: true
      }),
      className: "mask"
    });
    root.appendChild(mask);
  };
  const removeMask = (emit = true) => {
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = null;
    end = null;
    moveStart = null;
    creating = false;
    mask = null;
    background = null;
    brushended(emit);
  };
  const updateMask = (start2, end2, emit = true) => {
    const [x2, y2, x12, y12] = normalizeBounds(start2[0], start2[1], end2[0], end2[1], extent2);
    const [fx, fy, fx1, fy1] = brushRegion(x2, y2, x12, y12, extent2);
    if (reverse2)
      updateReverseMask(fx, fy, fx1, fy1);
    else
      updateNormalMask(fx, fy, fx1, fy1);
    brushed(fx, fy, fx1, fy1, emit);
    return [fx, fy, fx1, fy1];
  };
  const updateNormalMask = (x2, y2, x12, y12) => {
    mask.style.x = x2;
    mask.style.y = y2;
    mask.style.width = x12 - x2;
    mask.style.height = y12 - y2;
  };
  const updateReverseMask = (x2, y2, x12, y12) => {
    background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x2},${y2}L${x2},${y12}L${x12},${y12}L${x12},${y2}Z
    `;
    mask.style.x = x2;
    mask.style.y = y2;
    mask.style.width = x12 - x2;
    mask.style.height = y12 - y2;
  };
  const moveMask = (current) => {
    const clip = (dt, start2, end2, min6, max6) => {
      if (dt + start2 < min6)
        return min6 - start2;
      if (dt + end2 > max6)
        return max6 - end2;
      return dt;
    };
    const dx = current[0] - moveStart[0];
    const dy = current[1] - moveStart[1];
    const dx1 = clip(dx, start[0], end[0], originX, width);
    const dy1 = clip(dy, start[1], end[1], originY, height);
    const currentStart = [start[0] + dx1, start[1] + dy1];
    const currentEnd = [end[0] + dx1, end[1] + dy1];
    updateMask(currentStart, currentEnd);
  };
  const handles = {
    "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
    "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
    "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
    "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
    "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
    "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
    "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
    "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
  };
  const isMask = (target) => {
    return isSelection(target) || isHandle(target);
  };
  const isHandle = (target) => {
    const { id: id2 } = target;
    if (selectedHandles.indexOf(id2) === -1)
      return false;
    return new Set(Object.keys(handles)).has(id2);
  };
  const isSelection = (target) => {
    return target === mask.getElementById("selection");
  };
  const dragstart = (event) => {
    const { target } = event;
    const [offsetX, offsetY] = brushMousePosition(root, event);
    if (!mask || !isMask(target)) {
      initMask(offsetX, offsetY, event);
      creating = true;
      return;
    }
    if (isMask(target)) {
      moveStart = [offsetX, offsetY];
    }
  };
  const drag = (event) => {
    const { target } = event;
    const mouse = brushMousePosition(root, event);
    if (!start)
      return;
    if (!moveStart)
      return updateMask(start, mouse);
    if (isSelection(target))
      return moveMask(mouse);
    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
    const { id: id2 } = target;
    if (handles[id2]) {
      const [sx, sy, ex, ey] = handles[id2].vector;
      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
    }
  };
  const dragend = (event) => {
    if (moveStart) {
      moveStart = null;
      const { x: x2, y: y2, width: width2, height: height2 } = mask.style;
      start = [x2, y2];
      end = [x2 + width2, y2 + height2];
      brushupdated(x2, y2, x2 + width2, y2 + height2, event);
      return;
    }
    end = brushMousePosition(root, event);
    const [fx, fy, fx1, fy1] = updateMask(start, end);
    creating = false;
    brushcreated(fx, fy, fx1, fy1, event);
  };
  const click = (event) => {
    const { target } = event;
    if (mask && !isMask(target))
      removeMask();
  };
  const pointermove = (event) => {
    const { target } = event;
    if (!mask || !isMask(target) || creating)
      setCursor(root, "crosshair");
    else if (isSelection(target))
      setCursor(root, "move");
    else if (isHandle(target))
      setCursor(root, handles[target.id].cursor);
  };
  const pointerleave = () => {
    setCursor(root, "default");
  };
  root.addEventListener("dragstart", dragstart);
  root.addEventListener("drag", drag);
  root.addEventListener("dragend", dragend);
  root.addEventListener("click", click);
  root.addEventListener("pointermove", pointermove);
  root.addEventListener("pointerleave", pointerleave);
  return {
    mask,
    move(x2, y2, x12, y12, emit = true) {
      if (!mask)
        initMask(x2, y2, {});
      start = [x2, y2];
      end = [x12, y12];
      updateMask([x2, y2], [x12, y12], emit);
    },
    remove(emit = true) {
      if (mask)
        removeMask(emit);
    },
    destroy() {
      if (mask)
        removeMask(false);
      setCursor(root, "default");
      root.removeEventListener("dragstart", dragstart);
      root.removeEventListener("drag", drag);
      root.removeEventListener("dragend", dragend);
      root.removeEventListener("click", click);
      root.removeEventListener("pointermove", pointermove);
      root.removeEventListener("pointerleave", pointerleave);
    }
  };
}
function selectSiblingViews(target, viewInstances, brushKey) {
  return viewInstances.filter((d2) => {
    if (d2 === target)
      return false;
    const { interaction = {} } = d2.options;
    return Object.values(interaction).find((d3) => d3.brushKey === brushKey);
  });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d2) => selectPlotArea(d2.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.options);
}
function brushHighlight(root, _a) {
  var { elements: elementof, selectedHandles, siblings: siblingsof = (root2) => [], datum, brushRegion, extent: optionalExtent, reverse: reverse2, scale: scale3, coordinate, series = false, key = (d2) => d2, bboxOf: bboxOf3 = (root2) => {
    const { x: x2, y: y2, width, height } = root2.style;
    return { x: x2, y: y2, width, height };
  }, state = {}, emitter } = _a, rest = __rest81(_a, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
  const elements = elementof(root);
  const siblings = siblingsof(root);
  const siblingElements = siblings.flatMap(elementof);
  const valueof2 = createValueof(elements, datum);
  const brushStyle = subObject(rest, "mask");
  const { setState, removeState } = useState(state, valueof2);
  const clonedElement = /* @__PURE__ */ new Map();
  const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root);
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const brushended = () => {
    for (const element of [...elements, ...siblingElements]) {
      removeState(element, "active", "inactive");
    }
  };
  const brushed = (x2, y2, x12, y12) => {
    var _a2;
    for (const sibling of siblings)
      (_a2 = sibling.brush) === null || _a2 === void 0 ? void 0 : _a2.remove();
    const keys = /* @__PURE__ */ new Set();
    for (const element of elements) {
      const { min: min6, max: max6 } = element.getLocalBounds();
      const [ex, ey] = min6;
      const [ex1, ey1] = max6;
      if (!intersect2([ex, ey, ex1, ey1], [x2, y2, x12, y12])) {
        setState(element, "inactive");
      } else {
        setState(element, "active");
        keys.add(key(element));
      }
    }
    for (const element of siblingElements) {
      if (keys.has(key(element)))
        setState(element, "active");
      else
        setState(element, "inactive");
    }
  };
  const seriesBrushend = () => {
    for (const element of elements)
      removeState(element, "inactive");
    for (const cloned of clonedElement.values())
      cloned.remove();
    clonedElement.clear();
  };
  const seriesBrushed = (x2, y2, x12, y12) => {
    const clone = (element) => {
      const cloned = element.cloneNode();
      cloned.__data__ = element.__data__;
      element.parentNode.appendChild(cloned);
      clonedElement.set(element, cloned);
      return cloned;
    };
    const clipPath = new Rect({
      style: {
        x: x2 + ordinalX,
        y: y2 + ordinalY,
        width: x12 - x2,
        height: y12 - y2
      }
    });
    root.appendChild(clipPath);
    for (const element of elements) {
      const cloned = clonedElement.get(element) || clone(element);
      cloned.style.clipPath = clipPath;
      setState(element, "inactive");
      setState(cloned, "active");
    }
  };
  const brushHandler = brush(root, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    selectedHandles,
    brushended: (emit) => {
      const handler = series ? seriesBrushend : brushended;
      if (emit) {
        emitter.emit("brush:remove", { nativeEvent: true });
      }
      handler();
    },
    brushed: (x2, y2, x12, y12, emit) => {
      const selection = selectionOf(x2, y2, x12, y12, scale3, coordinate);
      if (emit) {
        emitter.emit("brush:highlight", {
          nativeEvent: true,
          data: { selection }
        });
      }
      const handler = series ? seriesBrushed : brushed;
      handler(x2, y2, x12, y12);
    },
    brushcreated: (x2, y2, x12, y12, event) => {
      const selection = selectionOf(x2, y2, x12, y12, scale3, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushupdated: (x2, y2, x12, y12, event) => {
      const selection = selectionOf(x2, y2, x12, y12, scale3, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushstarted: (e) => {
      emitter.emit("brush:start", e);
    }
  }));
  const onHighlight = ({ nativeEvent, data }) => {
    if (nativeEvent)
      return;
    const { selection } = data;
    const [x2, y2, x12, y12] = pixelsOf(selection, scale3, coordinate);
    brushHandler.move(x2, y2, x12, y12, false);
  };
  emitter.on("brush:highlight", onHighlight);
  const onRemove = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    brushHandler.remove(false);
  };
  emitter.on("brush:remove", onRemove);
  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
  brushHandler.destroy = () => {
    emitter.off("brush:highlight", onHighlight);
    emitter.off("brush:remove", onRemove);
    preBrushDestroy();
  };
  return brushHandler;
}
function BrushHighlight(_a) {
  var { facet, brushKey } = _a, rest = __rest81(_a, ["facet", "brushKey"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      reverse: false
    };
    const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
    const { scale: scale3, coordinate } = view;
    if (facet) {
      const bbox = plotArea.getBounds();
      const x2 = bbox.min[0];
      const y2 = bbox.min[1];
      const x12 = bbox.max[0];
      const y12 = bbox.max[1];
      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
        elements: () => selectFacetG2Elements(target, viewInstances),
        datum: createDatumof(selectFacetViews(target, viewInstances).map((d2) => d2.view)),
        brushRegion: (x3, y3, x13, y13) => [x3, y3, x13, y13],
        extent: [x2, y2, x12, y12],
        state: mergeState(selectFacetViews(target, viewInstances).map((d2) => d2.options), defaultStates),
        emitter,
        scale: scale3,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions), rest));
    }
    const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
      elements: selectG2Elements,
      key: (element) => element.__data__.key,
      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
      datum: createDatumof([
        view,
        ...selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.view)
      ]),
      brushRegion: (x2, y2, x12, y12) => [x2, y2, x12, y12],
      extent: void 0,
      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
      emitter,
      scale: scale3,
      coordinate,
      selectedHandles: void 0
    }, defaultOptions), rest));
    plotArea.brush = brush2;
    return () => brush2.destroy();
  };
}

// node_modules/@antv/g2/esm/interaction/brushXHighlight.js
function brushXRegion(x2, y2, x12, y12, extent2) {
  const [, minY, , maxY2] = extent2;
  return [x2, minY, x12, maxY2];
}
function BrushXHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
}

// node_modules/@antv/g2/esm/interaction/brushYHighlight.js
function brushYRegion(x2, y2, x12, y12, extent2) {
  const [minX, , maxX] = extent2;
  return [minX, y2, maxX, y12];
}
function BrushYHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
}

// node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
var __rest82 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var AXIS_CLASS_NAME = "axis";
var AXIS_LINE_CLASS_NAME = "axis-line";
var AXIS_MAIN_CLASS_NAME = "axis-main-group";
var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
function axesOf(container) {
  return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
function boundsOfAxis(axis) {
  return mainGroupOf(axis).getLocalBounds();
}
function verticalBrush(axis, _a) {
  var { cross: cross3, offsetX, offsetY } = _a, style = __rest82(_a, ["cross", "offsetX", "offsetY"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [lineX] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = (maxX - minX) * 2;
  return {
    brushRegion: brushYRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        width: cross3 ? size3 / 2 : size3,
        transform: `translate(${(cross3 ? minX : lineX - size3 / 2).toFixed(2)}, ${minY})`,
        height: maxY2 - minY
      }, style)
    }),
    extent: cross3 ? (
      // If it is cross, the x range is ignored.
      (x2, y2, x12, y12) => [-Infinity, y2, Infinity, y12]
    ) : (x2, y2, x12, y12) => [
      Math.floor(minX - offsetX),
      y2,
      Math.ceil(maxX - offsetX),
      y12
    ]
  };
}
function horizontalBrush(axis, _a) {
  var { offsetY, offsetX, cross: cross3 = false } = _a, style = __rest82(_a, ["offsetY", "offsetX", "cross"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [, lineY] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = maxY2 - minY;
  return {
    brushRegion: brushXRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        width: maxX - minX,
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        height: cross3 ? size3 : size3 * 2,
        transform: `translate(${minX}, ${cross3 ? minY : lineY - size3})`
      }, style)
    }),
    extent: cross3 ? (
      // If it is cross, the y range is ignored.
      (x2, y2, x12, y12) => [x2, -Infinity, x12, Infinity]
    ) : (x2, y2, x12, y12) => [
      x2,
      Math.floor(minY - offsetY),
      x12,
      Math.ceil(maxY2 - offsetY)
    ]
  };
}
function brushAxisHighlight(root, _a) {
  var {
    axes: axesOf2,
    // given root, return axes
    elements: elementsOf,
    // given root, return elements
    points: pointsOf,
    // given shape, return control points
    horizontal: isHorizontal2,
    // given axis, return direction
    datum,
    // given shape, return datum
    offsetY,
    // offsetY for shape area
    offsetX,
    // offsetX for shape area
    reverse: reverse2 = false,
    state = {},
    emitter,
    coordinate
  } = _a, rest = __rest82(_a, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
  const elements = elementsOf(root);
  const axes = axesOf2(root);
  const valueof2 = createValueof(elements, datum);
  const { setState, removeState } = useState(state, valueof2);
  const axisExtent = /* @__PURE__ */ new Map();
  const brushStyle = subObject(rest, "mask");
  const brushed = (points) => Array.from(axisExtent.values()).every(([x2, y2, x12, y12]) => points.some(([x05, y05]) => {
    return x05 >= x2 && x05 <= x12 && y05 >= y2 && y05 <= y12;
  }));
  const scales = axes.map((d2) => d2.attributes.scale);
  const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
  const indexDomain = /* @__PURE__ */ new Map();
  const initIndexDomain = () => {
    indexDomain.clear();
    for (let i = 0; i < axes.length; i++) {
      const scale3 = scales[i];
      const { domain } = scale3.getOptions();
      indexDomain.set(i, extentOf2(domain));
    }
  };
  initIndexDomain();
  const updateElement = (i, emit) => {
    const selectedElements = [];
    for (const element of elements) {
      const points = pointsOf(element);
      if (brushed(points)) {
        setState(element, "active");
        selectedElements.push(element);
      } else
        setState(element, "inactive");
    }
    indexDomain.set(i, selectionOf2(selectedElements, i));
    if (!emit)
      return;
    const selection = () => {
      if (!cross3)
        return Array.from(indexDomain.values());
      const S = [];
      for (const [index2, domain] of indexDomain) {
        const scale3 = scales[index2];
        const { name: name2 } = scale3.getOptions();
        if (name2 === "x")
          S[0] = domain;
        else
          S[1] = domain;
      }
      return S;
    };
    emitter.emit("brushAxis:highlight", {
      nativeEvent: true,
      data: {
        selection: selection()
      }
    });
  };
  const clearElement = (emit) => {
    for (const element of elements)
      removeState(element, "active", "inactive");
    initIndexDomain();
    if (!emit)
      return;
    emitter.emit("brushAxis:remove", { nativeEvent: true });
  };
  const selectionOf2 = (selected, i) => {
    const scale3 = scales[i];
    const { name: name2 } = scale3.getOptions();
    const domain = selected.map((d2) => {
      const data = d2.__data__;
      return scale3.invert(data[name2]);
    });
    return extentOf2(domainOf3(scale3, domain));
  };
  const cross3 = axes.some(isHorizontal2) && axes.some((d2) => !isHorizontal2(d2));
  const handlers = [];
  for (let i = 0; i < axes.length; i++) {
    const axis = axes[i];
    const createBrush = isHorizontal2(axis) ? horizontalBrush : verticalBrush;
    const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
      offsetY,
      offsetX,
      cross: cross3,
      zIndex: 999,
      fill: "transparent"
      // Make it interactive.
    });
    axis.parentNode.appendChild(hotZone);
    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
      reverse: reverse2,
      brushRegion,
      brushended(emit) {
        axisExtent.delete(axis);
        if (Array.from(axisExtent.entries()).length === 0)
          clearElement(emit);
        else
          updateElement(i, emit);
      },
      brushed(x2, y2, x12, y12, emit) {
        axisExtent.set(axis, extent2(x2, y2, x12, y12));
        updateElement(i, emit);
      }
    }));
    handlers.push(brushHandler);
  }
  const onRemove = (event = {}) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    handlers.forEach((d2) => d2.remove(false));
  };
  const rangeOf3 = (domain, scale3, axis) => {
    const [d0, d1] = domain;
    const maybeStep = (scale4) => scale4.getStep ? scale4.getStep() : 0;
    const x2 = abstractOf2(d0, scale3, axis);
    const x12 = abstractOf2(d1, scale3, axis) + maybeStep(scale3);
    if (isHorizontal2(axis))
      return [x2, -Infinity, x12, Infinity];
    return [-Infinity, x2, Infinity, x12];
  };
  const abstractOf2 = (x2, scale3, axis) => {
    const { height, width } = coordinate.getOptions();
    const scale1 = scale3.clone();
    if (isHorizontal2(axis))
      scale1.update({ range: [0, width] });
    else
      scale1.update({ range: [height, 0] });
    return scale1.map(x2);
  };
  const onHighlight = (event) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { selection } = event.data;
    for (let i = 0; i < handlers.length; i++) {
      const domain = selection[i];
      const handler = handlers[i];
      const axis = axes[i];
      if (domain) {
        const scale3 = scales[i];
        handler.move(...rangeOf3(domain, scale3, axis), false);
      } else {
        handler.remove(false);
      }
    }
  };
  emitter.on("brushAxis:remove", onRemove);
  emitter.on("brushAxis:highlight", onHighlight);
  return () => {
    handlers.forEach((d2) => d2.destroy());
    emitter.off("brushAxis:remove", onRemove);
    emitter.off("brushAxis:highlight", onHighlight);
  };
}
function BrushAxisHighlight(options) {
  return (target, _, emitter) => {
    const { container, view, options: viewOptions } = target;
    const plotArea = selectPlotArea(container);
    const { x: x05, y: y05 } = plotArea.getBBox();
    const { coordinate } = view;
    return brushAxisHighlight(container, Object.assign({
      elements: selectG2Elements,
      axes: axesOf,
      offsetY: y05,
      offsetX: x05,
      points: (element) => element.__data__.points,
      horizontal: (axis) => {
        const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
        return sx !== ex && sy === ey;
      },
      datum: createDatumof(view),
      state: mergeState(viewOptions, [
        "active",
        ["inactive", { opacity: 0.5 }]
      ]),
      coordinate,
      emitter
    }, options));
  };
}

// node_modules/@antv/g2/esm/interaction/brushFilter.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest83 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function dblclick(interval = 300) {
  let preTimeStamp = null;
  return (e) => {
    const { timeStamp } = e;
    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {
      preTimeStamp = timeStamp;
      return true;
    }
    preTimeStamp = timeStamp;
    return false;
  };
}
function brushFilter(root, _a) {
  var { filter: filter2, reset, brushRegion, extent: optionalExtent, reverse: reverse2, emitter, scale: scale3, coordinate, selection, series = false } = _a, rest = __rest83(_a, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
  const brushStyle = subObject(rest, "mask");
  const { width: rootWidth, height: rootHeight } = root.getBBox();
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const isDblclick = dblclick();
  const brush2 = brush(root, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    brushcreated
  }));
  root.addEventListener("click", click);
  function brushcreated(x2, y2, x12, y12, event) {
    event.nativeEvent = true;
    filter2(selection(x2, y2, x12, y12), event);
    brush2.remove();
  }
  function click(e) {
    if (isDblclick(e)) {
      e.nativeEvent = true;
      reset(e);
    }
  }
  const onFilter = ({ nativeEvent, data }) => {
    if (nativeEvent)
      return;
    const { selection: selection2 } = data;
    filter2(selection2, { nativeEvent: false });
  };
  emitter.on("brush:filter", onFilter);
  return () => {
    brush2.destroy();
    emitter.off("brush:filter", onFilter);
    root.removeEventListener("click", click);
  };
}
function BrushFilter(_a) {
  var { hideX = true, hideY = true } = _a, rest = __rest83(_a, ["hideX", "hideY"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options: viewOptions, update, setState } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      unhighlightedOpacity: 0.5,
      reverse: false
    };
    let filtered = false;
    let filtering = false;
    let newView = view;
    const { scale: scale3, coordinate } = view;
    return brushFilter(plotArea, Object.assign(Object.assign({
      brushRegion: (x2, y2, x12, y12) => [x2, y2, x12, y12],
      selection: (x2, y2, x12, y12) => {
        const { scale: scale4, coordinate: coordinate2 } = newView;
        return selectionOf(x2, y2, x12, y12, scale4, coordinate2);
      },
      filter: (selection, event) => __awaiter8(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const [domainX, domainY] = selection;
        setState("brushFilter", (options) => {
          const { marks } = options;
          const newMarks = marks.map((mark2) => deep_mix_default({
            // Hide label to keep smooth transition.
            axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
          }, mark2, {
            // Set nice to false to avoid modify domain.
            scale: {
              x: { domain: domainX, nice: false },
              y: { domain: domainY, nice: false }
            }
          }));
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
        });
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        const newState = yield update();
        newView = newState.view;
        filtering = false;
        filtered = true;
      }),
      reset: (event) => {
        if (filtering || !filtered)
          return;
        const { scale: scale4 } = view;
        const { x: scaleX, y: scaleY } = scale4;
        const domainX = scaleX.getOptions().domain;
        const domainY = scaleY.getOptions().domain;
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        filtered = false;
        newView = view;
        setState("brushFilter");
        update();
      },
      extent: void 0,
      emitter,
      scale: scale3,
      coordinate
    }, defaultOptions), rest));
  };
}

// node_modules/@antv/g2/esm/interaction/brushXFilter.js
function BrushXFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
}

// node_modules/@antv/g2/esm/interaction/brushYFilter.js
function BrushYFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
}

// node_modules/@antv/g2/esm/interaction/sliderFilter.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SLIDER_CLASS_NAME = "slider";
function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
  const { marks } = options;
  const newMarks = marks.map((mark2) => {
    var _a, _b;
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: scaleOptions,
      // Don't rerender sliders.
      [prefix]: Object.assign(Object.assign({}, ((_a = mark2[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
}
function abstractValue(values3, scale3, reverse2) {
  const [x2, x12] = values3;
  const v = reverse2 ? (d2) => 1 - d2 : (d2) => d2;
  const d0 = invert(scale3, v(x2), true);
  const d1 = invert(scale3, v(x12), false);
  return domainOf3(scale3, [d0, d1]);
}
function extentOf(domain) {
  return [domain[0], domain[domain.length - 1]];
}
function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values3) => component.setValues(values3), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider) => {
  var _a;
  const values3 = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
  if (values3[0] !== 0 || values3[1] !== 1)
    return values3;
} }) {
  return (context, _, emitter) => {
    const { container, view, update, setState } = context;
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    let filtering = false;
    const { scale: scale3, coordinate, layout } = view;
    const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
    const { x: scaleX, y: scaleY } = scale3;
    const transposed = isTranspose(coordinate);
    const channelOf = (orientation) => {
      const channel0 = orientation === "vertical" ? "y" : "x";
      const channel1 = orientation === "vertical" ? "x" : "y";
      if (transposed)
        return [channel1, channel0];
      return [channel0, channel1];
    };
    const sliderHandler = /* @__PURE__ */ new Map();
    const emitHandlers = /* @__PURE__ */ new Set();
    const channelDomain = {
      x: initDomain.x || scaleX.getOptions().domain,
      y: initDomain.y || scaleY.getOptions().domain
    };
    for (const slider of sliders) {
      const { orientation } = slider.attributes;
      const [channel0, channel1] = channelOf(orientation);
      const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
      const isX = channel0 === "x";
      const { ratio: ratioX } = scaleX.getOptions();
      const { ratio: ratioY } = scaleY.getOptions();
      const domainsOf = (event) => {
        if (event.data) {
          const { selection } = event.data;
          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
          return isX ? [domainOf3(scaleX, X, ratioX), domainOf3(scaleY, Y, ratioY)] : [domainOf3(scaleY, Y, ratioY), domainOf3(scaleX, X, ratioX)];
        }
        const { value: values4 } = event.detail;
        const scale0 = scale3[channel0];
        const domain0 = abstractValue(values4, scale0, transposed && orientation === "horizontal");
        const domain1 = channelDomain[channel1];
        return [domain0, domain1];
      };
      const onValueChange = throttle_default((event) => __awaiter9(this, void 0, void 0, function* () {
        const { initValue = false } = event;
        if (filtering && !initValue)
          return;
        filtering = true;
        const { nativeEvent = true } = event;
        const [domain0, domain1] = domainsOf(event);
        channelDomain[channel0] = domain0;
        channelDomain[channel1] = domain1;
        if (nativeEvent) {
          const X = isX ? domain0 : domain1;
          const Y = isX ? domain1 : domain0;
          emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
        }
        setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
          options,
          // Set nice to false to avoid modify domain.
          // Only update domain of current slider / scrollbar.
          { [channel0]: { domain: domain0, nice: false } },
          prefix,
          hasState,
          channel0,
          channel1
        )), {
          paddingLeft,
          paddingTop,
          paddingBottom,
          paddingRight
        }));
        yield update();
        filtering = false;
      }), wait, { leading, trailing });
      const emitHandler = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        const { data } = event;
        const { selection } = data;
        const [X, Y] = selection;
        slider.dispatchEvent(new CustomEvent("valuechange", {
          data,
          nativeEvent: false
        }));
        const V = isX ? abstractOf(X, scaleX) : abstractOf(Y, scaleY);
        setValue(slider, V);
      };
      emitter.on(eventName, emitHandler);
      slider.addEventListener("valuechange", onValueChange);
      sliderHandler.set(slider, onValueChange);
      emitHandlers.add([eventName, emitHandler]);
      const values3 = getInitValues(slider);
      if (values3) {
        slider.dispatchEvent(new CustomEvent("valuechange", {
          detail: {
            value: values3
          },
          nativeEvent: false,
          initValue: true
        }));
      }
    }
    return () => {
      for (const [slider, handler] of sliderHandler) {
        slider.removeEventListener("valuechange", handler);
      }
      for (const [name2, handler] of emitHandlers) {
        emitter.off(name2, handler);
      }
    };
  };
}

// node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
function ScrollbarFilter(options = {}) {
  return (context, _, emitter) => {
    const { view, container } = context;
    const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
    if (!scrollbars.length)
      return () => {
      };
    const { scale: scale3 } = view;
    const { x: scaleX, y: scaleY } = scale3;
    const initDomain = {
      x: [...scaleX.getOptions().domain],
      y: [...scaleY.getOptions().domain]
    };
    scaleX.update({ domain: scaleX.getOptions().expectedDomain });
    scaleY.update({ domain: scaleY.getOptions().expectedDomain });
    const interaction = SliderFilter(Object.assign(Object.assign({}, options), { initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values3) => component.setValue(values3[0]), getInitValues: (scrollbar) => {
      const values3 = scrollbar.slider.attributes.values;
      if (values3[0] !== 0)
        return values3;
    } }));
    return interaction(context, _, emitter);
  };
}

// node_modules/@antv/g2/esm/interaction/poptip.js
var __rest84 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function dom(tag, children, style) {
  return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
}
var defaultTipStyle = {
  backgroundColor: "rgba(0,0,0,0.75)",
  color: "#fff",
  width: "max-content",
  padding: "1px 4px",
  fontSize: "12px",
  borderRadius: "2.5px",
  boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
};
function isTipText(element) {
  if (element.nodeName !== "text")
    return false;
  if (element.isOverflowing())
    return true;
  return false;
}
function Poptip(_a) {
  var { offsetX = 8, offsetY = 8 } = _a, style = __rest84(_a, ["offsetX", "offsetY"]);
  return (context) => {
    const { container } = context;
    const [x05, y05] = container.getBounds().min;
    const tipStyle = subObject(style, "tip");
    const tips = /* @__PURE__ */ new Set();
    const pointerover = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      const { offsetX: mouseX, offsetY: mouseY } = e;
      const x2 = mouseX + offsetX - x05;
      const y2 = mouseY + offsetY - y05;
      if (target.tip) {
        target.tip.style.x = x2;
        target.tip.style.y = y2;
        return;
      }
      const { text } = target.style;
      const tipELement = new HTML({
        className: "poptip",
        style: {
          innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
          x: x2,
          y: y2
        }
      });
      container.appendChild(tipELement);
      target.tip = tipELement;
      tips.add(tipELement);
    };
    const pointerout = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      if (!target.tip)
        return;
      target.tip.remove();
      target.tip = null;
      tips.delete(target.tip);
    };
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    return () => {
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      tips.forEach((tip) => tip.remove());
    };
  };
}
Poptip.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest85 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function selectPlotArea2(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB_STYLE = {
  breadCrumbFill: "rgba(0, 0, 0, 0.85)",
  breadCrumbFontSize: 12,
  breadCrumbY: 12,
  activeFill: "rgba(0, 0, 0, 0.5)"
};
function TreemapDrillDown(drillDownOptions = {}) {
  const { originData = [], layout } = drillDownOptions, style = __rest85(drillDownOptions, ["originData", "layout"]);
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
  const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
  const breadCrumbActiveStyle = subObject(breadCrumb, "active");
  return (context) => {
    const { update, setState, container, options } = context;
    const plotArea = selectPlotArea2(container);
    const mark2 = options.marks[0];
    const { state } = mark2;
    const textGroup = new Group();
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter10(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (depth) {
        let name2 = "";
        let y2 = breadCrumbStyle.y;
        let x2 = 0;
        const textPath = [];
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = path2.map((text, index2) => {
          name2 = `${name2}${text}/`;
          textPath.push(text);
          const drillText = new Text({
            name: name2.replace(/\/$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x2,
              // @ts-ignore
              path: [...textPath],
              depth: index2
            }, breadCrumbStyle), { y: y2 })
          });
          textGroup.appendChild(drillText);
          x2 += drillText.getBBox().width;
          const textSeparator = new Text({
            style: Object.assign(Object.assign({ x: x2, text: " / " }, breadCrumbStyle), { y: y2 })
          });
          textGroup.appendChild(textSeparator);
          x2 += textSeparator.getBBox().width;
          if (x2 > maxWidth) {
            y2 = textGroup.getBBox().height + breadCrumbStyle.y;
            x2 = 0;
            drillText.attr({
              x: x2,
              y: y2
            });
            x2 += drillText.getBBox().width;
            textSeparator.attr({
              x: x2,
              y: y2
            });
            x2 += textSeparator.getBBox().width;
          }
          if (index2 === size(path2) - 1) {
            textSeparator.remove();
          }
          return drillText;
        });
        drillTexts.forEach((item, index2) => {
          if (index2 === size(drillTexts) - 1)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumbActiveStyle);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
          });
        });
      }
      legendClearSetState(container, setState);
      setState("treemapDrillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const strPath = path2.join("/");
        const newMarks = marks.map((mark3) => {
          if (mark3.type !== "rect")
            return mark3;
          let newData = originData;
          if (depth) {
            const filterData = originData.filter((item) => {
              const id2 = get_default(item, ["id"]);
              return id2 && (id2.match(`${strPath}/`) || strPath.match(id2));
            }).map((item) => ({
              value: item.height === 0 ? get_default(item, ["value"]) : void 0,
              name: get_default(item, ["id"])
            }));
            const { paddingLeft, paddingBottom, paddingRight } = layout;
            const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d2) => d2.name, layer: (d2) => d2.depth === depth + 1 });
            newData = treeDataTransform(filterData, newLayout, {
              value: "value"
            })[0];
          } else {
            newData = originData.filter((item) => {
              return item.depth === 1;
            });
          }
          const colorDomain = [];
          newData.forEach(({ path: path3 }) => {
            colorDomain.push(last(path3));
          });
          return deep_mix_default({}, mark3, {
            data: newData,
            scale: {
              color: { domain: colorDomain }
            }
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update(void 0, ["legendFilter"]);
    });
    const createDrillClick = (e) => {
      const item = e.target;
      if (get_default(item, ["markType"]) !== "rect")
        return;
      const key = get_default(item, ["__data__", "key"]);
      const node = find_default(originData, (d2) => d2.id === key);
      if (get_default(node, "height")) {
        drillDownClick(get_default(node, "path"), get_default(node, "depth"));
      }
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElements(plotArea);
      elements.forEach((element) => {
        const cursor = get_default(element, ["style", "cursor"]);
        const node = find_default(originData, (d2) => d2.id === get_default(element, ["__data__", "key"]));
        if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    createActive();
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/elementPointMove.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest86 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_STYLE = {
  pointR: 6,
  pointStrokeWidth: 1,
  pointStroke: "#888",
  pointActiveStroke: "#f5f5f5",
  pathStroke: "#888",
  pathLineDash: [3, 4],
  labelFontSize: 12,
  labelFill: "#888",
  labelStroke: "#fff",
  labelLineWidth: 1,
  labelY: -6,
  labelX: 2
};
var MOVE_POINT_NAME = "movePoint";
var elementMouseenter = (e) => {
  const element = e.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("_lineWidth", element.attr("lineWidth") || 1);
    element.attr("lineWidth", element.attr("_lineWidth") + 3);
  }
  if (markType === "interval") {
    element.attr("_opacity", element.attr("opacity") || 1);
    element.attr("opacity", 0.7 * element.attr("_opacity"));
  }
};
var elementMouseleave = (e) => {
  const element = e.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("lineWidth", element.attr("_lineWidth"));
  }
  if (markType === "interval") {
    element.attr("opacity", element.attr("_opacity"));
  }
};
var getNewData = (newChangeData, data, encode) => {
  return data.map((d2) => {
    const isUpdate = ["x", "color"].reduce((v, key) => {
      const field3 = encode[key];
      if (!field3)
        return v;
      if (d2[field3] !== newChangeData[field3])
        return false;
      return v;
    }, true);
    return isUpdate ? Object.assign(Object.assign({}, d2), newChangeData) : d2;
  });
};
var getIntervalDataRatioTransformFn = (element) => {
  const y2 = get_default(element, ["__data__", "y"]);
  const y12 = get_default(element, ["__data__", "y1"]);
  const v = y12 - y2;
  const { __data__: { data, encode, transform }, childNodes } = element.parentNode;
  const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data[childNodes.indexOf(element)][yField];
  return (newValue, isTheta3 = false) => {
    if (isNormalizeY || isTheta3) {
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var getPathDataRatioTransformFn = (element, index2) => {
  const v = get_default(element, ["__data__", "seriesItems", index2, "0", "value"]);
  const i = get_default(element, ["__data__", "seriesIndex", index2]);
  const { __data__: { data, encode, transform } } = element.parentNode;
  const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data[i][yField];
  return (newValue) => {
    if (isNormalizeY) {
      if (v === 1) {
        return newValue;
      }
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
  pointsShape.forEach((shape23, index2) => {
    shape23.attr("stroke", selection[1] === index2 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
  });
};
var createHelpShape = (group2, circle2, pathStyle, labelStyle) => {
  const pathShape = new Path({
    style: pathStyle
  });
  const labelShape = new Text({
    style: labelStyle
  });
  circle2.appendChild(labelShape);
  group2.appendChild(pathShape);
  return [pathShape, labelShape];
};
var getColorType = (scaleColor, color2) => {
  const indexOf3 = get_default(scaleColor, ["options", "range", "indexOf"]);
  if (!indexOf3)
    return;
  const i = scaleColor.options.range.indexOf(color2);
  return scaleColor.sortedDomain[i];
};
var getSamePointPosition = (center2, point6, target) => {
  const oldR = getPointsR(center2, point6);
  const newR = getPointsR(center2, target);
  const ratio = newR / oldR;
  const newX = center2[0] + (point6[0] - center2[0]) * ratio;
  const newY = center2[1] + (point6[1] - center2[1]) * ratio;
  return [newX, newY];
};
function ElementPointMove(elementPointMoveOptions = {}) {
  const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest86(elementPointMoveOptions, ["selection", "precision"]);
  const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE), style || {});
  const pathDefaultStyle = subObject(defaultStyle2, "path");
  const labelDefaultStyle = subObject(defaultStyle2, "label");
  const pointDefaultStyle = subObject(defaultStyle2, "point");
  return (context, _, emitter) => {
    const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
    const plotArea = selectPlotArea(container);
    let elements = getElements(plotArea);
    let newState;
    let newSelection = selection;
    const { transform = [], type: coordinateType } = coordinateOptions;
    const isTranspose3 = !!find_default(transform, ({ type }) => type === "transpose");
    const isPolar3 = coordinateType === "polar";
    const isTheta3 = coordinateType === "theta";
    const isArea = !!find_default(elements, ({ markType }) => markType === "area");
    if (isArea) {
      elements = elements.filter(({ markType }) => markType === "area");
    }
    const pointsGroup = new Group({
      style: {
        // Tooltip point need down.
        zIndex: 2
      }
    });
    plotArea.appendChild(pointsGroup);
    const selectedChange = () => {
      emitter.emit("element-point:select", {
        nativeEvent: true,
        data: {
          selection: newSelection
        }
      });
    };
    const dataChange = (changeData, data) => {
      emitter.emit("element-point:moved", {
        nativeEvent: true,
        data: {
          changeData,
          data
        }
      });
    };
    const elementClick = (e) => {
      const element = e.target;
      newSelection = [element.parentNode.childNodes.indexOf(element)];
      selectedChange();
      createPoints(element);
    };
    const elementSelect2 = (d2) => {
      const { data: { selection: selection2 }, nativeEvent } = d2;
      if (nativeEvent)
        return;
      newSelection = selection2;
      const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
      if (element) {
        createPoints(element);
      }
    };
    const createPoints = (element) => {
      const { attributes, markType, __data__: data } = element;
      const { stroke: fill } = attributes;
      const { points, seriesTitle, color: color2, title, seriesX, y1: y12 } = data;
      if (isTranspose3 && markType !== "interval")
        return;
      const { scale: scale3, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
      const { color: scaleColor, y: scaleY, x: scaleX } = scale3;
      const center2 = coordinate.getCenter();
      pointsGroup.removeChildren();
      let downPoint;
      const updateView = (x2, y2, color3, markTypes) => __awaiter11(this, void 0, void 0, function* () {
        setState("elementPointMove", (viewOptions) => {
          var _a;
          const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark2) => {
            if (!markTypes.includes(mark2.type))
              return mark2;
            const { data: data2, encode } = mark2;
            const encodeKeys = Object.keys(encode);
            const newChangeData = encodeKeys.reduce((value2, key) => {
              const dataKey = encode[key];
              if (key === "x") {
                value2[dataKey] = x2;
              }
              if (key === "y") {
                value2[dataKey] = y2;
              }
              if (key === "color") {
                value2[dataKey] = color3;
              }
              return value2;
            }, {});
            const newData = getNewData(newChangeData, data2, encode);
            dataChange(newChangeData, newData);
            return deep_mix_default({}, mark2, {
              data: newData,
              // No need animate
              animate: false
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        return yield update("elementPointMove");
      });
      if (["line", "area"].includes(markType)) {
        points.forEach((p2, index2) => {
          const title2 = scaleX.invert(seriesX[index2]);
          if (!title2)
            return;
          const circle2 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign({ cx: p2[0], cy: p2[1], fill }, pointDefaultStyle)
          });
          const ratioTransform = getPathDataRatioTransformFn(element, index2);
          circle2.addEventListener("mousedown", (e) => {
            const oldPoint = coordinate.output([seriesX[index2], 0]);
            const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
            container.attr("cursor", "move");
            if (newSelection[1] !== index2) {
              newSelection[1] = index2;
              selectedChange();
            }
            selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle2, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e3) => {
              const newCy = p2[1] + e3.clientY - downPoint[1];
              if (isArea) {
                if (isPolar3) {
                  const newCx = p2[0] + e3.clientX - downPoint[0];
                  const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                    newCx,
                    newCy
                  ]);
                  const [, initY] = coordinate.output([1, scaleY.output(0)]);
                  const [, y2] = coordinate.invert([
                    newX,
                    initY - (points[index2 + pathLength][1] - newY)
                  ]);
                  const nextIndex = (index2 + 1) % pathLength;
                  const lastIndex = (index2 - 1 + pathLength) % pathLength;
                  const newPath = getPointsPath([
                    points[lastIndex],
                    [newX, newY],
                    seriesTitle[nextIndex] && points[nextIndex]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY.invert(y2)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle2.attr("cx", newX);
                  circle2.attr("cy", newY);
                } else {
                  const [, initY] = coordinate.output([1, scaleY.output(0)]);
                  const [, y2] = coordinate.invert([
                    p2[0],
                    initY - (points[index2 + pathLength][1] - newCy)
                  ]);
                  const newPath = getPointsPath([
                    points[index2 - 1],
                    [p2[0], newCy],
                    seriesTitle[index2 + 1] && points[index2 + 1]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY.invert(y2)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle2.attr("cy", newCy);
                }
              } else {
                const [, y2] = coordinate.invert([p2[0], newCy]);
                const newPath = getPointsPath([
                  points[index2 - 1],
                  [p2[0], newCy],
                  points[index2 + 1]
                ]);
                labelShape.attr("text", scaleY.invert(y2).toFixed(precision));
                pathShape.attr("d", newPath);
                circle2.attr("cy", newCy);
              }
            };
            downPoint = [e.clientX, e.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              window.removeEventListener("mousemove", pointMousemove);
              container.removeEventListener("mouseup", mouseupFn);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y2 = Number(labelShape.attr("text"));
              const colorType = getColorType(scaleColor, color2);
              newState = yield updateView(title2, y2, colorType, [
                "line",
                "area"
              ]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle2);
        });
        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
      } else if (markType === "interval") {
        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
        if (isTranspose3) {
          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
        } else if (isTheta3) {
          circlePoint = points[0];
        }
        const ratioTransform = getIntervalDataRatioTransformFn(element);
        const circle2 = new Circle({
          name: MOVE_POINT_NAME,
          style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
        });
        circle2.addEventListener("mousedown", (e) => {
          container.attr("cursor", "move");
          const colorType = getColorType(scaleColor, color2);
          const [pathShape, labelShape] = createHelpShape(pointsGroup, circle2, pathDefaultStyle, labelDefaultStyle);
          const pointMousemove = (e3) => {
            if (isTranspose3) {
              const newCx = circlePoint[0] + e3.clientX - downPoint[0];
              const [initX] = coordinate.output([
                scaleY.output(0),
                scaleY.output(0)
              ]);
              const [, x2] = coordinate.invert([
                initX + (newCx - points[2][0]),
                circlePoint[1]
              ]);
              const newPath = getPointsPath([
                [newCx, points[0][1]],
                [newCx, points[1][1]],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY.invert(x2)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cx", newCx);
            } else if (isTheta3) {
              const newCy = circlePoint[1] + e3.clientY - downPoint[1];
              const newCx = circlePoint[0] + e3.clientX - downPoint[0];
              const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
              const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
              const lastPercent = coordinate.invert([newXOut, newYOut])[1];
              const percent = y12 - lastPercent;
              if (percent < 0)
                return;
              const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent > 0.5 ? 1 : 0);
              labelShape.attr("text", ratioTransform(percent, true).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cx", newXOut);
              circle2.attr("cy", newYOut);
            } else {
              const newCy = circlePoint[1] + e3.clientY - downPoint[1];
              const [, initY] = coordinate.output([1, scaleY.output(0)]);
              const [, y2] = coordinate.invert([
                circlePoint[0],
                initY - (points[2][1] - newCy)
              ]);
              const newPath = getPointsPath([
                [points[0][0], newCy],
                [points[1][0], newCy],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY.invert(y2)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cy", newCy);
            }
          };
          downPoint = [e.clientX, e.clientY];
          window.addEventListener("mousemove", pointMousemove);
          const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
            container.attr("cursor", "default");
            container.removeEventListener("mouseup", mouseupFn);
            window.removeEventListener("mousemove", pointMousemove);
            if (is_undefined_default(labelShape.attr("text")))
              return;
            const y2 = Number(labelShape.attr("text"));
            newState = yield updateView(title, y2, colorType, [markType]);
            labelShape.remove();
            pathShape.remove();
            createPoints(element);
          });
          container.addEventListener("mouseup", mouseupFn);
        });
        pointsGroup.appendChild(circle2);
      }
    };
    elements.forEach((element, index2) => {
      if (newSelection[0] === index2) {
        createPoints(element);
      }
      element.addEventListener("click", elementClick);
      element.addEventListener("mouseenter", elementMouseenter);
      element.addEventListener("mouseleave", elementMouseleave);
    });
    const rootClick = (e) => {
      const element = e === null || e === void 0 ? void 0 : e.target;
      if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
        newSelection = [];
        selectedChange();
        pointsGroup.removeChildren();
      }
    };
    emitter.on("element-point:select", elementSelect2);
    emitter.on("element-point:unselect", rootClick);
    container.addEventListener("mousedown", rootClick);
    return () => {
      pointsGroup.remove();
      emitter.off("element-point:select", elementSelect2);
      emitter.off("element-point:unselect", rootClick);
      container.removeEventListener("mousedown", rootClick);
      elements.forEach((element) => {
        element.removeEventListener("click", elementClick);
        element.removeEventListener("mouseenter", elementMouseenter);
        element.removeEventListener("mouseleave", elementMouseleave);
      });
    };
  };
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad(value2, width) {
  var s2 = value2 + "", length = s2.length;
  return length < width ? new Array(width - length + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;
    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i, j = I, c4;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
        if ((i = I) >= N) eof = true;
        else if ((c4 = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c4 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c4 = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c4 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c4 !== DELIMITER) continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter);
    });
  }
  function format2(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format: format2,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value2 = object[key].trim(), number2, m2;
    if (!value2) value2 = null;
    else if (value2 === "true") value2 = true;
    else if (value2 === "false") value2 = false;
    else if (value2 === "NaN") value2 = NaN;
    else if (!isNaN(number2 = +value2)) value2 = number2;
    else if (m2 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m2[4] && !m2[7]) value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else continue;
    object[key] = value2;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@antv/g2/esm/data/fetch.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fetch = (options) => {
  const { value: value2, format: format2 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
  return () => __awaiter12(void 0, void 0, void 0, function* () {
    const response = yield fetch(value2);
    if (format2 === "csv") {
      const str = yield response.text();
      return dsv_default(delimiter).parse(str, autoType2 ? autoType : identity2);
    } else if (format2 === "json") {
      return yield response.json();
    }
    throw new Error(`Unknown format: ${format2}.`);
  });
};
Fetch.props = {};

// node_modules/@antv/g2/esm/data/fold.js
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var Fold = (options) => {
  const { fields, key = "key", value: value2 = "value" } = options;
  return (data) => {
    if (isEmpty(fields))
      return data;
    return data.flatMap((d2) => fields.map((f) => Object.assign(Object.assign({}, d2), { [key]: f, [value2]: d2[f] })));
  };
};
Fold.props = {};

// node_modules/@antv/g2/esm/data/filter.js
function defined2(d2) {
  return d2 !== void 0 && d2 !== null && !Number.isNaN(d2);
}
var Filter2 = (options) => {
  const { callback = defined2 } = options;
  return (data) => data.filter(callback);
};
Filter2.props = {};

// node_modules/@antv/g2/esm/data/sort.js
var Sort2 = (options) => {
  const { callback } = options;
  return (data) => Array.isArray(data) ? [...data].sort(callback) : data;
};
Sort2.props = {};

// node_modules/@antv/g2/esm/data/pick.js
function pick(v, fields = []) {
  return fields.reduce((datum, field3) => {
    if (field3 in v) {
      datum[field3] = v[field3];
    }
    return datum;
  }, {});
}
var Pick = (options) => {
  const { fields } = options;
  return (data) => data.map((d2) => pick(d2, fields));
};
Pick.props = {};

// node_modules/@antv/g2/esm/data/rename.js
function isEmpty2(obj) {
  return Object.keys(obj).length === 0;
}
var Rename = (options) => {
  return (data) => {
    if (!options || isEmpty2(options))
      return data;
    const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
    return data.map(rename);
  };
};
Rename.props = {};

// node_modules/@antv/g2/esm/data/utils/fields.js
function normalizeFields(fields, defaultValue) {
  return fields.map((d2) => {
    if (Array.isArray(d2)) {
      const [field3, value2 = defaultValue] = d2;
      return [field3, value2];
    }
    return [d2, defaultValue];
  });
}

// node_modules/@antv/g2/esm/data/sortBy.js
var SortBy = (options) => {
  const { fields: F = [] } = options;
  const normalizedF = normalizeFields(F, true);
  return (data) => {
    const comparator = (a3, b) => normalizedF.reduce((ret, [field3, order = true]) => {
      if (ret !== 0) {
        return ret;
      }
      if (order) {
        return a3[field3] < b[field3] ? -1 : +(a3[field3] !== b[field3]);
      } else {
        return a3[field3] > b[field3] ? -1 : +(a3[field3] !== b[field3]);
      }
    }, 0);
    return [...data].sort(comparator);
  };
};
SortBy.props = {};

// node_modules/@antv/g2/esm/data/inline.js
var Inline = (options) => {
  const { value: value2 } = options;
  return () => value2;
};
Inline.props = {};

// node_modules/@antv/g2/esm/data/custom.js
var Custom = (options) => {
  const { callback = identity2 } = options;
  return (data) => callback(data);
};
Custom.props = {};

// node_modules/@antv/g2/esm/data/map.js
var Map2 = (options) => {
  const { callback = identity2 } = options;
  return (data) => Array.isArray(data) ? data.map(callback) : data;
};
Map2.props = {};

// node_modules/@antv/g2/esm/data/utils/flow.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function flow2(target, source) {
  return {
    set(key, normalize3, callback) {
      if (source[key] === void 0)
        return this;
      const value2 = normalize3 ? normalize3.call(null, source[key]) : source[key];
      if (callback)
        callback.call(null, value2);
      else if (typeof target[key] === "function")
        target[key](value2);
      else
        target[key] = value2;
      return this;
    },
    setAsync(key, normalize3, callback) {
      return __awaiter13(this, void 0, void 0, function* () {
        if (source[key] === void 0)
          return this;
        const value2 = normalize3 ? yield normalize3.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      });
    }
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d2) {
  return d2.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d2) {
  return d2.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudDispatch() {
  return;
}
function cloudSprite(contextAndRatio, d2, data, di) {
  if (d2.sprite)
    return;
  const c4 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c4.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x2 = 0, y2 = 0, maxh = 0;
  const n = data.length;
  --di;
  while (++di < n) {
    d2 = data[di];
    c4.save();
    c4.font = d2.style + " " + d2.weight + " " + ~~((d2.size + 1) / ratio) + "px " + d2.font;
    let w = c4.measureText(d2.text + "m").width * ratio, h = d2.size << 1;
    if (d2.rotate) {
      const sr = Math.sin(d2.rotate * cloudRadians), cr = Math.cos(d2.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x2 + w >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h >= ch)
      break;
    c4.translate((x2 + (w >> 1)) / ratio, (y2 + (h >> 1)) / ratio);
    if (d2.rotate)
      c4.rotate(d2.rotate * cloudRadians);
    c4.fillText(d2.text, 0, 0);
    if (d2.padding) {
      c4.lineWidth = 2 * d2.padding;
      c4.strokeText(d2.text, 0, 0);
    }
    c4.restore();
    d2.width = w;
    d2.height = h;
    d2.xoff = x2;
    d2.yoff = y2;
    d2.x1 = w >> 1;
    d2.y1 = h >> 1;
    d2.x0 = -d2.x1;
    d2.y0 = -d2.y1;
    d2.hasText = true;
    x2 += w;
  }
  const pixels = c4.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d2 = data[di];
    if (!d2.hasText)
      continue;
    const w = d2.width, w32 = w >> 5;
    let h = d2.y1 - d2.y0;
    for (let i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x2 = d2.xoff;
    if (x2 == null)
      return;
    y2 = d2.yoff;
    let seen = 0, seenRow = -1;
    for (let j = 0; j < h; j++) {
      for (let i = 0; i < w; i++) {
        const k2 = w32 * j + (i >> 5), m2 = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d2.y0++;
        h--;
        j--;
        y2++;
      }
    }
    d2.y1 = d2.y0 + seenRow;
    d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  let x2 = (tag.y + tag.y0) * sw + (lx >> 5), last5;
  for (let j = 0; j < h; j++) {
    last5 = 0;
    for (let i = 0; i <= w; i++) {
      if ((last5 << msx | (i < w ? (last5 = sprite[j * w + i]) >>> sx : 0)) & board[x2 + i])
        return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds, d2) {
  const b0 = bounds[0], b1 = bounds[1];
  if (d2.x + d2.x0 < b0.x)
    b0.x = d2.x + d2.x0;
  if (d2.y + d2.y0 < b0.y)
    b0.y = d2.y + d2.y0;
  if (d2.x + d2.x1 > b1.x)
    b1.x = d2.x + d2.x1;
  if (d2.y + d2.y1 > b1.y)
    b1.y = d2.y + d2.y1;
}
function collideRects(a3, b) {
  return a3.x + a3.x1 > b[0].x && a3.x + a3.x0 < b[1].x && a3.y + a3.y1 > b[0].y && a3.y + a3.y0 < b[1].y;
}
function archimedeanSpiral(size3) {
  const e = size3[0] / size3[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size3) {
  const dy = 4, dx = dy * size3[0] / size3[1];
  let x2 = 0, y2 = 0;
  return function(t) {
    const sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n) {
  const a3 = [];
  let i = -1;
  while (++i < n)
    a3[i] = 0;
  return a3;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d2) {
  return typeof d2 === "function" ? d2 : function() {
    return d2;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  let size3 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate2 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random = Math.random, event = cloudDispatch, words = [], timer = null, timeInterval = Infinity, canvas = cloudCanvas;
  const fontStyle = cloudFontNormal;
  const cloud = {};
  cloud.start = function() {
    const [width, height] = size3;
    const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size3[0] >> 5) * size3[1]), n = words.length, tags = [], data = words.map(function(d2, i2, data2) {
      d2.text = text.call(this, d2, i2, data2);
      d2.font = font.call(this, d2, i2, data2);
      d2.style = fontStyle.call(this, d2, i2, data2);
      d2.weight = fontWeight.call(this, d2, i2, data2);
      d2.rotate = rotate2.call(this, d2, i2, data2);
      d2.size = ~~fontSize.call(this, d2, i2, data2);
      d2.padding = padding.call(this, d2, i2, data2);
      return d2;
    }).sort(function(a3, b) {
      return b.size - a3.size;
    });
    let i = -1, bounds = !cloud.board ? void 0 : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    if (timer)
      clearInterval(timer);
    timer = setInterval(step, 0);
    step();
    function step() {
      const start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        const d2 = data[i];
        d2.x = width * (random() + 0.5) >> 1;
        d2.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d2, data, i);
        if (d2.hasText && place2(board, d2, bounds)) {
          event.call(null, "word", { cloud, word: d2 });
          tags.push(d2);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d2);
            }
          } else {
            bounds = [
              { x: d2.x + d2.x0, y: d2.y + d2.y0 },
              { x: d2.x + d2.x1, y: d2.y + d2.y1 }
            ];
          }
          d2.x -= size3[0] >> 1;
          d2.y -= size3[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
      if (i >= n) {
        cloud.stop();
        event.call(null, "end", { cloud, words: tags, bounds });
      }
    }
    return cloud;
  };
  cloud.stop = function() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    const context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    context.textBaseline = "middle";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size3[0] * size3[0] + size3[1] * size3[1]), s2 = spiral(size3), dt = random() < 0.5 ? 1 : -1;
    let dxdy, t = -dt, dx, dy;
    while (dxdy = s2(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size3[0] || tag.y + tag.y1 > size3[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size3[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          const sprite = tag.sprite, w = tag.width >> 5, sw = size3[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          let last5, x2 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h; j++) {
            last5 = 0;
            for (let i = 0; i <= w; i++) {
              board[x2 + i] |= last5 << msx | (i < w ? (last5 = sprite[j * w + i]) >>> sx : 0);
            }
            x2 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = (img) => {
    const can = document.createElement("canvas");
    const [width, height] = size3;
    if (!width || !height) {
      return;
    }
    const w32 = width >> 5;
    const board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    const cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    const imageData = cxt.getImageData(0, 0, width, height).data;
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        const k2 = w32 * j + (i >> 5);
        const tmp = j * width + i << 2;
        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        const m2 = flag ? 1 << 31 - i % 32 : 0;
        board[k2] |= m2;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_) {
    timeInterval = _ == null ? Infinity : _;
  };
  cloud.words = function(_) {
    words = _;
  };
  cloud.size = function(_ = []) {
    size3 = [+_[0], +_[1]];
  };
  cloud.text = function(_) {
    text = functor(_);
  };
  cloud.font = function(_) {
    font = functor(_);
  };
  cloud.fontWeight = function(_) {
    fontWeight = functor(_);
  };
  cloud.rotate = function(_) {
    rotate2 = functor(_);
  };
  cloud.canvas = function(_) {
    canvas = functor(_);
  };
  cloud.spiral = function(_) {
    spiral = spirals[_] || _;
  };
  cloud.fontSize = function(_) {
    fontSize = functor(_);
  };
  cloud.padding = function(_) {
    padding = functor(_);
  };
  cloud.random = function(_) {
    random = functor(_);
  };
  cloud.on = function(_) {
    event = functor(_);
  };
  return cloud;
}

// node_modules/@antv/g2/esm/data/wordCloud.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest87 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS5 = {
  fontSize: [20, 60],
  font: "Impact",
  padding: 2,
  rotate: function() {
    return (~~(Math.random() * 6) - 3) * 30;
  }
};
function processImageMask(img) {
  return new Promise((res, rej) => {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (typeof img === "string") {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img;
      image.onload = () => res(image);
      image.onerror = () => {
        console.error(`'image ${img} load failed !!!'`);
        rej();
      };
      return;
    }
    rej();
  });
}
function normalizeFontSize(fontSize, range3) {
  if (typeof fontSize === "function")
    return fontSize;
  if (Array.isArray(fontSize)) {
    const [fMin, fMax] = fontSize;
    if (!range3)
      return () => (fMax + fMin) / 2;
    const [min6, max6] = range3;
    if (max6 === min6)
      return () => (fMax + fMin) / 2;
    return ({ value: value2 }) => (fMax - fMin) / (max6 - min6) * (value2 - min6) + fMin;
  }
  return () => fontSize;
}
var WordCloud2 = (options, context) => {
  return (data) => __awaiter14(void 0, void 0, void 0, function* () {
    const cloudOptions = Object.assign({}, DEFAULT_OPTIONS5, options, {
      canvas: context.createCanvas
    });
    const layout = tagCloud();
    yield flow2(layout, cloudOptions).set("fontSize", (v) => {
      const arr = data.map((d2) => d2.value);
      return normalizeFontSize(v, [min(arr), max(arr)]);
    }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
    layout.words([...data]);
    const result = layout.start();
    const [cw2, ch2] = cloudOptions.size;
    const defaultBounds = [
      { x: 0, y: 0 },
      { x: cw2, y: ch2 }
    ];
    const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
    const tags = _tags.map((_a) => {
      var { x: x2, y: y2, font } = _a, rest = __rest87(_a, ["x", "y", "font"]);
      return Object.assign(Object.assign({}, rest), { x: x2 + cw2 / 2, y: y2 + ch2 / 2, fontFamily: font });
    });
    const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
    const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
    tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
    return tags;
  });
};
WordCloud2.props = {};

// node_modules/@antv/g2/esm/data/join.js
function field2(key) {
  return typeof key === "string" ? (d2) => d2[key] : key;
}
var Join = (options) => {
  const { join, on, select: select2 = [], as = select2, unknown = NaN } = options;
  const [key, fromKey] = on;
  const fk = field2(fromKey);
  const k2 = field2(key);
  const keyData = rollup(
    join,
    ([d2]) => d2,
    // Get the first matched.
    (d2) => fk(d2)
  );
  return (data) => data.map((d2) => {
    const source = keyData.get(k2(d2));
    return Object.assign(Object.assign({}, d2), select2.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
  });
};
Join.props = {};

// node_modules/@antv/g2/esm/data/slice.js
var Slice = (options) => {
  const { start, end } = options;
  return (data) => data.slice(start, end);
};
Slice.props = {};

// node_modules/@antv/g2/esm/data/kde.js
var import_pdfast = __toESM(require_src());
var KDE = (options) => {
  const { field: field3, groupBy: groupBy2, as = ["y", "size"], min: min6, max: max6, size: size3 = 10, width } = options;
  const [yField, sizeField] = as;
  return (data) => {
    const gs = Array.from(group(data, (d2) => groupBy2.map((gb) => d2[gb]).join("-")).values());
    return gs.map((g) => {
      const pdfResult = import_pdfast.default.create(g.map((i) => i[field3]), {
        min: min6,
        max: max6,
        size: size3,
        width
      });
      const _y = pdfResult.map((result) => result.x);
      const _size = pdfResult.map((result) => result.y);
      return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
    });
  };
};
KDE.props = {};

// node_modules/fmin/src/bisect.js
function bisect(f, a3, b, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance = parameters.tolerance || 1e-10, fA = f(a3), fB = f(b), delta = b - a3;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0) return a3;
  if (fB === 0) return b;
  for (var i = 0; i < maxIterations; ++i) {
    delta /= 2;
    var mid2 = a3 + delta, fMid = f(mid2);
    if (fMid * fA >= 0) {
      a3 = mid2;
    }
    if (Math.abs(delta) < tolerance || fMid === 0) {
      return mid2;
    }
  }
  return a3 + delta;
}

// node_modules/fmin/src/blas1.js
function zeros(x2) {
  var r = new Array(x2);
  for (var i = 0; i < x2; ++i) {
    r[i] = 0;
  }
  return r;
}
function zerosM(x2, y2) {
  return zeros(x2).map(function() {
    return zeros(y2);
  });
}
function dot2(a3, b) {
  var ret = 0;
  for (var i = 0; i < a3.length; ++i) {
    ret += a3[i] * b[i];
  }
  return ret;
}
function norm2(a3) {
  return Math.sqrt(dot2(a3, a3));
}
function scale2(ret, value2, c4) {
  for (var i = 0; i < value2.length; ++i) {
    ret[i] = value2[i] * c4;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/fmin/src/nelderMead.js
function nelderMead(f, x05, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x05.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N = x05.length, simplex = new Array(N + 1);
  simplex[0] = x05;
  simplex[0].fx = f(x05);
  simplex[0].id = 0;
  for (var i = 0; i < N; ++i) {
    var point6 = x05.slice();
    point6[i] = point6[i] ? point6[i] * nonZeroDelta : zeroDelta;
    simplex[i + 1] = point6;
    simplex[i + 1].fx = f(point6);
    simplex[i + 1].id = i + 1;
  }
  function updateSimplex(value2) {
    for (var i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  var sortOrder = function(a3, b) {
    return a3.fx - b.fx;
  };
  var centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x2) {
        var state = x2.slice();
        state.fx = x2.fx;
        state.id = x2.id;
        return state;
      });
      sortedSimplex.sort(function(a3, b) {
        return a3.id - b.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i = 0; i < N; ++i) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i = 0; i < N; ++i) {
      centroid[i] = 0;
      for (var j = 0; j < N; ++j) {
        centroid[i] += simplex[j][i];
      }
      centroid[i] /= N;
    }
    var worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1) break;
        for (i = 1; i < simplex.length; ++i) {
          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
          simplex[i].fx = f(simplex[i]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}

// node_modules/fmin/src/linesearch.js
function wolfeLineSearch(f, pk, current, next, a3, c1, c22) {
  var phi0 = current.fx, phiPrime0 = dot2(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a3 = a3 || 1;
  c1 = c1 || 1e-6;
  c22 = c22 || 0.1;
  function zoom(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a3 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a3, pk);
      phi2 = next.fx = f(next.x, next.fxprime);
      phiPrime = dot2(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a3 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a3;
      } else {
        if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
          return a3;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a3;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a3, pk);
    phi2 = next.fx = f(next.x, next.fxprime);
    phiPrime = dot2(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a3 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom(a0, a3, phi_old);
    }
    if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
      return a3;
    }
    if (phiPrime >= 0) {
      return zoom(a3, a0, phi2);
    }
    phi_old = phi2;
    a0 = a3;
    a3 *= 2;
  }
  return a3;
}

// node_modules/fmin/src/conjugateGradient.js
function conjugateGradient(f, initial, params) {
  var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a3 = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f(current.x, current.fxprime);
  pk = current.fxprime.slice();
  scale2(pk, current.fxprime, -1);
  for (var i = 0; i < maxIterations; ++i) {
    a3 = wolfeLineSearch(f, pk, current, next, a3);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a3
      });
    }
    if (!a3) {
      scale2(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot2(current.fxprime, current.fxprime), beta_k = Math.max(0, dot2(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a3
    });
  }
  return current;
}

// node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles);
  const innerPoints = intersectionPoints.filter(function(p2) {
    return containedInCircles(p2, circles);
  });
  let arcArea = 0, polygonArea = 0, i;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      const p3 = innerPoints[i];
      p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
    }
    innerPoints.sort(function(a3, b) {
      return b.angle - a3.angle;
    });
    let p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      const p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      let arc = null;
      for (let j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle2 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a22 = Math.atan2(p2.x - circle2.x, p2.y - circle2.y);
          let angleDiff = a22 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          const a3 = a22 - angleDiff / 2;
          let width = distance(midPoint, {
            x: circle2.x + circle2.radius * Math.sin(a3),
            y: circle2.y + circle2.radius * Math.cos(a3)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc === null || arc.width > width) {
            arc = { circle: circle2, width, p1, p2 };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p2 = p1;
      }
    }
  } else {
    let smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    let disjoint2 = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint2 = true;
        break;
      }
    }
    if (disjoint2) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point6, circles) {
  for (let i = 0; i < circles.length; ++i) {
    if (distance(point6, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i = 0; i < circles.length; ++i) {
    for (let j = i + 1; j < circles.length; ++j) {
      const intersect3 = circleCircleIntersection(circles[i], circles[j]);
      for (let k2 = 0; k2 < intersect3.length; ++k2) {
        const p2 = intersect3[k2];
        p2.parentIndex = [i, j];
        ret.push(p2);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d2) {
  if (d2 >= r1 + r2) {
    return 0;
  }
  if (d2 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  const w1 = r1 - (d2 * d2 - r2 * r2 + r1 * r1) / (2 * d2), w2 = r2 - (d2 * d2 - r1 * r1 + r2 * r2) / (2 * d2);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  const d2 = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d2 >= r1 + r2 || d2 <= Math.abs(r1 - r2)) {
    return [];
  }
  const a3 = (r1 * r1 - r2 * r2 + d2 * d2) / (2 * d2), h = Math.sqrt(r1 * r1 - a3 * a3), x05 = p1.x + a3 * (p2.x - p1.x) / d2, y05 = p1.y + a3 * (p2.y - p1.y) / d2, rx = -(p2.y - p1.y) * (h / d2), ry = -(p2.x - p1.x) * (h / d2);
  return [
    { x: x05 + rx, y: y05 - ry },
    { x: x05 - rx, y: y05 + ry }
  ];
}
function getCenter(points) {
  const center2 = { x: 0, y: 0 };
  for (let i = 0; i < points.length; ++i) {
    center2.x += points[i].x;
    center2.y += points[i].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}

// node_modules/@antv/g2/esm/data/utils/venn/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout;
  const loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  const circles = initialLayout(areas, parameters);
  const initial = [], setids = [];
  let setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  const solution = nelderMead(function(values3) {
    const current = {};
    for (let i = 0; i < setids.length; ++i) {
      const setid2 = setids[i];
      current[setid2] = {
        x: values3[2 * i],
        y: values3[2 * i + 1],
        radius: circles[setid2].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  const positions = solution.x;
  for (let i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs2 = {};
  let i, j, a3, b;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a3 = area2.sets[0];
      b = area2.sets[1];
      pairs2[[a3, b]] = true;
      pairs2[[b, a3]] = true;
    }
  }
  ids.sort((a4, b2) => {
    return a4 > b2 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a3 = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a3, b] in pairs2)) {
        areas.push({ sets: [a3, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x2) {
    return x2.sets.length == 2;
  }).map(function(current) {
    const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance2 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    let c4 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c4 = 1;
    } else if (current.size <= 1e-10) {
      c4 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c4;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x2, fxprime, distances, constraints) {
  let loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    const xi = x2[2 * i], yi = x2[2 * i + 1];
    for (let j = i + 1; j < distances.length; ++j) {
      const xj = x2[2 * j], yj = x2[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance2 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      if (constraint > 0 && distance2 <= dij || constraint < 0 && distance2 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  let initial = greedyLayout(areas, params);
  const loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  const restarts = params.restarts || 10;
  const sets = [], setids = {};
  let i;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  const matrices = getDistanceMatrices(areas, sets, setids);
  let distances = matrices.distances;
  const constraints = matrices.constraints;
  const norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  const obj = function(x2, fxprime) {
    return constrainedMDSGradient(x2, fxprime, distances, constraints);
  };
  let best, current;
  for (i = 0; i < restarts; ++i) {
    const initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  const positions = best.x;
  const circles = {};
  for (i = 0; i < sets.length; ++i) {
    const set2 = sets[i];
    circles[set2.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set2.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale2(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  const circles = {}, setOverlaps = {};
  let set2;
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      set2 = area2.sets[0];
      circles[set2] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set2] = [];
    }
  }
  areas = areas.filter(function(a3) {
    return a3.sets.length == 2;
  });
  for (let i = 0; i < areas.length; ++i) {
    const current = areas[i];
    let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight2 = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
    setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
  }
  const mostOverlapped = [];
  for (set2 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set2)) {
      let size3 = 0;
      for (let i = 0; i < setOverlaps[set2].length; ++i) {
        size3 += setOverlaps[set2][i].size * setOverlaps[set2][i].weight;
      }
      mostOverlapped.push({ set: set2, size: size3 });
    }
  }
  function sortOrder(a3, b) {
    return b.size - a3.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point6, index2) {
    circles[index2].x = point6.x;
    circles[index2].y = point6.y;
    positioned[index2] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (let i = 1; i < mostOverlapped.length; ++i) {
    const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
    set2 = circles[setIndex];
    overlap.sort(sortOrder);
    if (overlap.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    const points = [];
    for (let j = 0; j < overlap.length; ++j) {
      const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set2.radius, p1.radius, overlap[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (let k2 = j + 1; k2 < overlap.length; ++k2) {
        const p2 = circles[overlap[k2].set], d2 = distanceFromIntersectArea(set2.radius, p2.radius, overlap[k2].size);
        const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (let l = 0; l < extraPoints.length; ++l) {
          points.push(extraPoints[l]);
        }
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  let output = 0;
  function getCircles(indices) {
    return indices.map(function(i) {
      return sets[i];
    });
  }
  for (let i = 0; i < overlaps.length; ++i) {
    const area2 = overlaps[i];
    let overlap;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap = circleOverlap(left2.radius, right2.radius, distance(left2, right2));
    } else {
      overlap = intersectionArea(getCircles(area2.sets));
    }
    const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight2 * (overlap - area2.size) * (overlap - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  const minMax = function(d2) {
    const hi = Math.max.apply(null, circles.map(function(c4) {
      return c4[d2] + c4.radius;
    })), lo = Math.min.apply(null, circles.map(function(c4) {
      return c4[d2] - c4.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding) {
  const circles = [], setids = [];
  for (const setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding;
  height -= 2 * padding;
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  const scaled = {};
  for (let i = 0; i < circles.length; ++i) {
    const circle2 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle2.radius,
      x: padding + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2/esm/data/utils/venn/diagram.js
function circlePath(x2, y2, r) {
  const ret = [];
  const x05 = x2 - r;
  const y05 = y2;
  ret.push("M", x05, y05);
  ret.push("A", r, r, 0, 1, 0, x05 + 2 * r, y05);
  ret.push("A", r, r, 0, 1, 0, x05, y05);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  const stats = {};
  intersectionArea(circles, stats);
  const arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    const circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (let i = 0; i < arcs.length; ++i) {
      const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2/esm/data/venn.js
var Venn = (options) => {
  const { sets = "sets", size: size3 = "size", as = ["key", "path"], padding = 0 } = options;
  const [key, path2] = as;
  return (data) => {
    const vennData = data.map((d2) => Object.assign(Object.assign({}, d2), { sets: d2[sets], size: d2[size3], [key]: d2.sets.join("&") }));
    vennData.sort((a3, b) => a3.sets.length - b.sets.length);
    const solution = venn(vennData);
    let circles;
    return vennData.map((datum) => {
      const setsValue = datum[sets];
      const pathFunc = ({ width, height }) => {
        circles = circles ? circles : scaleSolution(solution, width, height, padding);
        const setCircles = setsValue.map((set2) => circles[set2]);
        let p2 = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(p2))
          p2 += " Z";
        return p2;
      };
      return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
    });
  };
};
Venn.props = {};

// node_modules/@antv/g2/esm/data/log.js
var Log3 = () => {
  return (data) => {
    console.log("G2 data section:", data);
    return data;
  };
};
Log3.props = {};

// node_modules/@antv/g2/esm/data/ema.js
function ema(values3, alpha) {
  if (alpha < 0 || alpha > 1) {
    throw new Error("alpha must be between 0 and 1.");
  }
  if (values3.length === 0) {
    return [];
  }
  let last5 = values3[0];
  const smoothed = [];
  for (const point6 of values3) {
    if (point6 === null || point6 === void 0) {
      smoothed.push(point6);
      console.warn("EMAThe value is null or undefined", values3);
      continue;
    }
    if (last5 === null || last5 === void 0) {
      last5 = point6;
    }
    const smoothedVal = last5 * alpha + (1 - alpha) * point6;
    smoothed.push(smoothedVal);
    last5 = smoothedVal;
  }
  return smoothed;
}
var EMA = (options) => {
  const { field: field3 = "y", alpha = 0.6, as = field3 } = options;
  return (data) => {
    const values3 = data.map((d2) => {
      return d2[field3];
    });
    const out = ema(values3, alpha);
    return data.map((d2, i) => {
      return Object.assign(Object.assign({}, d2), { [as]: out[i] });
    });
  };
};
EMA.props = {};

// node_modules/@antv/g2/esm/utils/bounds.js
function parseAABB(min22) {
  const { min: min6, max: max6 } = min22;
  return [
    [min6[0], min6[1]],
    [max6[0], max6[1]]
  ];
}
function isInBounds(point6, bounds) {
  const [x2, y2] = point6;
  const [min6, max6] = bounds;
  return x2 >= min6[0] && x2 <= max6[0] && y2 >= min6[1] && y2 <= max6[1];
}
function isOverflow(b1, b2) {
  const [min6, max6] = b1;
  return !(isInBounds(min6, b2) && isInBounds(max6, b2));
}
function isOverlap(b1, b2) {
  const [min1, max1] = b1;
  const [min22, max22] = b2;
  return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
}

// node_modules/@antv/g2/esm/label-transform/overlapHide.js
var OverlapHide = (options) => {
  const { priority } = options;
  return (labels) => {
    const displayLabels = [];
    if (priority)
      labels.sort(priority);
    labels.forEach((l) => {
      show(l);
      const b1 = l.getLocalBounds();
      const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
      if (overlaping)
        hide(l);
      else
        displayLabels.push(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
function isSegmentIntersect([a3, b], [c4, d2]) {
  return d2 > a3 && b > c4;
}
function useMap() {
  const map5 = /* @__PURE__ */ new Map();
  const get3 = (key) => map5.get(key);
  const set2 = (key, value2) => map5.set(key, value2);
  return [get3, set2];
}
function getBoundsWithoutConnector(shape23) {
  const node = shape23.cloneNode(true);
  const connectorShape = node.getElementById("connector");
  connectorShape && node.removeChild(connectorShape);
  const { min: min6, max: max6 } = node.getRenderBounds();
  node.destroy();
  return { min: min6, max: max6 };
}
var OverlapDodgeY = (options) => {
  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
  return (labels) => {
    const n = labels.length;
    if (n <= 1)
      return labels;
    const [y05, setY0] = useMap();
    const [y2, setY] = useMap();
    const [h, setH] = useMap();
    const [xx, setXX] = useMap();
    for (const label of labels) {
      const { min: min6, max: max6 } = getBoundsWithoutConnector(label);
      const [x05, y06] = min6;
      const [x12, y12] = max6;
      setY0(label, y06);
      setY(label, y06);
      setH(label, y12 - y06);
      setXX(label, [x05, x12]);
    }
    for (let iter = 0; iter < maxIterations; iter++) {
      labels.sort((a3, b) => ascending(y2(a3), y2(b)));
      let error2 = 0;
      for (let i = 0; i < n - 1; i++) {
        const l0 = labels[i];
        let j = i + 1;
        let l1;
        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
          j += 1;
        if (l1) {
          const y06 = y2(l0);
          const h0 = h(l0);
          const y12 = y2(l1);
          const delta = y12 - (y06 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            error2 = Math.max(error2, newDelta);
            setY(l0, y06 - newDelta);
            setY(l1, y12 + newDelta);
          }
        }
      }
      if (error2 < maxError)
        break;
    }
    for (const label of labels) {
      label.style.y += y2(label) - y05(label);
    }
    return labels;
  };
};

// node_modules/@antv/g2/esm/utils/color.js
function parseToRGB(c4) {
  if (typeof c4 === "object")
    return c4;
  return parseColor(c4);
}

// node_modules/@antv/g2/esm/label-transform/contrastReverse.js
function getsRGB(s2) {
  let c4 = s2 / 255;
  c4 = c4 <= 0.03928 ? c4 / 12.92 : Math.pow((c4 + 0.055) / 1.055, 2.4);
  return c4;
}
function getL(r, g, b) {
  return 0.2126 * getsRGB(r) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
}
function contrast(foreground, background) {
  if (!foreground || !background || foreground === background)
    return 1;
  const { r, g, b } = foreground;
  const { r: rb, g: gb, b: bb } = background;
  const L1 = getL(r, g, b);
  const L2 = getL(rb, gb, bb);
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}
function mostContrast(color2, palette) {
  const i = maxIndex(palette, (c4) => contrast(color2, parseToRGB(c4)));
  return palette[i];
}
var ContrastReverse = (options) => {
  const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
  return (labels) => {
    labels.forEach((l) => {
      const background = l.attr("dependentElement").parsedStyle.fill;
      const foreground = l.parsedStyle.fill;
      const c4 = contrast(foreground, background);
      if (c4 < threshold)
        l.attr("fill", mostContrast(background, palette));
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowHide.js
var OverflowHide = () => {
  return (labels) => {
    labels.forEach((l) => {
      show(l);
      const bounds = l.attr("bounds");
      const b = l.getLocalBounds();
      const overflow = isOverflow(parseAABB(b), bounds);
      if (overflow)
        hide(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
var adjustPosition = (target, edge) => {
  const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
  const [[minX, minY], [maxX, maxY2]] = target;
  let changeX = 0, changeY = 0;
  if (minX < minEdgeX) {
    changeX = minEdgeX - minX;
  } else if (maxX > maxEdgeX) {
    changeX = maxEdgeX - maxX;
  }
  if (minY < minEdgeY) {
    changeY = minEdgeY - minY;
  } else if (maxY2 > maxEdgeY) {
    changeY = maxEdgeY - maxY2;
  }
  return [changeX, changeY];
};
var ExceedAdjust = () => {
  return (labels, { canvas, layout }) => {
    labels.forEach((l) => {
      show(l);
      const { max: max6, min: min6 } = l.getRenderBounds();
      const [xMax, yMax] = max6, [xMin, yMin] = min6;
      const changeValue = adjustPosition(
        [
          [xMin, yMin],
          [xMax, yMax]
        ],
        // Prevent label overlap in multiple charts by calculating layouts separately to avoid collisions.
        [
          [layout.x, layout.y],
          [layout.x + layout.width, layout.y + layout.height]
        ]
      );
      if (l.style.connector && l.style.connectorPoints) {
        l.style.connectorPoints[0][0] -= changeValue[0];
        l.style.connectorPoints[0][1] -= changeValue[1];
      }
      l.style.x += changeValue[0];
      l.style.y += changeValue[1];
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/lib/core.js
function corelib() {
  return {
    "data.fetch": Fetch,
    "data.inline": Inline,
    "data.sortBy": SortBy,
    "data.sort": Sort2,
    "data.filter": Filter2,
    "data.pick": Pick,
    "data.rename": Rename,
    "data.fold": Fold,
    "data.slice": Slice,
    "data.custom": Custom,
    "data.map": Map2,
    "data.join": Join,
    "data.kde": KDE,
    "data.log": Log3,
    "data.wordCloud": WordCloud2,
    "data.ema": EMA,
    "transform.stackY": StackY,
    "transform.binX": BinX,
    "transform.bin": Bin,
    "transform.dodgeX": DodgeX,
    "transform.jitter": Jitter,
    "transform.jitterX": JitterX,
    "transform.jitterY": JitterY,
    "transform.symmetryY": SymmetryY,
    "transform.diffY": DiffY,
    "transform.stackEnter": StackEnter,
    "transform.normalizeY": NormalizeY,
    "transform.select": Select,
    "transform.selectX": SelectX,
    "transform.selectY": SelectY,
    "transform.groupX": GroupX,
    "transform.groupY": GroupY,
    "transform.groupColor": GroupColor,
    "transform.group": Group2,
    "transform.sortX": SortX,
    "transform.sortY": SortY,
    "transform.sortColor": SortColor,
    "transform.flexX": FlexX,
    "transform.pack": Pack,
    "transform.sample": Sample,
    "transform.filter": Filter,
    "coordinate.cartesian": Cartesian,
    "coordinate.polar": Polar,
    "coordinate.transpose": Transpose,
    "coordinate.theta": Theta,
    "coordinate.parallel": Parallel,
    "coordinate.fisheye": Fisheye,
    "coordinate.radial": Radial,
    "coordinate.radar": Radar,
    "encode.constant": Constant2,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "mark.rect": Rect3,
    "mark.line": Line5,
    "mark.point": Point3,
    "mark.text": Text3,
    "mark.cell": Cell,
    "mark.area": Area2,
    "mark.link": Link2,
    "mark.image": Image4,
    "mark.polygon": Polygon3,
    "mark.box": Box2,
    "mark.vector": Vector2,
    "mark.lineX": LineX,
    "mark.lineY": LineY,
    "mark.connector": Connector2,
    "mark.range": Range,
    "mark.rangeX": RangeX,
    "mark.rangeY": RangeY,
    "mark.path": Path4,
    "mark.shape": Shape3,
    "mark.density": Density2,
    "mark.heatmap": Heatmap2,
    "mark.wordCloud": WordCloud,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point4,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential2,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "theme.classicDark": ClassicDark,
    "theme.academy": Academy,
    "theme.light": Light,
    "theme.dark": Dark,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.zoomIn": ZoomIn,
    "animation.zoomOut": ZoomOut,
    "animation.pathIn": PathIn,
    "animation.morphing": Morphing,
    "animation.growInX": GrowInX,
    "animation.growInY": GrowInY,
    "interaction.elementHighlight": ElementHighlight,
    "interaction.elementHighlightByX": ElementHighlightByX,
    "interaction.elementHighlightByColor": ElementHighlightByColor,
    "interaction.elementSelect": ElementSelect,
    "interaction.elementSelectByX": ElementSelectByX,
    "interaction.elementSelectByColor": ElementSelectByColor,
    "interaction.fisheye": Fisheye2,
    "interaction.chartIndex": ChartIndex,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.brushHighlight": BrushHighlight,
    "interaction.brushXHighlight": BrushXHighlight,
    "interaction.brushYHighlight": BrushYHighlight,
    "interaction.brushAxisHighlight": BrushAxisHighlight,
    "interaction.brushFilter": BrushFilter,
    "interaction.brushXFilter": BrushXFilter,
    "interaction.brushYFilter": BrushYFilter,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip,
    "interaction.treemapDrillDown": TreemapDrillDown,
    "interaction.elementPointMove": ElementPointMove,
    "composition.spaceLayer": SpaceLayer,
    "composition.spaceFlex": SpaceFlex,
    "composition.facetRect": FacetRect,
    "composition.repeatMatrix": RepeatMatrix,
    "composition.facetCircle": FacetCircle,
    "composition.timingKeyframe": TimingKeyframe,
    "labelTransform.overlapHide": OverlapHide,
    "labelTransform.overlapDodgeY": OverlapDodgeY,
    "labelTransform.overflowHide": OverflowHide,
    "labelTransform.contrastReverse": ContrastReverse,
    "labelTransform.exceedAdjust": ExceedAdjust
  };
}

// node_modules/@antv/g2/esm/lib/geo.js
function geolib() {
  return {
    "composition.geoView": GeoView,
    "composition.geoPath": GeoPath
  };
}

// node_modules/@antv/g2/esm/lib/graph.js
function graphlib() {
  return {
    "data.arc": Arc3,
    "data.cluster": Cluster,
    "mark.forceGraph": ForceGraph,
    "mark.tree": Tree2,
    "mark.pack": Pack2,
    "mark.sankey": Sankey3,
    "mark.chord": Chord,
    "mark.treemap": Treemap
  };
}

// node_modules/@antv/g2/esm/lib/plot.js
function plotlib() {
  return {
    "data.venn": Venn,
    "mark.boxplot": Boxplot,
    "mark.gauge": Gauge,
    "mark.wordCloud": WordCloud,
    "mark.liquid": Liquid2
  };
}

// node_modules/@antv/g2/esm/lib/std.js
function stdlib() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
}

// node_modules/@antv/g2/esm/api/extend.js
function extend4(Runtime2, library3) {
  class Chart4 extends Runtime2 {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { lib: library3 }));
    }
  }
  return Chart4;
}

// node_modules/@antv/g2/esm/api/library.js
var library = {};
function register(key, component) {
  if (key.startsWith("symbol."))
    registerSymbol(key.split(".").pop(), component);
  else
    Object.assign(library, { [key]: component });
}

// node_modules/@antv/g2/esm/utils/size.js
var parseInt10 = (d2) => d2 ? parseInt(d2) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return {
    width: wrapperWidth - widthPadding,
    height: wrapperHeight - heightPadding
  };
}

// node_modules/@antv/g2/esm/api/node.js
function bfs(node, callback) {
  const discovered = [node];
  while (discovered.length) {
    const currentNode = discovered.shift();
    callback && callback(currentNode);
    const children = currentNode.children || [];
    for (const child of children) {
      discovered.push(child);
    }
  }
}
var Node3 = class {
  constructor(value2 = {}, type) {
    this.parentNode = null;
    this.children = [];
    this.index = 0;
    this.type = type;
    this.value = value2;
  }
  /**
   * Apply specified transform to current value. Mount the node
   * to replace the original one in the tree and then return it.
   */
  map(transform = (x2) => x2) {
    const newValue = transform(this.value);
    this.value = newValue;
    return this;
  }
  /**
   * Set or get the specified attribute. It the value is specified, update
   * the attribute of current value and return the node. Otherwise
   * return the the attribute of current value.
   */
  attr(key, value2) {
    if (arguments.length === 1)
      return this.value[key];
    return this.map((v) => (v[key] = value2, v));
  }
  /**
   * Create a new node and append to children nodes.
   */
  append(Ctor) {
    const node = new Ctor({});
    node.children = [];
    this.push(node);
    return node;
  }
  push(node) {
    node.parentNode = this;
    node.index = this.children.length;
    this.children.push(node);
    return this;
  }
  /**
   * Remove current node from parentNode.
   */
  remove() {
    const parent = this.parentNode;
    if (parent) {
      const { children } = parent;
      const index2 = children.findIndex((item) => item === this);
      children.splice(index2, 1);
    }
    return this;
  }
  getNodeByKey(key) {
    let targetNode = null;
    const callback = (node) => {
      if (key === node.attr("key")) {
        targetNode = node;
      }
    };
    bfs(this, callback);
    return targetNode;
  }
  getNodesByType(type) {
    const nodes = [];
    const callback = (node) => {
      if (type === node.type) {
        nodes.push(node);
      }
    };
    bfs(this, callback);
    return nodes;
  }
  getNodeByType(type) {
    let node = null;
    bfs(this, (current) => {
      if (node)
        return;
      if (type === current.type)
        node = current;
    });
    return node;
  }
  /**
   * Apply specified callback to the node value.
   */
  call(callback, ...params) {
    callback(this.map(), ...params);
    return this;
  }
  getRoot() {
    let root = this;
    while (root && root.parentNode) {
      root = root.parentNode;
    }
    return root;
  }
};

// node_modules/@antv/g2/esm/api/utils.js
var __rest88 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var VIEW_KEYS = [
  "width",
  "height",
  "depth",
  "padding",
  "paddingLeft",
  "paddingRight",
  "paddingBottom",
  "paddingTop",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "margin",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginBottom",
  "autoFit",
  "theme",
  "title",
  "interaction"
];
var REMOVE_FLAG = "__remove__";
var CALLBACK_NODE = "__callback__";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
function normalizeContainer2(container) {
  if (container === void 0) {
    const container2 = document.createElement("div");
    container2[REMOVE_FLAG] = true;
    return container2;
  }
  if (typeof container === "string") {
    const node = document.getElementById(container);
    return node;
  }
  return container;
}
function removeContainer(container) {
  const parent = container.parentNode;
  if (parent) {
    parent.removeChild(container);
  }
}
function normalizeRoot(node) {
  if (node.type !== null)
    return node;
  const root = node.children[node.children.length - 1];
  for (const key of VIEW_KEYS)
    root.attr(key, node.attr(key));
  return root;
}
function valueOf3(node) {
  return Object.assign(Object.assign({}, node.value), { type: node.type });
}
function sizeOf2(options, container) {
  const { width, height, autoFit, depth = 0 } = options;
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  if (autoFit) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
  }
  effectiveWidth = width || effectiveWidth;
  effectiveHeight = height || effectiveHeight;
  return {
    width: Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    depth
  };
}
function optionsOf(node) {
  const root = normalizeRoot(node);
  const discovered = [root];
  const nodeValue = /* @__PURE__ */ new Map();
  nodeValue.set(root, valueOf3(root));
  while (discovered.length) {
    const node2 = discovered.pop();
    const value2 = nodeValue.get(node2);
    const { children = [] } = node2;
    for (const child of children) {
      if (child.type === CALLBACK_NODE) {
        value2.children = child.value;
      } else {
        const childValue = valueOf3(child);
        const { children: children2 = [] } = value2;
        children2.push(childValue);
        discovered.push(child);
        nodeValue.set(child, childValue);
        value2.children = children2;
      }
    }
  }
  return nodeValue.get(root);
}
function isMark(type, mark2) {
  if (typeof type === "function")
    return true;
  return new Set(Object.keys(mark2)).has(type);
}
function isComposition(type, composition) {
  return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
}
function normalizeRootOptions(node, options, previousType, marks, composition) {
  const { type: oldType } = node;
  const { type = previousType || oldType } = options;
  if (isComposition(type, composition)) {
    for (const key of VIEW_KEYS) {
      if (node.attr(key) !== void 0 && options[key] === void 0) {
        options[key] = node.attr(key);
      }
    }
    return options;
  }
  if (isMark(type, marks)) {
    const view = { type: "view" };
    const mark2 = Object.assign({}, options);
    for (const key of VIEW_KEYS) {
      if (mark2[key] !== void 0) {
        view[key] = mark2[key];
        delete mark2[key];
      }
    }
    return Object.assign(Object.assign({}, view), { children: [mark2] });
  }
  return options;
}
function typeCtor(type, mark2, composition) {
  if (typeof type === "function")
    return mark2.mark;
  const node = Object.assign(Object.assign({}, mark2), composition);
  const ctor = node[type];
  if (!ctor)
    throw new Error(`Unknown mark: ${type}.`);
  return ctor;
}
function createNode2(options, mark2, composition) {
  if (typeof options === "function") {
    const node2 = new Node3();
    node2.value = options;
    node2.type = CALLBACK_NODE;
    return node2;
  }
  const { type, children } = options, value2 = __rest88(options, ["type", "children"]);
  const Ctor = typeCtor(type, mark2, composition);
  const node = new Ctor();
  node.value = value2;
  node.type = type;
  return node;
}
function updateNode(node, newOptions) {
  const { type, children } = newOptions, value2 = __rest88(newOptions, ["type", "children"]);
  if (node.type === type || type === void 0) {
    deepAssign(node.value, value2);
  } else if (typeof type === "string") {
    node.type = type;
    node.value = value2;
  }
}
function appendNode(parent, newOptions, mark2, composition) {
  if (!parent)
    return;
  const discovered = [[parent, newOptions]];
  while (discovered.length) {
    const [parent2, nodeOptions] = discovered.shift();
    const node = createNode2(nodeOptions, mark2, composition);
    if (Array.isArray(parent2.children))
      parent2.push(node);
    const { children } = nodeOptions;
    if (Array.isArray(children)) {
      for (const child of children) {
        discovered.push([node, child]);
      }
    } else if (typeof children === "function") {
      discovered.push([node, children]);
    }
  }
}
function updateRoot(node, options, definedType, mark2, composition) {
  const rootOptions = normalizeRootOptions(node, options, definedType, mark2, composition);
  const discovered = [[null, node, rootOptions]];
  while (discovered.length) {
    const [parent, oldNode, newNode] = discovered.shift();
    if (!oldNode) {
      appendNode(parent, newNode, mark2, composition);
    } else if (!newNode) {
      oldNode.remove();
    } else {
      updateNode(oldNode, newNode);
      const { children: newChildren } = newNode;
      const { children: oldChildren } = oldNode;
      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
        const n = Math.max(newChildren.length, oldChildren.length);
        for (let i = 0; i < n; i++) {
          const newChild = newChildren[i];
          const oldChild = oldChildren[i];
          discovered.push([oldNode, oldChild, newChild]);
        }
      } else if (typeof newChildren === "function") {
        discovered.push([oldNode, null, newChildren]);
      }
    }
  }
}
function createEmptyPromise() {
  let reject;
  let resolve;
  const cloned = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [cloned, resolve, reject];
}

// node_modules/@antv/g2/esm/api/define.js
function defineValueProp(Node4, name2, { key = name2 }) {
  Node4.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    return this.attr(key, value2);
  };
}
function defineArrayProp(Node4, name2, { key = name2 }) {
  Node4.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    if (Array.isArray(value2))
      return this.attr(key, value2);
    const array2 = [...this.attr(key) || [], value2];
    return this.attr(key, array2);
  };
}
function defineObjectProp(Node4, name2, { key: k2 = name2 }) {
  Node4.prototype[name2] = function(key, value2) {
    if (arguments.length === 0)
      return this.attr(k2);
    if (arguments.length === 1 && typeof key !== "string") {
      return this.attr(k2, key);
    }
    const obj = this.attr(k2) || {};
    obj[key] = arguments.length === 1 ? true : value2;
    return this.attr(k2, obj);
  };
}
function defineMixProp(Node4, name2, descriptor) {
  Node4.prototype[name2] = function(key) {
    if (arguments.length === 0)
      return this.attr(name2);
    if (Array.isArray(key))
      return this.attr(name2, { items: key });
    if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
      return this.attr(name2, key);
    }
    if (key === null || key === false)
      return this.attr(name2, key);
    const obj = this.attr(name2) || {};
    const { items = [] } = obj;
    items.push(key);
    obj.items = items;
    return this.attr(name2, obj);
  };
}
function defineNodeProp(Node4, name2, { ctor }) {
  Node4.prototype[name2] = function(hocMark) {
    const node = this.append(ctor);
    if (name2 === "mark") {
      node.type = hocMark;
    }
    return node;
  };
}
function defineContainerProp(Node4, name2, { ctor }) {
  Node4.prototype[name2] = function() {
    this.type = null;
    return this.append(ctor);
  };
}
function defineProps(descriptors) {
  return (Node4) => {
    for (const [name2, descriptor] of Object.entries(descriptors)) {
      const { type } = descriptor;
      if (type === "value")
        defineValueProp(Node4, name2, descriptor);
      else if (type === "array")
        defineArrayProp(Node4, name2, descriptor);
      else if (type === "object")
        defineObjectProp(Node4, name2, descriptor);
      else if (type === "node")
        defineNodeProp(Node4, name2, descriptor);
      else if (type === "container")
        defineContainerProp(Node4, name2, descriptor);
      else if (type === "mix")
        defineMixProp(Node4, name2, descriptor);
    }
    return Node4;
  };
}
function nodeProps(node) {
  return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
}

// node_modules/@antv/g2/esm/api/props.js
var commonProps = {
  encode: { type: "object" },
  scale: { type: "object" },
  data: { type: "value" },
  transform: { type: "array" },
  style: { type: "object" },
  animate: { type: "object" },
  coordinate: { type: "object" },
  interaction: { type: "object" },
  label: { type: "array", key: "labels" },
  axis: { type: "object" },
  legend: { type: "object" },
  slider: { type: "object" },
  scrollbar: { type: "object" },
  state: { type: "object" },
  layout: { type: "object" },
  theme: { type: "object" },
  title: { type: "value" }
};
var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

// node_modules/@antv/g2/esm/api/composition.js
var __decorate = function(decorators, target, key, desc) {
  var c4 = arguments.length, r = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c4 < 3 ? d2(r) : c4 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c4 > 3 && r && Object.defineProperty(target, key, r), r;
};
var CompositionNode = class CompositionNode2 extends Node3 {
  /**
   * Change current node data and its children data.
   */
  changeData(data) {
    var _a;
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data);
    if ((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) {
      this.children.forEach((child) => {
        child.attr("data", data);
      });
    }
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get view instance by key.
   */
  getView() {
    const chart = this.getRoot();
    const { views } = chart.getContext();
    if (!(views === null || views === void 0 ? void 0 : views.length))
      return void 0;
    return views.find((view) => view.key === this._key);
  }
  getScale() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.scale;
  }
  getScaleByChannel(channel) {
    const scale3 = this.getScale();
    if (scale3)
      return scale3[channel];
    return;
  }
  getCoordinate() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.coordinate;
  }
  getTheme() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.theme;
  }
  getGroup() {
    const key = this._key;
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
  /**
   * Show the view.
   */
  show() {
    const group2 = this.getGroup();
    if (!group2)
      return;
    !group2.isVisible() && show(group2);
  }
  /**
   * Hide the view.
   */
  hide() {
    const group2 = this.getGroup();
    if (!group2)
      return;
    group2.isVisible() && hide(group2);
  }
};
CompositionNode = __decorate([
  defineProps(compositionProps)
], CompositionNode);

// node_modules/@antv/g2/esm/api/mark.js
var __decorate2 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c4 < 3 ? d2(r) : c4 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c4 > 3 && r && Object.defineProperty(target, key, r), r;
};
var MarkNode = class MarkNode2 extends Node3 {
  changeData(data) {
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data);
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get mark from chart views.
   */
  getMark() {
    var _a;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    const { markState } = chartView;
    const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
    return markState.get(markKey);
  }
  /**
   * Get all scales instance.
   */
  getScale() {
    var _a;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
  }
  /**
   * Get the scale instance by channel.
   */
  getScaleByChannel(channel) {
    var _a, _b;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
  }
  /**
   * Get canvas group.
   */
  getGroup() {
    const key = this.attr("key");
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
};
MarkNode = __decorate2([
  defineProps(markProps)
], MarkNode);

// node_modules/@antv/g2/esm/api/runtime.js
var __decorate3 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c4 < 3 ? d2(r) : c4 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c4 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest89 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var G2_CHART_KEY = "G2_CHART_KEY";
var Runtime = class extends CompositionNode {
  constructor(options) {
    const { container, canvas, renderer, plugins, lib, createCanvas } = options, rest = __rest89(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
    super(rest, "view");
    this._hasBindAutoFit = false;
    this._rendering = false;
    this._trailing = false;
    this._trailingResolve = null;
    this._trailingReject = null;
    this._previousDefinedType = null;
    this._onResize = debounce_default(() => {
      this.forceFit();
    }, 300);
    this._renderer = renderer || new Renderer();
    this._plugins = plugins || [];
    this._container = normalizeContainer2(container);
    this._emitter = new esm_default();
    this._context = {
      library: Object.assign(Object.assign({}, lib), library),
      emitter: this._emitter,
      canvas,
      createCanvas
    };
    this._create();
  }
  render() {
    if (this._rendering)
      return this._addToTrailing();
    if (!this._context.canvas)
      this._createCanvas();
    this._context.canvas.getConfig().supportsCSSTransform = true;
    this._bindAutoFit();
    this._rendering = true;
    const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
    const [finished1, resolve, reject] = createEmptyPromise();
    finished.then(resolve).catch(reject).then(() => this._renderTrailing());
    return finished1;
  }
  /**
   * @overload
   * @param {G2ViewTree} [options]
   * @returns {Runtime|Spec}
   */
  options(options) {
    if (arguments.length === 0)
      return optionsOf(this);
    const { type } = options;
    if (type)
      this._previousDefinedType = type;
    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
    return this;
  }
  getContainer() {
    return this._container;
  }
  getContext() {
    return this._context;
  }
  on(event, callback, once) {
    this._emitter.on(event, callback, once);
    return this;
  }
  once(event, callback) {
    this._emitter.once(event, callback);
    return this;
  }
  emit(event, ...args) {
    this._emitter.emit(event, ...args);
    return this;
  }
  off(event, callback) {
    this._emitter.off(event, callback);
    return this;
  }
  clear() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_CLEAR);
    this._reset();
    destroy(options, this._context, false);
    this.emit(ChartEvent.AFTER_CLEAR);
  }
  destroy() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_DESTROY);
    this._unbindAutoFit();
    this._reset();
    destroy(options, this._context, true);
    if (this._container[REMOVE_FLAG])
      removeContainer(this._container);
    this.emit(ChartEvent.AFTER_DESTROY);
  }
  forceFit() {
    this.options["autoFit"] = true;
    const { width, height } = sizeOf2(this.options(), this._container);
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  changeSize(width, height) {
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    this.attr("width", width);
    this.attr("height", height);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  _create() {
    const { library: library3 } = this._context;
    const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
    const marks = [
      "mark.mark",
      ...Object.keys(library3).filter(isMark2)
    ];
    this._marks = {};
    for (const key of marks) {
      const name2 = key.split(".").pop();
      class Mark2 extends MarkNode {
        constructor() {
          super({}, name2);
        }
      }
      this._marks[name2] = Mark2;
      this[name2] = function(composite) {
        const node = this.append(Mark2);
        if (name2 === "mark")
          node.type = composite;
        return node;
      };
    }
    const compositions = [
      "composition.view",
      ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
    ];
    this._compositions = Object.fromEntries(compositions.map((key) => {
      const name2 = key.split(".").pop();
      let Composition = class Composition extends CompositionNode {
        constructor() {
          super({}, name2);
        }
      };
      Composition = __decorate3([
        defineProps(nodeProps(this._marks))
      ], Composition);
      return [name2, Composition];
    }));
    for (const Ctor of Object.values(this._compositions)) {
      defineProps(nodeProps(this._compositions))(Ctor);
    }
    for (const key of compositions) {
      const name2 = key.split(".").pop();
      this[name2] = function() {
        const Composition = this._compositions[name2];
        this.type = null;
        return this.append(Composition);
      };
    }
  }
  _reset() {
    const KEYS = ["theme", "type", "width", "height", "autoFit"];
    this.type = "view";
    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
    this.children = [];
  }
  _renderTrailing() {
    if (!this._trailing)
      return;
    this._trailing = false;
    this.render().then(() => {
      const trailingResolve = this._trailingResolve.bind(this);
      this._trailingResolve = null;
      trailingResolve(this);
    }).catch((error2) => {
      const trailingReject = this._trailingReject.bind(this);
      this._trailingReject = null;
      trailingReject(error2);
    });
  }
  _createResolve(resolve) {
    return () => {
      this._rendering = false;
      resolve(this);
    };
  }
  _createReject(reject) {
    return (error2) => {
      this._rendering = false;
      reject(error2);
    };
  }
  // Update actual size and key.
  _computedOptions() {
    const options = this.options();
    const { key = G2_CHART_KEY } = options;
    const { width, height, depth } = sizeOf2(options, this._container);
    this._width = width;
    this._height = height;
    this._key = key;
    return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
  }
  // Create canvas if it does not exist.
  // DragAndDropPlugin is for interaction.
  // It is OK to register more than one time, G will handle this.
  _createCanvas() {
    const { width, height } = sizeOf2(this.options(), this._container);
    this._plugins.push(new Plugin());
    this._plugins.forEach((d2) => this._renderer.registerPlugin(d2));
    this._context.canvas = new Canvas({
      container: this._container,
      width,
      height,
      renderer: this._renderer
    });
  }
  _addToTrailing() {
    var _a;
    (_a = this._trailingResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);
    this._trailing = true;
    const promise = new Promise((resolve, reject) => {
      this._trailingResolve = resolve;
      this._trailingReject = reject;
    });
    return promise;
  }
  _bindAutoFit() {
    const options = this.options();
    const { autoFit } = options;
    if (this._hasBindAutoFit) {
      if (!autoFit)
        this._unbindAutoFit();
      return;
    }
    if (autoFit) {
      this._hasBindAutoFit = true;
      window.addEventListener("resize", this._onResize);
    }
  }
  _unbindAutoFit() {
    if (this._hasBindAutoFit) {
      this._hasBindAutoFit = false;
      window.removeEventListener("resize", this._onResize);
    }
  }
};

// node_modules/@antv/g2/esm/api/chart.js
var Chart = extend4(Runtime, library);

// node_modules/@antv/g2/esm/index.js
var library2 = Object.assign({}, stdlib());
var Chart2 = extend4(Runtime, library2);

// node_modules/@ant-design/plots/es/components/base/index.js
var import_react2 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useChart.js
var import_react = __toESM(require_react());

// node_modules/@ant-design/plots/es/util/index.js
var import_lodash = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/util/is-valid-element.js
var isValidElement = function(jsxCode) {
  var jsxRegex = /react|\.jsx|children:\[\(|return\s+[A-Za-z0-9].createElement\((?!['"][g|circle|ellipse|image|rect|line|polyline|polygon|text|path|html|mesh]['"])([^\)])*,/i;
  return jsxRegex.test(jsxCode);
};

// node_modules/@ant-design/plots/es/hooks/useChart.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function useChart(ChartClass, config) {
  var chart = (0, import_react.useRef)();
  var chartOptions = (0, import_react.useRef)();
  var container = (0, import_react.useRef)(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type, encoderOptions) {
    var _a;
    if (type === void 0) {
      type = "image/png";
    }
    var canvas = (_a = container.current) === null || _a === void 0 ? void 0 : _a.getElementsByTagName("canvas")[0];
    return canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(type, encoderOptions);
  };
  var downloadImage = function(name2, type, encoderOptions) {
    if (name2 === void 0) {
      name2 = "download";
    }
    if (type === void 0) {
      type = "image/png";
    }
    var imageName = name2;
    if (name2.indexOf(".") === -1) {
      imageName = "".concat(name2, ".").concat(type.split("/")[1]);
    }
    var base64 = toDataURL(type, encoderOptions);
    var a3 = document.createElement("a");
    a3.href = base64;
    a3.download = imageName;
    document.body.appendChild(a3);
    a3.click();
    document.body.removeChild(a3);
    a3 = null;
    return imageName;
  };
  var processConfig = function(cfg, flag) {
    if (flag === void 0) {
      flag = false;
    }
    var keys = Object.keys(cfg);
    var isTooltip = flag;
    keys.forEach(function(key) {
      var current = cfg[key];
      if (key === "tooltip") {
        isTooltip = true;
      }
      if ((0, import_lodash.isFunction)(current) && isValidElement("".concat(current))) {
        cfg[key] = function() {
          var arg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
          }
          return createNode(current.apply(void 0, arg), isTooltip);
        };
      } else {
        if ((0, import_lodash.isArray)(current)) {
          current.forEach(function(item) {
            processConfig(item, isTooltip);
          });
        } else if ((0, import_lodash.isObject)(current)) {
          processConfig(current, isTooltip);
        } else {
          isTooltip = flag;
        }
      }
    });
  };
  (0, import_react.useEffect)(function() {
    if (chart.current && !(0, import_lodash.isEqual)(chartOptions.current, config)) {
      chartOptions.current = (0, import_lodash.cloneDeep)(config);
      processConfig(config);
      chart.current.update(config);
      chart.current.render();
    }
  }, [config]);
  (0, import_react.useEffect)(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = (0, import_lodash.cloneDeep)(config);
    }
    processConfig(config);
    var chartInstance = new ChartClass(container.current, __assign({}, config));
    chartInstance.toDataURL = toDataURL;
    chartInstance.downloadImage = downloadImage;
    chartInstance.render();
    chart.current = chartInstance;
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}

// node_modules/@antv/g2-extension-plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS6 = {
  field: "value",
  size: [1, 1],
  // width, height
  round: false,
  padding: 0,
  // Default desc.
  sort: (a3, b) => b.value - a3.value,
  as: ["x", "y"],
  // Whether to ignore parentValue. When set to true, the weight of the parent node is determined by the child element.
  ignoreParentValue: true
};
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  const { field: field3, fields } = options;
  if (isString(field3)) {
    return field3;
  }
  if (isArray(field3)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field3[0];
  }
  console.warn(`${INVALID_FIELD_ERR_MSG} will try to get fields instead.`);
  if (isString(fields)) {
    return fields;
  }
  if (isArray(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
  const nodes = [];
  if (root && root.each) {
    let parent;
    let index2;
    root.each((node) => {
      var _a, _b;
      if (node.parent !== parent) {
        parent = node.parent;
        index2 = 0;
      } else {
        index2 += 1;
      }
      const ancestors = filter_default((((_a = node.ancestors) === null || _a === void 0 ? void 0 : _a.call(node)) || []).map((d2) => nodes.find((n) => n.name === d2.name) || d2), ({ depth }) => depth > 0 && depth < node.depth);
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index2;
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    root.eachNode((node) => {
      nodes.push(node);
    });
  }
  return nodes;
}
function partition(data, options) {
  options = mix({}, DEFAULT_OPTIONS6, options);
  const as = options.as;
  if (!isArray(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  let field3;
  try {
    field3 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  const partition2 = (data2) => partition_default().size(options.size).round(options.round).padding(options.padding)(
    /**
     * The sum function must be specified in the d3Hierarchy layout to compute node values by calling the specified value function
     * from the current node in post-order traversal order for the current node and for each descendant node and returning the current node.
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}.
     * The computed value obtained by the parent is sum(node(parent)) + sum(node(child1)) + sum(node(child2)).
     * In the sum function, d is the data passed in by the user and children is the reserved field.
     */
    hierarchy(data2).sum((d2) => size(d2.children) ? options.ignoreParentValue ? 0 : d2[field3] - reduce_default(d2.children, (a3, b) => a3 + b[field3], 0) : d2[field3]).sort(options.sort)
  );
  const root = partition2(data);
  const x2 = as[0];
  const y2 = as[1];
  root.each((node) => {
    var _a, _b;
    node[x2] = [node.x0, node.x1, node.x1, node.x0];
    node[y2] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach((prop) => {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}

// node_modules/@antv/g2-extension-plot/esm/mark/sunburst.js
var __rest90 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SUNBURST_TYPE = "sunburst";
var SUNBURST_TYPE_FIELD = "markType";
var SUNBURST_PATH_FIELD = "path";
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
function transformData(options) {
  const { data, encode } = options;
  const { color: color2, value: value2 } = encode;
  const type = "partition";
  const nodes = partition(data, {
    field: value2,
    // @ts-ignore
    type: `hierarchy.${type}`,
    as: ["x", "y"]
  });
  const result = [];
  nodes.forEach((node) => {
    var _a, _b, _c, _d;
    if (node.depth === 0) {
      return null;
    }
    let path2 = node.data.name;
    const pathList = [path2];
    let ancestorNode = Object.assign({}, node);
    while (ancestorNode.depth > 1) {
      path2 = `${(_a = ancestorNode.parent.data) === null || _a === void 0 ? void 0 : _a.name} / ${path2}`;
      pathList.unshift((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name);
      ancestorNode = ancestorNode.parent;
    }
    const nodeInfo = Object.assign(Object.assign(Object.assign({}, pick_default(node.data, [value2])), { [SUNBURST_PATH_FIELD]: path2, [SUNBURST_ANCESTOR_FIELD]: ancestorNode.data.name }), node);
    if (color2 && color2 !== SUNBURST_ANCESTOR_FIELD) {
      nodeInfo[color2] = node.data[color2] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[color2]);
    }
    result.push(nodeInfo);
  });
  return result.map((d2) => {
    const x2 = d2.x.slice(0, 2);
    const y2 = [d2.y[2], d2.y[0]];
    if (x2[0] === x2[1]) {
      y2[0] = y2[1] = (d2.y[2] + d2.y[0]) / 2;
    }
    return Object.assign(Object.assign({}, d2), {
      x: x2,
      y: y2,
      fillOpacity: Math.pow(0.85, d2.depth)
    });
  });
}
var DEFAULT_OPTIONS7 = {
  id: SUNBURST_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: SUNBURST_PATH_FIELD,
    color: SUNBURST_ANCESTOR_FIELD,
    value: "value"
  },
  axis: { x: false, y: false },
  style: {
    [SUNBURST_TYPE_FIELD]: SUNBURST_TYPE,
    stroke: "#fff",
    lineWidth: 0.5,
    fillOpacity: "fillOpacity",
    [CHILD_NODE_COUNT]: CHILD_NODE_COUNT,
    depth: "depth"
  },
  state: {
    active: { zIndex: 2, stroke: "#000" },
    inactive: { zIndex: 1, stroke: "#fff" }
  },
  legend: false,
  interaction: { drillDown: true },
  coordinate: {
    type: "polar",
    innerRadius: 0.2
  }
};
var Sunburst = (options) => {
  const { encode: encodeOption, data = [], legend } = options, resOptions = __rest90(options, ["encode", "data", "legend"]);
  const coordinate = Object.assign(Object.assign({}, resOptions.coordinate), {
    // Reac Bug InnerRadius = 0.
    innerRadius: Math.max(get_default(resOptions, ["coordinate", "innerRadius"], 0.2), 1e-5)
  });
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS7.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData({ encode, data });
  console.log(rectData, "rectData");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS7, Object.assign(Object.assign({ type: "rect", data: rectData, encode, tooltip: {
      title: "path",
      items: [
        (d2) => {
          return {
            name: value2,
            value: d2[value2]
          };
        }
      ]
    } }, resOptions), { coordinate }))
  ];
};
Sunburst.props = {};

// node_modules/@antv/g2-extension-plot/esm/interaction/drillDown.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsSunburst = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => get_default(item, ["style", SUNBURST_TYPE_FIELD]) === SUNBURST_TYPE);
};
function selectPlotArea3(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.85)",
    fontSize: 12,
    y: 1
  },
  active: {
    fill: "rgba(0, 0, 0, 0.5)"
  }
};
function DrillDown(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {}, isFixedColor = false } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB, textConfig);
  return (context) => {
    const { update, setState, container, view, options } = context;
    const document2 = container.ownerDocument;
    const plotArea = selectPlotArea3(container);
    const sunburstMark = options.marks.find(({ id: id2 }) => id2 === SUNBURST_TYPE);
    const { state } = sunburstMark;
    const textGroup = document2.createElement("g");
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter15(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2) {
        const rootText = document2.createElement("text", {
          style: Object.assign({
            x: 0,
            text: breadCrumb.rootText,
            // @ts-ignore
            depth: 0
          }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2 === null || path2 === void 0 ? void 0 : path2.split(" / ");
        let y2 = breadCrumb.style.y;
        let x2 = textGroup.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index2) => {
          const textSeparator = document2.createElement("text", {
            style: Object.assign(Object.assign({ x: x2, text: " / " }, breadCrumb.style), { y: y2 })
          });
          textGroup.appendChild(textSeparator);
          x2 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = document2.createElement("text", {
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x2,
              // @ts-ignore
              depth: index2 + 1
            }, breadCrumb.style), { y: y2 })
          });
          textGroup.appendChild(drillText);
          x2 += drillText.getBBox().width;
          if (x2 > maxWidth) {
            y2 = textGroup.getBBox().height;
            x2 = 0;
            textSeparator.attr({
              x: x2,
              y: y2
            });
            x2 += textSeparator.getBBox().width;
            drillText.attr({
              x: x2,
              y: y2
            });
            x2 += drillText.getBBox().width;
          }
          return drillText;
        });
        [rootText, ...drillTexts].forEach((item, index2) => {
          if (index2 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(item.name, get_default(item, ["style", "depth"]));
          });
        });
      }
      setState("drillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== SUNBURST_TYPE && mark2.type !== "rect")
            return mark2;
          const { data } = mark2;
          const newScale = Object.fromEntries(["color"].map((channel) => [channel, { domain: view.scale[channel].getOptions().domain }]));
          const newData = data.filter((item) => {
            const key = item.path;
            if (!isFixedColor) {
              item[SUNBURST_ANCESTOR_FIELD] = key.split(" / ")[depth];
            }
            if (!path2)
              return true;
            const reg = new RegExp(`^${path2}.+`);
            return reg.test(key);
          });
          return deep_mix_default({}, mark2, isFixedColor ? {
            data: newData,
            scale: newScale
          } : {
            data: newData
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update();
    });
    const createDrillClick = (e) => {
      const item = e.target;
      if (get_default(item, ["style", SUNBURST_TYPE_FIELD]) !== SUNBURST_TYPE || get_default(item, ["markType"]) !== "rect" || !get_default(item, ["style", CHILD_NODE_COUNT]))
        return;
      const path2 = get_default(item, ["__data__", "key"]);
      const depth = get_default(item, ["style", "depth"]);
      item.style.cursor = "pointer";
      drillDownClick(path2, depth);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsSunburst(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2-extension-plot/esm/lib.js
function plotlib2() {
  return {
    "interaction.drillDown": DrillDown,
    "mark.sunburst": Sunburst
  };
}

// node_modules/@ant-design/plots/es/core/base/chart.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var Chart3 = extend4(Runtime, __assign2(__assign2({}, stdlib()), plotlib2()));

// node_modules/@ant-design/plots/es/core/utils/index.js
var import_lodash2 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/core/utils/transform.js
var transformOptions = function(params) {
  var options = filterTransformed(params);
  var _a = options.children, children = _a === void 0 ? [] : _a;
  var rest = (0, import_lodash2.omit)(options, [].concat(VIEW_OPTIONS, CONFIG_SHAPE.map(function(item) {
    return item.key;
  })));
  var getCustomTransform = function(key) {
    var _a2;
    return (_a2 = SPECIAL_OPTIONS.find(function(option) {
      return option.key === key;
    })) === null || _a2 === void 0 ? void 0 : _a2.callback;
  };
  var updateOptions = function(origin, key, value2) {
    var callback = getCustomTransform(key);
    if (callback) {
      callback(origin, key, value2);
    } else {
      origin[key] = mergeWithArrayCoverage({}, origin[key], value2);
    }
  };
  var transformShape = function(config) {
    Object.keys(config).forEach(function(key) {
      if (!config[key])
        return;
      var exist = CONFIG_SHAPE.find(function(item) {
        return item.key === key;
      });
      if (exist) {
        var type = exist.type, extend_keys = exist.extend_keys;
        if (type) {
          children.push(transformConfig(mergeWithArrayCoverage({}, (0, import_lodash2.pick)(config, extend_keys), { type }, config[key])));
        } else {
          if ((0, import_lodash2.isArray)(config[key])) {
            config[key].forEach(function(annotation) {
              children.push(transformConfig(annotation));
            });
          }
        }
      }
    });
  };
  var transformConfig = function(config) {
    transformShape(config);
    Object.keys(TRANSFORM_OPTION_KEY).forEach(function(key) {
      var transformTarget = TRANSFORM_OPTION_KEY[key];
      if (!(0, import_lodash2.isUndefined)(config[key])) {
        if ((0, import_lodash2.isObject)(transformTarget)) {
          var value2 = transformTarget.value, target = transformTarget.target;
          var transformValue = value2(config[key]);
          updateOptions(config, target, transformValue);
        } else {
          (0, import_lodash2.set)(config, transformTarget, config[key]);
        }
      }
    });
    return config;
  };
  children.forEach(function(child) {
    var config = mergeWithArrayCoverage({}, rest, child);
    transformConfig(mergeWithArrayCoverage(child, config));
  });
  transformShape(options);
  deleteExcessKeys(options);
  return params;
};

// node_modules/@ant-design/plots/es/core/utils/delete-excess-keys.js
var __spreadArray5 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var deleteExcessKeys = function(options) {
  var _a = options.children, children = _a === void 0 ? [] : _a;
  var deleteKeys = Object.keys(TRANSFORM_OPTION_KEY).concat(CONFIG_SHAPE.map(function(item) {
    return item.key;
  }));
  deleteKeys.forEach(function(key) {
    delete options[key];
  });
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (deleteKeys.includes(key)) {
        delete child[key];
      }
    });
  });
  Object.keys(options).forEach(function(key) {
    if (!__spreadArray5(__spreadArray5([], VIEW_OPTIONS, true), ANNOTATION_LIST.map(function(item) {
      return item.key;
    }), true).includes(key)) {
      delete options[key];
    }
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/filter-transformed.js
var filterTransformed = function(params) {
  var options = params.options;
  var _a = options.children, children = _a === void 0 ? [] : _a;
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if ((0, import_lodash2.isArray)(child[key]) && key !== "data") {
        child[key] = child[key].filter(function(item) {
          return !item[TRANSFORM_SIGN];
        });
      }
    });
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/merge-with-array-coverage.js
var __spreadArray6 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var arrayCoverage = function(objValue, srcValue) {
  if ((0, import_lodash2.isArray)(srcValue)) {
    return srcValue;
  }
};
var mergeWithArrayCoverage = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return import_lodash2.mergeWith.apply(void 0, __spreadArray6(__spreadArray6([], args, false), [arrayCoverage], false));
};

// node_modules/@ant-design/plots/es/core/utils/field-adapter.js
function fieldAdapter(field3) {
  switch (typeof field3) {
    case "function":
      return field3;
    case "string":
      return function(d2) {
        return (0, import_lodash2.get)(d2, [field3]);
      };
    default:
      return function() {
        return field3;
      };
  }
}

// node_modules/@ant-design/plots/es/core/constants/index.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest91 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var CHART_OPTIONS = ["renderer"];
var VIEW_OPTIONS = [
  "width",
  "height",
  "autoFit",
  "theme",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "depth",
  "title",
  "clip",
  "children",
  "type",
  "data",
  "direction"
];
var TRANSFORM_SIGN = "__transform__";
var SKIP_DEL_CUSTOM_SIGN = "__skipDelCustomKeys__";
var commonCallback = function(type, value2) {
  if ((0, import_lodash2.isBoolean)(value2)) {
    return {
      type,
      available: value2
    };
  }
  return __assign3({ type }, value2);
};
var TRANSFORM_OPTION_KEY = {
  /** encode */
  xField: "encode.x",
  yField: "encode.y",
  colorField: "encode.color",
  angleField: "encode.y",
  keyField: "encode.key",
  sizeField: "encode.size",
  shapeField: "encode.shape",
  seriesField: "encode.series",
  positionField: "encode.position",
  textField: "encode.text",
  valueField: "encode.value",
  binField: "encode.x",
  srcField: "encode.src",
  linkColorField: "encode.linkColor",
  fontSizeField: "encode.fontSize",
  radius: "coordinate.outerRadius",
  innerRadius: "coordinate.innerRadius",
  startAngle: "coordinate.startAngle",
  endAngle: "coordinate.endAngle",
  focusX: "coordinate.focusX",
  focusY: "coordinate.focusY",
  distortionX: "coordinate.distortionX",
  distortionY: "coordinate.distortionY",
  visual: "coordinate.visual",
  /**
   * @title 
   * @example
   *  1. stack: true -> transform: [{type: 'stackY'}]
   */
  stack: {
    target: "transform",
    value: function(value2) {
      return commonCallback("stackY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. normalize: true -> transform: [{type: 'normalizeY'}]
   */
  normalize: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @description  normalize
   * @example
   *  1. percent: true -> transform: [{type: 'normalizeY'}]
   */
  percent: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. group: true -> transform: [{type: 'dodgeX'}]
   */
  group: {
    target: "transform",
    value: function(value2) {
      return commonCallback("dodgeX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. sort: true -> transform: [{type: 'sortX'}]
   */
  sort: {
    target: "transform",
    value: function(value2) {
      return commonCallback("sortX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. symmetry: true -> transform: [{type: 'symmetryY'}]
   */
  symmetry: {
    target: "transform",
    value: function(value2) {
      return commonCallback("symmetryY", value2);
    }
  },
  /**
   * @title  y  y1 
   * @example
   *  1. diff: true -> transform: [{type: 'diffY'}]
   */
  diff: {
    target: "transform",
    value: function(value2) {
      return commonCallback("diffY", value2);
    }
  },
  meta: {
    target: "scale",
    value: function(value2) {
      return value2;
    }
  },
  label: {
    target: "labels",
    value: function(value2) {
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. shape: 'smooth' -> style: {shape: 'smooth'}
   */
  shape: "style.shape",
  /**
   * @title 
   * @description  boolean  
   */
  connectNulls: {
    target: "style",
    value: function(value2) {
      if ((0, import_lodash2.isBoolean)(value2)) {
        return {
          connect: value2
        };
      }
      return value2;
    }
  }
};
var EXTEND_KEYS = [
  "xField",
  "yField",
  "seriesField",
  "colorField",
  "keyField",
  "positionField",
  "meta",
  "tooltip",
  "animate",
  "stack",
  "normalize",
  "percent",
  "group",
  "sort",
  "symmetry",
  "diff"
];
var CONFIG_SHAPE = [
  {
    key: "annotations",
    extend_keys: []
  },
  {
    key: "line",
    type: "line",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "point",
    type: "point",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "area",
    type: "area",
    extend_keys: EXTEND_KEYS
  }
];
var SPECIAL_OPTIONS = [
  {
    key: "transform",
    callback: function(origin, key, value2) {
      var _a;
      origin[key] = origin[key] || [];
      var _b = value2.available, available = _b === void 0 ? true : _b, rest = __rest91(value2, ["available"]);
      if (available) {
        origin[key].push(__assign3((_a = {}, _a[TRANSFORM_SIGN] = true, _a), rest));
      } else {
        var index2 = origin[key].indexOf(function(item) {
          return item.type === value2.type;
        });
        if (index2 !== -1) {
          origin[key].splice(index2, 1);
        }
      }
    }
  },
  {
    key: "labels",
    callback: function(origin, key, value2) {
      var _a;
      if (!value2 || (0, import_lodash2.isArray)(value2)) {
        origin[key] = value2 ? value2 : [];
        return;
      }
      if (!value2.text) {
        value2["text"] = origin["yField"];
      }
      origin[key] = origin[key] || [];
      origin[key].push(__assign3((_a = {}, _a[TRANSFORM_SIGN] = true, _a), value2));
    }
  }
];
var ANNOTATION_LIST = [
  {
    key: "conversionTag",
    shape: "ConversionTag"
  },
  {
    key: "axisText",
    shape: "BidirectionalBarAxisText"
  }
];

// node_modules/@ant-design/plots/es/core/annotation/shapes/Text.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var __rest92 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Text4 = (
  /** @class */
  function(_super) {
    __extends(Text5, _super);
    function Text5(_a) {
      if (_a === void 0) {
        _a = {};
      }
      var style = _a.style, restOptions = __rest92(_a, ["style"]);
      return _super.call(this, __assign4({ style: __assign4({ text: "", fontSize: 12, textBaseline: "middle", textAlign: "center", fill: "#000", fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1 }, style) }, restOptions)) || this;
    }
    return Text5;
  }(Text)
);

// node_modules/@ant-design/plots/es/core/annotation/shapes/Polygon.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __rest93 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Polygon4 = (
  /** @class */
  function(_super) {
    __extends2(Polygon5, _super);
    function Polygon5(_a) {
      if (_a === void 0) {
        _a = {};
      }
      var style = _a.style, restOptions = __rest93(_a, ["style"]);
      return _super.call(this, __assign5({ style: __assign5({ fill: "#eee" }, style) }, restOptions)) || this;
    }
    return Polygon5;
  }(Polygon)
);

// node_modules/@ant-design/plots/es/core/annotation/core.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Annotaion = (
  /** @class */
  function(_super) {
    __extends3(Annotaion3, _super);
    function Annotaion3(chart, config, defaultOptions) {
      var _this = _super.call(this, { style: mergeWithArrayCoverage(defaultOptions, config) }) || this;
      _this.chart = chart;
      return _this;
    }
    Annotaion3.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
    };
    Annotaion3.prototype.disconnectedCallback = function() {
    };
    Annotaion3.prototype.attributeChangedCallback = function(name2) {
    };
    Annotaion3.prototype.update = function(attr, animate) {
      var _a;
      this.attr(mergeWithArrayCoverage({}, this.attributes, attr || {}));
      return (_a = this.render) === null || _a === void 0 ? void 0 : _a.call(this, this.attributes, this, animate);
    };
    Annotaion3.prototype.clear = function() {
      this.removeChildren();
    };
    Annotaion3.prototype.getElementsLayout = function() {
      var canvas = this.chart.getContext().canvas;
      var elements = canvas.document.getElementsByClassName("element");
      var elementsLayout = [];
      elements.forEach(function(element) {
        var bbox = element.getBBox();
        var x2 = bbox.x, y2 = bbox.y, width = bbox.width, height = bbox.height;
        var data = element["__data__"];
        elementsLayout.push({
          bbox,
          x: x2,
          y: y2,
          width,
          height,
          key: data.key,
          data
        });
      });
      return elementsLayout;
    };
    Annotaion3.prototype.bindEvents = function(attributes, container) {
    };
    return Annotaion3;
  }(CustomElement)
);

// node_modules/@ant-design/plots/es/core/annotation/conversion-tag.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var ConversionTag = (
  /** @class */
  function(_super) {
    __extends4(ConversionTag2, _super);
    function ConversionTag2(chart, options) {
      return _super.call(this, chart, options, { type: ConversionTag2.tag }) || this;
    }
    ConversionTag2.prototype.getConversionTagLayout = function() {
      var isVertical2 = this.direction === "vertical";
      var elementsLayout = this.getElementsLayout();
      var _a = elementsLayout[0], firstX = _a.x, firstY = _a.y, firstHeigt = _a.height, firstWidth = _a.width, firstData = _a.data;
      var valuePath = ["items", 0, "value"];
      var preValue = (0, import_lodash2.get)(firstData, valuePath);
      var elementDistance = isVertical2 ? elementsLayout[1].y - firstY - firstHeigt : elementsLayout[1].x - firstX - firstWidth;
      var tagLayout = [];
      var _b = this.attributes, _c = _b.size, size3 = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
      elementsLayout.forEach(function(element, index2) {
        if (index2 > 0) {
          var x2 = element.x, y2 = element.y, height = element.height, width = element.width, data = element.data, key = element.key;
          var currentValue = (0, import_lodash2.get)(data, valuePath);
          var halfSize = size3 / 2;
          if (isVertical2) {
            var arrowVertexX = x2 + width / 2;
            var arrowVertexY = y2;
            tagLayout.push({
              points: [
                [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX, arrowVertexY - spacing],
                [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing]
              ],
              center: [arrowVertexX, arrowVertexY - elementDistance / 2 - spacing],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          } else {
            var arrowVertexX = x2;
            var arrowVertexY = y2 + height / 2;
            tagLayout.push({
              points: [
                [x2 - elementDistance + spacing, arrowVertexY - halfSize],
                [x2 - arrowSize - spacing, arrowVertexY - halfSize],
                [arrowVertexX - spacing, arrowVertexY],
                [x2 - arrowSize - spacing, arrowVertexY + halfSize],
                [x2 - elementDistance + spacing, arrowVertexY + halfSize]
              ],
              center: [arrowVertexX - elementDistance / 2 - spacing, arrowVertexY],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          }
          preValue = currentValue;
        }
      });
      return tagLayout;
    };
    ConversionTag2.prototype.render = function() {
      this.setDirection();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.setDirection = function() {
      var coordinate = this.chart.getCoordinate();
      var transformations = (0, import_lodash2.get)(coordinate, "options.transformations");
      var direction = "horizontal";
      transformations.forEach(function(transformation) {
        if (transformation.includes("transpose")) {
          direction = "vertical";
        }
      });
      this.direction = direction;
    };
    ConversionTag2.prototype.drawConversionTag = function() {
      var _this = this;
      var conversionLayout = this.getConversionTagLayout();
      var _a = this.attributes, style = _a.style, _b = _a.text, textStyle = _b.style, formatter = _b.formatter;
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, value2 = layout.value, key = layout.key;
        var prev = value2[0], next = value2[1];
        var x2 = center2[0], y2 = center2[1];
        var polygon = new Polygon4({
          style: __assign6({ points, fill: "#eee" }, style),
          id: "polygon-".concat(key)
        });
        var text = new Text4({
          style: __assign6({ x: x2, y: y2, text: (0, import_lodash2.isFunction)(formatter) ? formatter(prev, next) : (next / prev * 100).toFixed(2) + "%" }, textStyle),
          id: "text-".concat(key)
        });
        _this.appendChild(polygon);
        _this.appendChild(text);
      });
    };
    ConversionTag2.prototype.update = function() {
      var _this = this;
      var conversionLayout = this.getConversionTagLayout();
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, key = layout.key;
        var x2 = center2[0], y2 = center2[1];
        var polygon = _this.getElementById("polygon-".concat(key));
        var text = _this.getElementById("text-".concat(key));
        polygon.setAttribute("points", points);
        text.setAttribute("x", x2);
        text.setAttribute("y", y2);
      });
    };
    ConversionTag2.tag = "ConversionTag";
    return ConversionTag2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/constants.js
var VERTICAL_MARGIN = 32;
var HORIZONTAL_MARGIN = 16;
var AXIS_LABEL_PADDING = 48;

// node_modules/@ant-design/plots/es/core/annotation/bidirectional-bar-axis-text.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest94 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var BidirectionalBarAxisText = (
  /** @class */
  function(_super) {
    __extends5(BidirectionalBarAxisText2, _super);
    function BidirectionalBarAxisText2(chart, options) {
      return _super.call(this, chart, options, { type: BidirectionalBarAxisText2.tag }) || this;
    }
    BidirectionalBarAxisText2.prototype.render = function() {
      this.drawText();
    };
    BidirectionalBarAxisText2.prototype.getBidirectionalBarAxisTextLayout = function() {
      var layout = this.attributes.layout;
      var isVertical2 = layout === "vertical";
      var allElementsLayout = this.getElementsLayout();
      var elementsLayout = isVertical2 ? (0, import_lodash2.uniqBy)(allElementsLayout, "x") : (0, import_lodash2.uniqBy)(allElementsLayout, "y");
      var textPath = ["title"];
      var textLayout = [];
      var views = this.chart.getContext().views;
      var _a = (0, import_lodash2.get)(views, [0, "layout"]), viewWidth = _a.width, viewHeight = _a.height;
      elementsLayout.forEach(function(element) {
        var x2 = element.x, y2 = element.y, height = element.height, width = element.width, data = element.data, key = element.key;
        var text = (0, import_lodash2.get)(data, textPath);
        if (isVertical2) {
          textLayout.push({
            x: x2 + width / 2,
            y: viewHeight,
            text,
            key
          });
        } else {
          textLayout.push({
            x: viewWidth,
            y: y2 + height / 2,
            text,
            key
          });
        }
      });
      if ((0, import_lodash2.uniqBy)(textLayout, "text").length !== textLayout.length) {
        textLayout = Object.values((0, import_lodash2.groupBy)(textLayout, "text")).map(function(items) {
          var _a2;
          var sum4 = items.reduce(function(pre, cur) {
            return pre + (isVertical2 ? cur.x : cur.y);
          }, 0);
          return __assign7(__assign7({}, items[0]), (_a2 = {}, _a2[isVertical2 ? "x" : "y"] = sum4 / items.length, _a2));
        });
      }
      return textLayout;
    };
    BidirectionalBarAxisText2.prototype.transformLabelStyle = function(style) {
      var removeLabel = {};
      var reg = /^label[A-Z]/;
      Object.keys(style).forEach(function(key) {
        if (reg.test(key)) {
          removeLabel[key.replace("label", "").replace(/^[A-Z]/, function(match) {
            return match.toLowerCase();
          })] = style[key];
        }
      });
      return removeLabel;
    };
    BidirectionalBarAxisText2.prototype.drawText = function() {
      var _this = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      var _a = this.attributes, viewLayout = _a.layout, labelFormatter = _a.labelFormatter, textStyle = __rest94(_a, ["layout", "labelFormatter"]);
      axisLayout.forEach(function(layout) {
        var x2 = layout.x, y2 = layout.y, text = layout.text, key = layout.key;
        var textNode = new Text4({
          style: __assign7({ x: x2, y: y2, text: (0, import_lodash2.isFunction)(labelFormatter) ? labelFormatter(text) : text, wordWrap: true, wordWrapWidth: viewLayout === "horizontal" ? VERTICAL_MARGIN * 2 : 120, maxLines: 2, textOverflow: "ellipsis" }, _this.transformLabelStyle(textStyle)),
          id: "text-".concat(key)
        });
        _this.appendChild(textNode);
      });
    };
    BidirectionalBarAxisText2.prototype.destroy = function() {
      this.clear();
    };
    BidirectionalBarAxisText2.prototype.update = function() {
      this.destroy();
      this.drawText();
    };
    BidirectionalBarAxisText2.tag = "BidirectionalBarAxisText";
    return BidirectionalBarAxisText2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/annotation/index.js
var Annotaion2 = { ConversionTag, BidirectionalBarAxisText };
var Controller = (
  /** @class */
  function() {
    function Controller2(chart, config) {
      this.container = /* @__PURE__ */ new Map();
      this.chart = chart;
      this.config = config;
      this.init();
    }
    Controller2.prototype.init = function() {
      var _this = this;
      ANNOTATION_LIST.forEach(function(annotation) {
        var _a;
        var key = annotation.key, shape23 = annotation.shape;
        var annotationOptions = _this.config[key];
        if (annotationOptions) {
          var annotationInstance = new Annotaion2[shape23](_this.chart, annotationOptions);
          var canvas = _this.chart.getContext().canvas;
          canvas.appendChild(annotationInstance);
          _this.container.set(key, annotationInstance);
        } else {
          (_a = _this.container.get(key)) === null || _a === void 0 ? void 0 : _a.clear();
        }
      });
    };
    Controller2.prototype.update = function() {
      var _this = this;
      if (!this.container.size)
        return;
      ANNOTATION_LIST.forEach(function(annotation) {
        var key = annotation.key;
        var annotationInstance = _this.container.get(key);
        annotationInstance === null || annotationInstance === void 0 ? void 0 : annotationInstance.update();
      });
    };
    return Controller2;
  }()
);

// node_modules/@ant-design/plots/es/core/base/index.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var Plot = (
  /** @class */
  function(_super) {
    __extends6(Plot2, _super);
    function Plot2(container, options) {
      var _this = _super.call(this) || this;
      _this.container = typeof container === "string" ? document.getElementById(container) : container;
      _this.options = _this.mergeOption(options);
      _this.createG2();
      _this.bindEvents();
      return _this;
    }
    Plot2.prototype.getChartOptions = function() {
      return __assign8(__assign8({}, (0, import_lodash2.pick)(this.options, CHART_OPTIONS)), { container: this.container });
    };
    Plot2.prototype.getSpecOptions = function() {
      if (this.type === "base" || this[SKIP_DEL_CUSTOM_SIGN]) {
        return __assign8(__assign8({}, this.options), this.getChartOptions());
      }
      return this.options;
    };
    Plot2.prototype.createG2 = function() {
      if (!this.container) {
        throw Error("The container is not initialized!");
      }
      this.chart = new Chart3(this.getChartOptions());
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "Ant Design Charts");
    };
    Plot2.prototype.bindEvents = function() {
      var _this = this;
      if (this.chart) {
        this.chart.on("*", function(e) {
          if (e === null || e === void 0 ? void 0 : e.type) {
            _this.emit(e.type, e);
          }
        });
      }
    };
    Plot2.prototype.getBaseOptions = function() {
      return { type: "view", autoFit: true };
    };
    Plot2.prototype.getDefaultOptions = function() {
    };
    Plot2.prototype.render = function() {
      var _this = this;
      if (this.type !== "base") {
        this.execAdaptor();
      }
      this.chart.options(this.getSpecOptions());
      this.chart.render().then(function() {
        _this.annotation = new Controller(_this.chart, _this.options);
      });
      this.bindSizeSensor();
    };
    Plot2.prototype.update = function(options) {
      this.options = this.mergeOption(options);
    };
    Plot2.prototype.mergeOption = function(options) {
      return mergeWithArrayCoverage({}, this.getBaseOptions(), this.getDefaultOptions(), options);
    };
    Plot2.prototype.changeData = function(data) {
      this.chart.changeData(data);
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.destroy = function() {
      this.chart.destroy();
      this.off();
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor33 = this.getSchemaAdaptor();
      adaptor33({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this = this;
      var _a = this.options.autoFit, autoFit = _a === void 0 ? true : _a;
      if (autoFit) {
        this.chart.on(ChartEvent.AFTER_CHANGE_SIZE, function() {
          _this.annotation.update();
        });
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@ant-design/plots/es/core/plots/base/index.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Base = (
  /** @class */
  function(_super) {
    __extends7(Base2, _super);
    function Base2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "base";
      return _this;
    }
    Base2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line" }]
      };
    };
    Base2.prototype.getDefaultOptions = function() {
      return Base2.getDefaultOptions();
    };
    Base2.prototype.getSchemaAdaptor = function() {
      return function(params) {
        return params;
      };
    };
    return Base2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/adaptor/shape-stack.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
function shapeStack(params) {
  var options = params.options;
  var stack = options.stack, tooltip2 = options.tooltip, xField = options.xField;
  if (!stack)
    return params;
  var shapes = CONFIG_SHAPE.map(function(item) {
    return item.type;
  }).filter(function(item) {
    return !!item;
  });
  var hasStack = false;
  shapes.forEach(function(shape23) {
    if (options[shape23]) {
      hasStack = true;
      (0, import_lodash2.set)(options, [shape23, "stack"], __assign9({ y1: "y" }, typeof stack === "object" ? stack : {}));
    }
  });
  if (hasStack && !(0, import_lodash2.isBoolean)(tooltip2) && !tooltip2) {
    (0, import_lodash2.set)(options, "tooltip", {
      title: xField,
      items: [
        {
          channel: "y"
        }
      ]
    });
  }
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/mark.js
function mark(params) {
  return (0, import_lodash2.flow)(shapeStack)(params);
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate-layout.js
function coordinateLayout(params) {
  var _a = params.options.layout, layout = _a === void 0 ? "horizontal" : _a;
  params.options.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
  return params;
}
function allCoordinateLayout(params) {
  coordinateLayout(params);
  var _a = params.options.layout, layout = _a === void 0 ? "horizontal" : _a;
  params.options.children.forEach(function(item) {
    var _a2;
    if ((_a2 = item === null || item === void 0 ? void 0 : item.coordinate) === null || _a2 === void 0 ? void 0 : _a2.transform) {
      item.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
    }
  });
  return params;
}

// node_modules/@ant-design/plots/es/core/plots/area/adaptor.js
function adaptor2(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/area/index.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area3 = (
  /** @class */
  function(_super) {
    __extends8(Area4, _super);
    function Area4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "area";
      return _this;
    }
    Area4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "area" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        }
      };
    };
    Area4.prototype.getDefaultOptions = function() {
      return Area4.getDefaultOptions();
    };
    Area4.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bar/adaptor.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
function adaptor3(params) {
  var background = function(params2) {
    var options = params2.options;
    if ((0, import_lodash2.get)(options, "children.length") > 1) {
      (0, import_lodash2.set)(options, "children", [{ type: "interval" }]);
    }
    var scale3 = options.scale, markBackground = options.markBackground, data = options.data, children = options.children, yField = options.yField;
    var domain = (0, import_lodash2.get)(scale3, "y.domain", []);
    if (markBackground && domain.length && (0, import_lodash2.isArray)(data)) {
      var domainMax_1 = "domainMax";
      var backgroundData = data.map(function(item) {
        var _a;
        return __assign10(__assign10({ originData: __assign10({}, item) }, (0, import_lodash2.omit)(item, yField)), (_a = {}, _a[domainMax_1] = domain[domain.length - 1], _a));
      });
      children.unshift(__assign10({ type: "interval", data: backgroundData, yField: domainMax_1, tooltip: false, style: {
        fill: "#eee"
      }, label: false }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash2.flow)(background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bar/shape.js
var reisterShape = function() {
  var draw25DBar = function(style, context) {
    return function(points) {
      var _a = style.fill, fill = _a === void 0 ? "#2888FF" : _a, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var p1 = points[0], p2 = points[1], p3 = points[2], p4 = points[3];
      var height = (p2[1] - p1[1]) / 2;
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var top = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], [p3[0] - pitch, p1[1] + height], p4],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var bottom = document2.createElement("polygon", {
        style: {
          points: [[p1[0] - pitch, p1[1] + height], p2, p3, [p3[0] - pitch, p1[1] + height]],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], p2, [p1[0] + pitch, p1[1] + height]],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(top);
      g.appendChild(bottom);
      g.appendChild(right2);
      return g;
    };
  };
  register("shape.interval.bar25D", draw25DBar);
};

// node_modules/@ant-design/plots/es/core/plots/bar/index.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape();
var Bar = (
  /** @class */
  function(_super) {
    __extends9(Bar2, _super);
    function Bar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Bar";
      return _this;
    }
    Bar2.getDefaultOptions = function() {
      return {
        type: "view",
        coordinate: { transform: [{ type: "transpose" }] },
        children: [{ type: "interval" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        }
      };
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/column/shape.js
var reisterShape2 = function() {
  var draw25DColumn = function(style, context) {
    return function(points) {
      var _a = style.fill, fill = _a === void 0 ? "#2888FF" : _a, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var x3 = points[1][0] - points[0][0];
      var x4 = x3 / 2 + points[0][0];
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var left2 = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] + pitch],
            [x4, points[3][1] + pitch],
            [points[3][0], points[3][1]]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [
            [x4, points[1][1] + pitch],
            [points[1][0], points[1][1]],
            [points[2][0], points[2][1]],
            [x4, points[2][1] + pitch]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var top = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] - pitch],
            [points[1][0], points[1][1]],
            [x4, points[1][1] + pitch]
          ],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(right2);
      g.appendChild(left2);
      g.appendChild(top);
      return g;
    };
  };
  register("shape.interval.column25D", draw25DColumn);
};

// node_modules/@ant-design/plots/es/core/plots/column/index.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape2();
var Column2 = (
  /** @class */
  function(_super) {
    __extends10(Column3, _super);
    function Column3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Column3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Column3.prototype.getDefaultOptions = function() {
      return Column3.getDefaultOptions();
    };
    Column3.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/dual-axes/adaptor.js
function adaptor4(params) {
  var colorField = function(params2) {
    var options = params2.options;
    var _a = options.children, children = _a === void 0 ? [] : _a, legend = options.legend;
    if (!legend)
      return params2;
    children.forEach(function(option) {
      if (!(0, import_lodash2.get)(option, "colorField")) {
        var yField_1 = (0, import_lodash2.get)(option, "yField");
        (0, import_lodash2.set)(option, "colorField", function() {
          return yField_1;
        });
      }
    });
    return params2;
  };
  var annotations = function(params2) {
    var options = params2.options;
    var _a = options.annotations, annotations2 = _a === void 0 ? [] : _a, _b = options.children, children = _b === void 0 ? [] : _b, scale3 = options.scale;
    var sharedScale = false;
    if ((0, import_lodash2.get)(scale3, "y.key")) {
      return params2;
    }
    children.forEach(function(child, index2) {
      if (!(0, import_lodash2.get)(child, "scale.y.key")) {
        var scaleKey_1 = "child".concat(index2, "Scale");
        (0, import_lodash2.set)(child, "scale.y.key", scaleKey_1);
        var _a2 = child.annotations, childAnnotations = _a2 === void 0 ? [] : _a2;
        if (childAnnotations.length > 0) {
          (0, import_lodash2.set)(child, "scale.y.independent", false);
          childAnnotations.forEach(function(annotation) {
            (0, import_lodash2.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
        if (!sharedScale && annotations2.length > 0 && (0, import_lodash2.get)(child, "scale.y.independent") === void 0) {
          sharedScale = true;
          (0, import_lodash2.set)(child, "scale.y.independent", false);
          annotations2.forEach(function(annotation) {
            (0, import_lodash2.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
      }
    });
    return params2;
  };
  return (0, import_lodash2.flow)(colorField, annotations, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/dual-axes/index.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DualAxes = (
  /** @class */
  function(_super) {
    __extends11(DualAxes2, _super);
    function DualAxes2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "DualAxes";
      return _this;
    }
    DualAxes2.getDefaultOptions = function() {
      return {
        type: "view",
        axis: {
          y: { title: false, tick: false },
          x: { title: false }
        },
        scale: {
          y: {
            independent: true,
            nice: true
          }
        }
      };
    };
    DualAxes2.prototype.getDefaultOptions = function() {
      return DualAxes2.getDefaultOptions();
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/funnel/adaptor.js
function adaptor5(params) {
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, colorField = options.colorField;
    if (!colorField) {
      (0, import_lodash2.set)(options, "colorField", xField);
    }
    return params2;
  };
  var transform = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, transform2 = options.transform, _a = options.isTransposed, isTransposed = _a === void 0 ? true : _a, coordinate = options.coordinate;
    if (!transform2) {
      if (compareField) {
        (0, import_lodash2.set)(options, "transform", []);
      } else {
        (0, import_lodash2.set)(options, "transform", [{ type: "symmetryY" }]);
      }
    }
    if (!coordinate && isTransposed) {
      (0, import_lodash2.set)(options, "coordinate", { transform: [{ type: "transpose" }] });
    }
    return params2;
  };
  var compare = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, seriesField = options.seriesField, data = options.data, children = options.children, yField = options.yField, _a = options.isTransposed, isTransposed = _a === void 0 ? true : _a;
    if (compareField || seriesField) {
      var groupedData = Object.values((0, import_lodash2.groupBy)(data, function(item) {
        return item[compareField || seriesField];
      }));
      children[0].data = groupedData[0];
      children.push({
        type: "interval",
        data: groupedData[1],
        // @ts-ignore
        yField: function(item) {
          return -item[yField];
        }
      });
      delete options["compareField"];
      delete options.data;
    }
    if (seriesField) {
      (0, import_lodash2.set)(options, "type", "spaceFlex");
      (0, import_lodash2.set)(options, "ratio", [1, 1]);
      (0, import_lodash2.set)(options, "direction", isTransposed ? "row" : "col");
      delete options["seriesField"];
    }
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      (0, import_lodash2.set)(options, "tooltip", {
        title: false,
        items: [
          function(d2) {
            return { name: d2[xField], value: d2[yField] };
          }
        ]
      });
    }
    return params2;
  };
  return (0, import_lodash2.flow)(init, transform, compare, tooltip2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/funnel/index.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Funnel2 = (
  /** @class */
  function(_super) {
    __extends12(Funnel3, _super);
    function Funnel3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Funnel3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: { x: { padding: 0 } },
        animate: { enter: { type: "fadeIn" } },
        axis: false,
        shapeField: "funnel",
        label: {
          position: "inside",
          transform: [{ type: "contrastReverse" }]
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Funnel3.prototype.getDefaultOptions = function() {
      return Funnel3.getDefaultOptions();
    };
    Funnel3.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    return Funnel3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/line/adaptor.js
function adaptor6(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/line/index.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line6 = (
  /** @class */
  function(_super) {
    __extends13(Line7, _super);
    function Line7() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      return _this;
    }
    Line7.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // - 
        // animate: {
        //   enter: { type: 'growInX' },
        // },
        children: [{ type: "line" }]
      };
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Line7;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/pie/adaptor.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
function adaptor7(params) {
  var emptyData = function(params2) {
    var options = params2.options;
    var angleField = options.angleField, data = options.data, label = options.label, tooltip2 = options.tooltip, colorField = options.colorField;
    var getColorValue = fieldAdapter(colorField);
    if ((0, import_lodash2.isArray)(data) && data.length > 0) {
      var sum4 = data.reduce(function(a3, b) {
        return a3 + b[angleField];
      }, 0);
      if (sum4 === 0) {
        var normalization = data.map(function(item) {
          var _a;
          return __assign11(__assign11({}, item), (_a = {}, _a[angleField] = 1, _a));
        });
        (0, import_lodash2.set)(options, "data", normalization);
        if (label) {
          (0, import_lodash2.set)(options, "label", __assign11(__assign11({}, label), { formatter: function() {
            return 0;
          } }));
        }
        if (tooltip2 !== false) {
          if ((0, import_lodash2.isFunction)(tooltip2)) {
            (0, import_lodash2.set)(options, "tooltip", function(arg, index2, items) {
              var _a;
              return tooltip2(__assign11(__assign11({}, arg), (_a = {}, _a[angleField] = 0, _a)), index2, items.map(function(item) {
                var _a2;
                return __assign11(__assign11({}, item), (_a2 = {}, _a2[angleField] = 0, _a2));
              }));
            });
          } else {
            (0, import_lodash2.set)(options, "tooltip", __assign11(__assign11({}, tooltip2), { items: [
              function(arg, i, d2) {
                return {
                  name: getColorValue(arg, i, d2),
                  value: 0
                };
              }
            ] }));
          }
        }
      }
    }
    return params2;
  };
  return (0, import_lodash2.flow)(emptyData, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/pie/index.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pie = (
  /** @class */
  function(_super) {
    __extends14(Pie2, _super);
    function Pie2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pie";
      return _this;
    }
    Pie2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "theta" },
        transform: [{ type: "stackY", reverse: true }],
        animate: { enter: { type: "waveIn" } }
      };
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/scatter/adaptor.js
function adaptor8(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/scatter/index.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = (
  /** @class */
  function(_super) {
    __extends15(Scatter2, _super);
    function Scatter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "scatter";
      return _this;
    }
    Scatter2.getDefaultOptions = function() {
      return {
        axis: {
          y: { title: false },
          x: { title: false }
        },
        legend: {
          size: false
        },
        children: [{ type: "point" }]
      };
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radar/adaptor.js
function adaptor9(params) {
  var init = function(params2) {
    (0, import_lodash2.set)(params2, "options.coordinate", { type: (0, import_lodash2.get)(params2, "options.coordinateType", "polar") });
    return params2;
  };
  return (0, import_lodash2.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radar/index.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar2 = (
  /** @class */
  function(_super) {
    __extends16(Radar3, _super);
    function Radar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radar";
      return _this;
    }
    Radar3.getDefaultOptions = function() {
      return {
        axis: {
          x: { grid: true, line: true },
          y: { zIndex: 1, title: false, line: true, nice: true }
        },
        meta: { x: { padding: 0.5, align: 0 } },
        interaction: { tooltip: { style: { crosshairsLineDash: [4, 4] } } },
        children: [{ type: "line" }],
        //   polar  radar 
        coordinateType: "polar"
      };
    };
    Radar3.prototype.getDefaultOptions = function() {
      return Radar3.getDefaultOptions();
    };
    Radar3.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Radar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/stock/adaptor.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
var Y_FIELD_KEY = "__stock-range__";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
function adaptor10(params) {
  var transformData2 = function(params2) {
    var _a = params2.options, data = _a.data, yField = _a.yField;
    params2.options.data = (0, import_lodash2.map)(data, function(item) {
      var obj = item && __assign12({}, item);
      if (Array.isArray(yField) && obj) {
        var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
        obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
        obj[Y_FIELD_KEY] = [obj[open_1], obj[close_1], obj[high], obj[low]];
      }
      return obj;
    });
    return params2;
  };
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, fallingFill = options.fallingFill, risingFill = options.risingFill;
    var open = yField[0], close = yField[1], high = yField[2], low = yField[3];
    var getFieldData = fieldAdapter(xField);
    params2.options.children = (0, import_lodash2.map)(params2.options.children, function(child, index2) {
      var isShadow = index2 === 0;
      return __assign12(__assign12({}, child), { tooltip: {
        title: function(d2, i, data) {
          var v = getFieldData(d2, i, data);
          return v instanceof Date ? v.toLocaleString() : v;
        },
        items: [{ field: high }, { field: low }, { field: open }, { field: close }]
      }, encode: __assign12(__assign12({}, child.encode || {}), { y: isShadow ? [high, low] : [open, close], color: function(d2) {
        return Math.sign(d2[close] - d2[open]);
      } }), style: __assign12(__assign12({}, child.style || {}), { lineWidth: isShadow ? 1 : 10 }) });
    });
    delete options["yField"];
    params2.options.legend = {
      color: false
    };
    if (fallingFill) {
      (0, import_lodash2.set)(params2, "options.scale.color.range[0]", fallingFill);
    }
    if (risingFill) {
      (0, import_lodash2.set)(params2, "options.scale.color.range[2]", risingFill);
    }
    return params2;
  };
  return (0, import_lodash2.flow)(transformData2, init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/stock/index.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_COLORS = ["#26a69a", "#999999", "#ef5350"];
var Stock = (
  /** @class */
  function(_super) {
    __extends17(Stock2, _super);
    function Stock2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "stock";
      return _this;
    }
    Stock2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            domain: [-1, 0, 1],
            range: DEFAULT_COLORS
          },
          y: { nice: true }
        },
        children: [
          // shadow
          {
            type: "link"
          },
          // real body
          {
            type: "link"
          }
        ],
        axis: {
          x: { title: false, grid: false },
          y: { title: false, grid: true, gridLineDash: null }
        },
        animate: { enter: { type: "scaleInY" } },
        interaction: {
          tooltip: {
            shared: true,
            marker: false,
            groupName: false,
            crosshairs: true
          }
        }
      };
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return Stock2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-line/adaptor.js
function adaptor11(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-line/index.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyLine = (
  /** @class */
  function(_super) {
    __extends18(TinyLine2, _super);
    function TinyLine2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyLine";
      return _this;
    }
    TinyLine2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line", axis: false }],
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-area/adaptor.js
function adaptor12(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-area/index.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyArea = (
  /** @class */
  function(_super) {
    __extends19(TinyArea2, _super);
    function TinyArea2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyArea";
      return _this;
    }
    TinyArea2.getDefaultOptions = function() {
      return {
        type: "view",
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        children: [{ type: "area", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-column/adaptor.js
function adaptor13(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-column/index.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends20(TinyColumn2, _super);
    function TinyColumn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyColumn";
      return _this;
    }
    TinyColumn2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/adaptor.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
function adaptor14(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a = options.color, color2 = _a === void 0 ? [] : _a;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color2.length ? color2 : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign13({}, transformOption));
    return params2;
  };
  return (0, import_lodash2.flow)(transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/index.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyProgress = (
  /** @class */
  function(_super) {
    __extends21(TinyProgress2, _super);
    function TinyProgress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyProgress";
      return _this;
    }
    TinyProgress2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        tooltip: false,
        children: [
          {
            interaction: { tooltip: false },
            coordinate: { transform: [{ type: "transpose" }] },
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d2) {
              return d2;
            }, color: function(d2, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyProgress2.prototype.getDefaultOptions = function() {
      return TinyProgress2.getDefaultOptions();
    };
    TinyProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyProgress2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/adaptor.js
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
function adaptor15(params) {
  var radius = function(params2) {
    var options = params2.options;
    var _a = options.radius, radius2 = _a === void 0 ? 0.8 : _a;
    (0, import_lodash2.set)(params2, "options.coordinate.innerRadius", radius2);
    return params2;
  };
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a = options.color, color2 = _a === void 0 ? [] : _a;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color2.length ? color2 : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign14({}, transformOption));
    return params2;
  };
  return (0, import_lodash2.flow)(radius, transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/index.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyRing = (
  /** @class */
  function(_super) {
    __extends22(TinyRing2, _super);
    function TinyRing2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyRing";
      return _this;
    }
    TinyRing2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        coordinate: { type: "theta" },
        animate: { enter: { type: "waveIn" } },
        interaction: { tooltip: false },
        tooltip: false,
        children: [
          {
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d2) {
              return d2;
            }, color: function(d2, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyRing2.prototype.getDefaultOptions = function() {
      return TinyRing2.getDefaultOptions();
    };
    TinyRing2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyRing2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/rose/adaptor.js
function adaptor16(params) {
  return (0, import_lodash2.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/rose/index.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rose = (
  /** @class */
  function(_super) {
    __extends23(Rose2, _super);
    function Rose2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rose";
      return _this;
    }
    Rose2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "polar" },
        animate: { enter: { type: "waveIn" } }
      };
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/waterfall/constants.js
var START_KEY = "__start__";
var END_KEY = "__end__";
var WATERFALL_VALUE = "__waterfall_value__";

// node_modules/@ant-design/plots/es/core/plots/waterfall/adaptor.js
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
var __spreadArray7 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor17(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, yField = options.yField;
    if (!data.length)
      return params2;
    data.reduce(function(prev, cur, index2) {
      var _a2;
      var getFieldData = fieldAdapter(yField);
      var newCur = getFieldData(cur, index2, data);
      if (index2 === 0 || cur.isTotal) {
        cur[START_KEY] = 0;
        cur[END_KEY] = newCur;
        cur[WATERFALL_VALUE] = newCur;
      } else {
        var start = (_a2 = prev[END_KEY]) !== null && _a2 !== void 0 ? _a2 : getFieldData(prev, index2, data);
        cur[START_KEY] = start;
        cur[END_KEY] = start + newCur;
        cur[WATERFALL_VALUE] = prev[END_KEY];
      }
      return cur;
    }, []);
    Object.assign(options, { yField: [START_KEY, END_KEY] });
    return params2;
  };
  var link3 = function(params2) {
    var options = params2.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, xField = options.xField, children = options.children, linkStyle = options.linkStyle;
    var linkData = __spreadArray7([], data, true);
    linkData.reduce(function(prev, cur, index2) {
      if (index2 > 0) {
        cur.x1 = prev[xField];
        cur.x2 = cur[xField];
        cur.y1 = prev[END_KEY];
      }
      return cur;
    }, []);
    linkData.shift();
    children.push({
      type: "link",
      xField: ["x1", "x2"],
      yField: "y1",
      //  scrollbar  link  interval
      zIndex: -1,
      data: linkData,
      style: __assign15({ stroke: "#697474" }, linkStyle),
      label: false,
      tooltip: false
    });
    return params2;
  };
  return (0, import_lodash2.flow)(transformData2, link3, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/waterfall/index.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Waterfall = (
  /** @class */
  function(_super) {
    __extends24(Waterfall2, _super);
    function Waterfall2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "waterfall";
      return _this;
    }
    Waterfall2.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          field: WATERFALL_VALUE,
          valueFormatter: "~s",
          name: "value"
        },
        axis: {
          y: {
            title: null,
            labelFormatter: "~s"
          },
          x: {
            title: null
          }
        },
        children: [
          {
            type: "interval",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/histogram/adaptor.js
function adaptor18(params) {
  var transformHistogramConfig = function(params2) {
    var options = params2.options;
    var data = options.data, binNumber = options.binNumber, binWidth = options.binWidth, children = options.children, _a = options.channel, channel = _a === void 0 ? "count" : _a;
    var targetTransform = (0, import_lodash2.get)(children, "[0].transform[0]", {});
    if ((0, import_lodash2.isNumber)(binWidth)) {
      (0, import_lodash2.assign)(targetTransform, { thresholds: (0, import_lodash2.ceil)((0, import_lodash2.divide)(data.length, binWidth)), y: channel });
      return params2;
    }
    if ((0, import_lodash2.isNumber)(binNumber)) {
      (0, import_lodash2.assign)(targetTransform, { thresholds: binNumber, y: channel });
      return params2;
    }
    return params2;
  };
  return (0, import_lodash2.flow)(transformHistogramConfig, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/histogram/index.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = (
  /** @class */
  function(_super) {
    __extends25(Histogram2, _super);
    function Histogram2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Histogram";
      return _this;
    }
    Histogram2.getDefaultOptions = function() {
      return {
        type: "view",
        autoFit: true,
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "rect",
            transform: [{ type: "binX", y: "count" }],
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/heatmap/adaptor.js
function adaptor19(params) {
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a = options.tooltip, tooltip3 = _a === void 0 ? {} : _a, colorField = options.colorField, sizeField = options.sizeField;
    if (tooltip3 && !tooltip3.field) {
      tooltip3.field = colorField || sizeField;
    }
    return params2;
  };
  var transformMark = function(params2) {
    var options = params2.options;
    var mark2 = options.mark, children = options.children;
    if (mark2) {
      children[0].type = mark2;
    }
    return params2;
  };
  return (0, import_lodash2.flow)(tooltip2, transformMark, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/heatmap/index.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap3 = (
  /** @class */
  function(_super) {
    __extends26(Heatmap4, _super);
    function Heatmap4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      return _this;
    }
    Heatmap4.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          valueFormatter: "~s"
        },
        axis: {
          y: {
            title: null,
            grid: true
          },
          x: {
            title: null,
            grid: true
          }
        },
        children: [
          {
            type: "point",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Heatmap4.prototype.getDefaultOptions = function() {
      return Heatmap4.getDefaultOptions();
    };
    Heatmap4.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    return Heatmap4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/box/adaptor.js
function adaptor20(params) {
  var init = function(params2) {
    var _a = params2.options.boxType, boxType = _a === void 0 ? "box" : _a;
    params2.options.children[0].type = boxType;
    return params2;
  };
  return (0, import_lodash2.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/box/index.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Box3 = (
  /** @class */
  function(_super) {
    __extends27(Box4, _super);
    function Box4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "box";
      return _this;
    }
    Box4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "box" }],
        axis: {
          y: { title: false },
          x: { title: false }
        },
        //  tooltip
        tooltip: {
          items: [
            { name: "min", channel: "y" },
            { name: "q1", channel: "y1" },
            { name: "q2", channel: "y2" },
            { name: "q3", channel: "y3" },
            { name: "max", channel: "y4" }
          ]
        }
      };
    };
    Box4.prototype.getDefaultOptions = function() {
      return Box4.getDefaultOptions();
    };
    Box4.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Box4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sankey/adaptor.js
function adaptor21(params) {
  var dataTransform4 = function(params2) {
    var options = params2.options;
    var data = options.data;
    var defaultTransform = [
      {
        type: "custom",
        callback: function(datum) {
          return { links: datum };
        }
      }
    ];
    if ((0, import_lodash2.isArray)(data)) {
      if (data.length > 0) {
        (0, import_lodash2.set)(options, "data", {
          value: data,
          transform: defaultTransform
        });
      } else {
        delete options.children;
      }
    } else if ((0, import_lodash2.get)(data, "type") === "fetch" && (0, import_lodash2.get)(data, "value")) {
      var transform = (0, import_lodash2.get)(data, "transform");
      if ((0, import_lodash2.isArray)(transform)) {
        (0, import_lodash2.set)(data, "transform", transform.concat(defaultTransform));
      } else {
        (0, import_lodash2.set)(data, "transform", defaultTransform);
      }
    }
    return params2;
  };
  return (0, import_lodash2.flow)(dataTransform4, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sankey/index.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sankey4 = (
  /** @class */
  function(_super) {
    __extends28(Sankey5, _super);
    function Sankey5() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "sankey";
      return _this;
    }
    Sankey5.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sankey" }] };
    };
    Sankey5.prototype.getDefaultOptions = function() {
      return Sankey5.getDefaultOptions();
    };
    Sankey5.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    return Sankey5;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bullet/adaptor.js
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
var DEFAULT_COLORS2 = ["#f0efff", "#5B8FF9", "#3D76DD"];
function getTransformData(data, field3, xField, isSort) {
  if (isSort === void 0) {
    isSort = true;
  }
  var maxSize = 0;
  var isArrayData = false;
  var transformData2 = (0, import_lodash2.map)(data, function(d2) {
    var _a, _b;
    var fieldData = (0, import_lodash2.get)(d2, [field3]);
    if ((0, import_lodash2.isNil)(fieldData))
      return [];
    if ((0, import_lodash2.isString)(fieldData)) {
      var numberData = Number(fieldData);
      if (isNaN(numberData))
        return [];
      return _a = {}, _a[xField] = d2[xField], _a[field3] = numberData, _a;
    }
    if ((0, import_lodash2.isArray)(fieldData)) {
      isArrayData = true;
      maxSize = Math.max(maxSize, fieldData.length);
      return (0, import_lodash2.map)(isSort ? fieldData.sort(function(a3, b) {
        return b - a3;
      }) : fieldData, function(value2, index2) {
        var _a2;
        return _a2 = {}, _a2[xField] = d2[xField], _a2[field3] = value2, _a2.index = index2, _a2;
      });
    }
    maxSize = Math.max(1, maxSize);
    return _b = {}, _b[xField] = d2[xField], _b[field3] = fieldData, _b;
  }).flat();
  if (isArrayData) {
    return [
      transformData2.map(function(item) {
        return __assign16({ index: 0 }, item);
      }),
      maxSize
    ];
  }
  return [transformData2, maxSize];
}
function getFieldColor(maxSize, color2) {
  return new Array(maxSize).fill("").map(function(d2, i) {
    return (0, import_lodash2.isArray)(color2) ? color2[i % color2.length] : color2;
  });
}
function adaptor22(params) {
  var init = function(params2) {
    var _a = params2.options, color2 = _a.color, _b = _a.rangeField, rangeField = _b === void 0 ? "ranges" : _b, _c = _a.measureField, measureField = _c === void 0 ? "measures" : _c, _d = _a.targetField, targetField = _d === void 0 ? "targets" : _d, _e = _a.xField, xField = _e === void 0 ? "title" : _e, mapField = _a.mapField, data = _a.data;
    var _f = getTransformData(data, rangeField, xField), rangesData = _f[0], rangesMaxSize = _f[1];
    var _g = getTransformData(data, measureField, xField, false), measuresData = _g[0], measuresMaxSize = _g[1];
    var _h = getTransformData(data, targetField, xField, false), targetsData = _h[0], targetsMaxSize = _h[1];
    var rangesColor = (0, import_lodash2.get)(color2, [rangeField], DEFAULT_COLORS2[0]);
    var measuresColor = (0, import_lodash2.get)(color2, [measureField], DEFAULT_COLORS2[1]);
    var targetsColor = (0, import_lodash2.get)(color2, [targetField], DEFAULT_COLORS2[2]);
    var colors = [
      getFieldColor(rangesMaxSize, rangesColor),
      getFieldColor(measuresMaxSize, measuresColor),
      getFieldColor(targetsMaxSize, targetsColor)
    ].flat();
    params2.options.children = (0, import_lodash2.map)(params2.options.children, function(c4, i) {
      var datas = [rangesData, measuresData, targetsData][i];
      var yField = [rangeField, measureField, targetField][i];
      return __assign16(__assign16({}, c4), {
        data: datas,
        encode: __assign16(__assign16({}, c4.encode || {}), { x: xField, y: yField, color: function(d2) {
          var index2 = d2.index;
          var mapString = (0, import_lodash2.isNumber)(index2) ? "".concat(yField, "_").concat(index2) : yField;
          return mapField ? (0, import_lodash2.get)(mapField, [yField, index2], mapString) : mapString;
        } }),
        style: __assign16(__assign16({}, c4.style || {}), {
          // 
          zIndex: function(d2) {
            return -d2[yField];
          }
        }),
        // labels  yField
        labels: i !== 0 ? (0, import_lodash2.map)(c4.labels, function(l) {
          return __assign16(__assign16({}, l), { text: yField });
        }) : void 0
      });
    });
    params2.options.scale.color.range = colors;
    params2.options.legend.color.itemMarker = function(d2) {
      if (mapField && (0, import_lodash2.includes)(mapField === null || mapField === void 0 ? void 0 : mapField[targetField], d2)) {
        return "line";
      }
      return (d2 === null || d2 === void 0 ? void 0 : d2.replace(/\_\d$/, "")) === targetField ? "line" : "square";
    };
    return params2;
  };
  var layoutAdaptor = function(params2) {
    var _a = params2.options.layout, layout = _a === void 0 ? "horizontal" : _a;
    if (layout !== "horizontal") {
      (0, import_lodash2.set)(params2, "options.children[2].shapeField", "hyphen");
    }
    return params2;
  };
  var cfgAdaptor = function(params2) {
    var _a = params2.options, _b = _a.range, range3 = _b === void 0 ? {} : _b, _c = _a.measure, measure = _c === void 0 ? {} : _c, _d = _a.target, target = _d === void 0 ? {} : _d, children = _a.children;
    params2.options.children = [range3, measure, target].map(function(c4, i) {
      return mergeWithArrayCoverage(children[i], c4);
    });
    return params2;
  };
  return (0, import_lodash2.flow)(init, layoutAdaptor, cfgAdaptor, allCoordinateLayout, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bullet/index.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = (
  /** @class */
  function(_super) {
    __extends29(Bullet2, _super);
    function Bullet2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bullet";
      return _this;
    }
    Bullet2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            range: DEFAULT_COLORS2
          }
        },
        legend: {
          color: {
            itemMarker: function(d2) {
              return d2 === "target" ? "line" : "square";
            }
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval",
            style: { maxWidth: 30 },
            axis: { y: { grid: true, gridLineWidth: 2 } }
          },
          {
            type: "interval",
            style: { maxWidth: 20 },
            transform: [{ type: "stackY" }]
          },
          {
            type: "point",
            encode: { size: 8, shape: "line" }
          }
        ],
        interaction: { tooltip: { shared: true } },
        coordinate: { transform: [{ type: "transpose" }] }
      };
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/gauge/adaptor.js
function adaptor23(params) {
  var init = function(params2) {
    var data = params2.options.data;
    params2.options.data = {
      value: data
    };
    return params2;
  };
  return (0, import_lodash2.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/gauge/index.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Gauge2 = (
  /** @class */
  function(_super) {
    __extends30(Gauge3, _super);
    function Gauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Gauge";
      return _this;
    }
    Gauge3.getDefaultOptions = function() {
      return {
        type: "view",
        legend: false,
        children: [{ type: "gauge" }]
      };
    };
    Gauge3.prototype.getDefaultOptions = function() {
      return Gauge3.getDefaultOptions();
    };
    Gauge3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Gauge3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/liquid/adaptor.js
function adaptor24(params) {
  var init = function(params2) {
    var percent = params2.options.percent;
    if ((0, import_lodash2.isNumber)(percent)) {
      (0, import_lodash2.set)(params2, "options.data", percent);
      delete params2.options.percent;
    }
    return params2;
  };
  return (0, import_lodash2.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/liquid/index.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Liquid3 = (
  /** @class */
  function(_super) {
    __extends31(Liquid4, _super);
    function Liquid4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Liquid";
      return _this;
    }
    Liquid4.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "liquid" }] };
    };
    Liquid4.prototype.getDefaultOptions = function() {
      return Liquid4.getDefaultOptions();
    };
    Liquid4.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    return Liquid4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/wordCloud/adaptor.js
function adaptor25(params) {
  return (0, import_lodash2.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/wordCloud/index.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud3 = (
  /** @class */
  function(_super) {
    __extends32(WordCloud4, _super);
    function WordCloud4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "WordCloud";
      return _this;
    }
    WordCloud4.getDefaultOptions = function() {
      return { type: "view", legend: false, children: [{ type: "wordCloud" }] };
    };
    WordCloud4.prototype.getDefaultOptions = function() {
      return WordCloud4.getDefaultOptions();
    };
    WordCloud4.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return WordCloud4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/treemap/adaptor.js
function adaptor26(params) {
  var init = function(params2) {
    var options = params2.options;
    var data = options.data;
    if (data) {
      (0, import_lodash2.set)(options, "data", {
        value: data
      });
    }
    return params2;
  };
  return (0, import_lodash2.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/treemap/index.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Treemap2 = (
  /** @class */
  function(_super) {
    __extends33(Treemap3, _super);
    function Treemap3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "treemap";
      return _this;
    }
    Treemap3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "treemap"
          }
        ]
      };
    };
    Treemap3.prototype.getDefaultOptions = function() {
      return Treemap3.getDefaultOptions();
    };
    Treemap3.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Treemap3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radial-bar/adaptor.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
function adaptor27(params) {
  var coordinate = function(params2) {
    var options = params2.options;
    var startAngle = options.startAngle, maxAngle = options.maxAngle, coordinate2 = options.coordinate;
    var start = (0, import_lodash2.isNumber)(startAngle) ? startAngle / (2 * Math.PI) * 360 : -90;
    var end = (0, import_lodash2.isNumber)(maxAngle) ? (Number(maxAngle) + start) / 180 * Math.PI : Math.PI;
    (0, import_lodash2.set)(params2, ["options", "coordinate"], __assign17(__assign17({}, coordinate2), { endAngle: end, startAngle: startAngle !== null && startAngle !== void 0 ? startAngle : -Math.PI / 2 }));
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    var getXFieldData = fieldAdapter(xField);
    var getYFieldData = fieldAdapter(yField);
    if (!tooltip3) {
      (0, import_lodash2.set)(options, "tooltip", {
        title: false,
        items: [function(d2, i, data) {
          return { name: getXFieldData(d2, i, data), value: getYFieldData(d2, i, data) };
        }]
      });
    }
    return params2;
  };
  var background = function(params2) {
    var options = params2.options;
    var markBackground = options.markBackground, children = options.children, scale3 = options.scale, coordinate2 = options.coordinate, xField = options.xField;
    var domain = (0, import_lodash2.get)(scale3, "y.domain", []);
    if (markBackground) {
      children.unshift(__assign17({
        type: "interval",
        xField,
        yField: domain[domain.length - 1],
        colorField: markBackground.color,
        scale: { color: { type: "identity" } },
        style: {
          fillOpacity: markBackground.opacity,
          fill: markBackground.color ? void 0 : "#e0e4ee"
          // fill
        },
        // 
        coordinate: __assign17(__assign17({}, coordinate2), { startAngle: -Math.PI / 2, endAngle: 3 / 2 * Math.PI }),
        animate: false
      }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash2.flow)(coordinate, tooltip2, background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radial-bar/index.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadialBar = (
  /** @class */
  function(_super) {
    __extends34(RadialBar3, _super);
    function RadialBar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radial";
      return _this;
    }
    RadialBar3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "radial", innerRadius: 0.1, outerRadius: 1, endAngle: Math.PI },
        animate: { enter: { type: "waveIn", duration: 800 } },
        axis: {
          y: {
            nice: true,
            labelAutoHide: true,
            labelAutoRotate: false
          },
          x: {
            title: false,
            nice: true,
            labelAutoRotate: false,
            labelAutoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        }
      };
    };
    RadialBar3.prototype.getDefaultOptions = function() {
      return RadialBar3.getDefaultOptions();
    };
    RadialBar3.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/circlePacking/adaptor.js
function adaptor28(params) {
  return (0, import_lodash2.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/circlePacking/index.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends35(CirclePacking2, _super);
    function CirclePacking2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "CirclePacking";
      return _this;
    }
    CirclePacking2.getDefaultOptions = function() {
      return {
        legend: false,
        type: "view",
        children: [
          {
            type: "pack"
          }
        ]
      };
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/violin/adaptor.js
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
function adaptor29(params) {
  var customTransform = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, seriesField = options.seriesField, children = options.children;
    var newChildren = children === null || children === void 0 ? void 0 : children.map(function(item) {
      return __assign18(__assign18({}, item), { xField, yField, seriesField, colorField: seriesField, data: item.type === "density" ? {
        transform: [
          {
            type: "kde",
            field: yField,
            groupBy: [xField, seriesField]
          }
        ]
      } : item.data });
    }).filter(function(item) {
      return options.violinType !== "density" || item.type === "density";
    });
    (0, import_lodash2.set)(options, "children", newChildren);
    if (options.violinType === "polar") {
      (0, import_lodash2.set)(options, "coordinate", { type: "polar" });
    }
    (0, import_lodash2.set)(options, "violinType", void 0);
    return params2;
  };
  return (0, import_lodash2.flow)(customTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/violin/index.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Violin2 = (
  /** @class */
  function(_super) {
    __extends36(Violin3, _super);
    function Violin3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      return _this;
    }
    Violin3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "density",
            sizeField: "size",
            tooltip: false
          },
          {
            type: "boxplot",
            shapeField: "violin",
            style: {
              opacity: 0.5,
              point: false
            }
          }
        ],
        animate: { enter: { type: "fadeIn" } }
      };
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/adaptor.js
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
var __spreadArray8 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor30(params) {
  var field3 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children;
    children.forEach(function(child, index2) {
      (0, import_lodash2.set)(child, "yField", yField[index2]);
    });
    return params2;
  };
  var data = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, data2 = options.data;
    if ((0, import_lodash2.isPlainObject)(data2))
      return params2;
    var transformData2 = (0, import_lodash2.isArray)((0, import_lodash2.get)(data2, [0])) ? data2 : [data2, data2];
    children.forEach(function(child, index2) {
      (0, import_lodash2.set)(child, "data", __spreadArray8([], transformData2[index2].map(function(item) {
        return __assign19({ groupKey: yField[index2] }, item);
      }), true));
    });
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a = options.yField, y12 = _a[0], y2 = _a[1], tooltip3 = options.tooltip;
    if (!tooltip3) {
      (0, import_lodash2.set)(options, "tooltip", {
        items: [
          {
            field: y12,
            value: y12
          },
          {
            field: y2,
            value: y2
          }
        ]
      });
    }
    return params2;
  };
  var layout = function(params2) {
    var options = params2.options;
    var children = options.children, layout2 = options.layout, transform = options.coordinate.transform, _a = options.paddingBottom, paddingBottom = _a === void 0 ? AXIS_LABEL_PADDING : _a, _b = options.paddingLeft, paddingLeft = _b === void 0 ? AXIS_LABEL_PADDING : _b, axis = options.axis;
    (0, import_lodash2.set)(options, "axisText", __assign19(__assign19({}, (axis === null || axis === void 0 ? void 0 : axis.x) || {}), { layout: layout2 }));
    var child1 = children[0], child2 = children[1];
    if (layout2 === "vertical") {
      (0, import_lodash2.set)(options, "direction", "col");
      (0, import_lodash2.set)(options, "paddingLeft", paddingLeft);
      (0, import_lodash2.set)(options, "coordinate.transform", transform.filter(function(item) {
        return item.type !== "transpose";
      }));
      (0, import_lodash2.set)(child1, "paddingBottom", HORIZONTAL_MARGIN);
      (0, import_lodash2.set)(child2, "paddingTop", HORIZONTAL_MARGIN);
      (0, import_lodash2.set)(child2, "axis", {
        x: {
          position: "top"
        }
      });
      (0, import_lodash2.set)(child2, "scale", {
        y: {
          range: [0, 1]
        }
      });
    } else {
      (0, import_lodash2.set)(options, "paddingBottom", paddingBottom);
      (0, import_lodash2.set)(child1, "scale", {
        y: {
          range: [0, 1]
        }
      });
      var _c = child1.paddingRight, paddingRight = _c === void 0 ? VERTICAL_MARGIN : _c;
      var _d = child2.paddingLeft, paddingLeft_1 = _d === void 0 ? VERTICAL_MARGIN : _d;
      (0, import_lodash2.set)(child1, "paddingRight", paddingRight);
      (0, import_lodash2.set)(child1, "axis", {
        x: {
          position: "right"
        }
      });
      (0, import_lodash2.set)(child2, "paddingLeft", paddingLeft_1);
    }
    return params2;
  };
  return (0, import_lodash2.flow)(field3, data, tooltip2, layout, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/index.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends37(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "BidirectionalBar";
      return _this;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return {
        type: "spaceFlex",
        coordinate: { transform: [{ type: "transpose" }] },
        scale: {
          y: { nice: true }
        },
        direction: "row",
        layout: "horizontal",
        legend: false,
        axis: {
          y: {
            title: false
          },
          x: { title: false, label: false }
        },
        children: [{ type: "interval" }, { type: "interval" }]
      };
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/venn/type.js
var DefaultTransformKey;
(function(DefaultTransformKey2) {
  DefaultTransformKey2["color"] = "key";
  DefaultTransformKey2["d"] = "path";
})(DefaultTransformKey || (DefaultTransformKey = {}));

// node_modules/@ant-design/plots/es/core/plots/venn/adaptor.js
function adaptor31(params) {
  var init = function(params2) {
    var options = params2.options;
    var data = options.data, setsField = options.setsField, sizeField = options.sizeField;
    if ((0, import_lodash2.isArray)(data)) {
      (0, import_lodash2.set)(options, "data", {
        type: "inline",
        value: data,
        transform: [
          {
            type: "venn",
            sets: setsField,
            size: sizeField,
            as: [DefaultTransformKey.color, DefaultTransformKey.d]
          }
        ]
      });
      (0, import_lodash2.set)(options, "colorField", setsField);
      (0, import_lodash2.set)(options, ["children", "0", "encode", "d"], DefaultTransformKey.d);
    }
    (0, import_lodash2.set)(params2, "options", (0, import_lodash2.omit)(options, ["sizeField", "setsField"]));
    return params2;
  };
  return (0, import_lodash2.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/venn/index.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Venn2 = (
  /** @class */
  function(_super) {
    __extends38(Venn3, _super);
    function Venn3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "venn";
      return _this;
    }
    Venn3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "path" }],
        legend: {
          color: { itemMarker: "circle" }
        },
        encode: { color: DefaultTransformKey.color, d: DefaultTransformKey.d }
      };
    };
    Venn3.prototype.getDefaultOptions = function() {
      return Venn3.getDefaultOptions();
    };
    Venn3.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Venn3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sunburst/adaptor.js
function adaptor32(params) {
  var init = function(params2) {
    return params2;
  };
  return (0, import_lodash2.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sunburst/index.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sunburst2 = (
  /** @class */
  function(_super) {
    __extends39(Sunburst3, _super);
    function Sunburst3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Sunburst";
      return _this;
    }
    Sunburst3.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sunburst" }] };
    };
    Sunburst3.prototype.getDefaultOptions = function() {
      return Sunburst3.getDefaultOptions();
    };
    Sunburst3.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    return Sunburst3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/index.js
var Plots = {
  Base,
  Line: Line6,
  Column: Column2,
  Pie,
  Area: Area3,
  Bar,
  DualAxes,
  Funnel: Funnel2,
  Scatter,
  Radar: Radar2,
  Rose,
  Stock,
  TinyLine,
  TinyArea,
  TinyColumn,
  TinyProgress,
  TinyRing,
  Waterfall,
  Histogram,
  Heatmap: Heatmap3,
  Box: Box3,
  Sankey: Sankey4,
  Bullet,
  Gauge: Gauge2,
  Liquid: Liquid3,
  WordCloud: WordCloud3,
  Treemap: Treemap2,
  RadialBar,
  CirclePacking,
  Violin: Violin2,
  BidirectionalBar,
  Venn: Venn2,
  Mix: DualAxes,
  Sunburst: Sunburst2
};

// node_modules/@ant-design/plots/es/components/base/index.js
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
var __rest95 = function(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var BaseChart = (0, import_react2.forwardRef)(function(_a, ref) {
  var _b = _a.chartType, chartType = _b === void 0 ? "Base" : _b, config = __rest95(_a, ["chartType"]);
  var _c = config.containerStyle, containerStyle = _c === void 0 ? {
    height: "inherit",
    flex: 1
  } : _c, _d = config.containerAttributes, containerAttributes = _d === void 0 ? {} : _d, className2 = config.className, loading = config.loading, loadingTemplate = config.loadingTemplate, errorTemplate = config.errorTemplate, rest = __rest95(config, ["containerStyle", "containerAttributes", "className", "loading", "loadingTemplate", "errorTemplate"]);
  var _e = useChart(Plots[chartType], rest), chart = _e.chart, container = _e.container;
  (0, import_react2.useImperativeHandle)(ref, function() {
    return chart.current;
  });
  return import_react2.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react2.default.createElement(ChartLoading, { loadingTemplate }),
    import_react2.default.createElement("div", __assign20({ className: className2, style: containerStyle, ref: container }, containerAttributes))
  );
});

// node_modules/@ant-design/plots/es/components/area/index.js
var import_react3 = __toESM(require_react());
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var AreaChart = (0, import_react3.forwardRef)(function(props, ref) {
  return import_react3.default.createElement(BaseChart, __assign21({}, props, { chartType: "Area", ref }));
});
var area_default4 = AreaChart;

// node_modules/@ant-design/plots/es/components/bar/index.js
var import_react4 = __toESM(require_react());
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var BarChart = (0, import_react4.forwardRef)(function(props, ref) {
  return import_react4.default.createElement(BaseChart, __assign22({}, props, { chartType: "Bar", ref }));
});
var bar_default = BarChart;

// node_modules/@ant-design/plots/es/components/column/index.js
var import_react5 = __toESM(require_react());
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
var ColumnChart = (0, import_react5.forwardRef)(function(props, ref) {
  return import_react5.default.createElement(BaseChart, __assign23({}, props, { chartType: "Column", ref }));
});
var column_default = ColumnChart;

// node_modules/@ant-design/plots/es/components/dual-axes/index.js
var import_react6 = __toESM(require_react());
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
var DualAxesChart = (0, import_react6.forwardRef)(function(props, ref) {
  return import_react6.default.createElement(BaseChart, __assign24({}, props, { chartType: "DualAxes", ref }));
});
var dual_axes_default = DualAxesChart;

// node_modules/@ant-design/plots/es/components/funnel/index.js
var import_react7 = __toESM(require_react());
var __assign25 = function() {
  __assign25 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign25.apply(this, arguments);
};
var FunnelChart = (0, import_react7.forwardRef)(function(props, ref) {
  return import_react7.default.createElement(BaseChart, __assign25({}, props, { chartType: "Funnel", ref }));
});
var funnel_default = FunnelChart;

// node_modules/@ant-design/plots/es/components/line/index.js
var import_react8 = __toESM(require_react());
var __assign26 = function() {
  __assign26 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign26.apply(this, arguments);
};
var LineChart = (0, import_react8.forwardRef)(function(props, ref) {
  return import_react8.default.createElement(BaseChart, __assign26({}, props, { chartType: "Line", ref }));
});
var line_default3 = LineChart;

// node_modules/@ant-design/plots/es/components/pie/index.js
var import_react9 = __toESM(require_react());
var __assign27 = function() {
  __assign27 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign27.apply(this, arguments);
};
var PieChart = (0, import_react9.forwardRef)(function(props, ref) {
  return import_react9.default.createElement(BaseChart, __assign27({}, props, { chartType: "Pie", ref }));
});
var pie_default2 = PieChart;

// node_modules/@ant-design/plots/es/components/scatter/index.js
var import_react10 = __toESM(require_react());
var __assign28 = function() {
  __assign28 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign28.apply(this, arguments);
};
var ScatterChart = (0, import_react10.forwardRef)(function(props, ref) {
  return import_react10.default.createElement(BaseChart, __assign28({}, props, { chartType: "Scatter", ref }));
});
var scatter_default = ScatterChart;

// node_modules/@ant-design/plots/es/components/radar/index.js
var import_react11 = __toESM(require_react());
var __assign29 = function() {
  __assign29 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign29.apply(this, arguments);
};
var RadarChart = (0, import_react11.forwardRef)(function(props, ref) {
  return import_react11.default.createElement(BaseChart, __assign29({}, props, { chartType: "Radar", ref }));
});
var radar_default = RadarChart;

// node_modules/@ant-design/plots/es/components/tiny/line/index.js
var import_react12 = __toESM(require_react());
var __assign30 = function() {
  __assign30 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign30.apply(this, arguments);
};
var TinyLineChart = (0, import_react12.forwardRef)(function(props, ref) {
  return import_react12.default.createElement(BaseChart, __assign30({}, props, { chartType: "TinyLine", ref }));
});
var line_default4 = TinyLineChart;

// node_modules/@ant-design/plots/es/components/tiny/area/index.js
var import_react13 = __toESM(require_react());
var __assign31 = function() {
  __assign31 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign31.apply(this, arguments);
};
var TinyAreaChart = (0, import_react13.forwardRef)(function(props, ref) {
  return import_react13.default.createElement(BaseChart, __assign31({}, props, { chartType: "TinyArea", ref }));
});
var area_default5 = TinyAreaChart;

// node_modules/@ant-design/plots/es/components/tiny/column/index.js
var import_react14 = __toESM(require_react());
var __assign32 = function() {
  __assign32 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign32.apply(this, arguments);
};
var TinyLineChart2 = (0, import_react14.forwardRef)(function(props, ref) {
  return import_react14.default.createElement(BaseChart, __assign32({}, props, { chartType: "TinyColumn", ref }));
});
var column_default2 = TinyLineChart2;

// node_modules/@ant-design/plots/es/components/tiny/progress/index.js
var import_react15 = __toESM(require_react());
var __assign33 = function() {
  __assign33 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign33.apply(this, arguments);
};
var TinyProgressChart = (0, import_react15.forwardRef)(function(props, ref) {
  return import_react15.default.createElement(BaseChart, __assign33({}, props, { chartType: "TinyProgress", ref }));
});
var progress_default = TinyProgressChart;

// node_modules/@ant-design/plots/es/components/tiny/ring/index.js
var import_react16 = __toESM(require_react());
var __assign34 = function() {
  __assign34 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign34.apply(this, arguments);
};
var TinyRingChart = (0, import_react16.forwardRef)(function(props, ref) {
  return import_react16.default.createElement(BaseChart, __assign34({}, props, { chartType: "TinyRing", ref }));
});
var ring_default = TinyRingChart;

// node_modules/@ant-design/plots/es/components/tiny/index.js
var Tiny = { Line: line_default4, Area: area_default5, Column: column_default2, Progress: progress_default, Ring: ring_default };

// node_modules/@ant-design/plots/es/components/rose/index.js
var import_react17 = __toESM(require_react());
var __assign35 = function() {
  __assign35 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign35.apply(this, arguments);
};
var RoseChart = (0, import_react17.forwardRef)(function(props, ref) {
  return import_react17.default.createElement(BaseChart, __assign35({}, props, { chartType: "Rose", ref }));
});
var rose_default = RoseChart;

// node_modules/@ant-design/plots/es/components/waterfall/index.js
var import_react18 = __toESM(require_react());
var __assign36 = function() {
  __assign36 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign36.apply(this, arguments);
};
var WaterfallChart = (0, import_react18.forwardRef)(function(props, ref) {
  return import_react18.default.createElement(BaseChart, __assign36({}, props, { chartType: "Waterfall", ref }));
});
var waterfall_default = WaterfallChart;

// node_modules/@ant-design/plots/es/components/histogram/index.js
var import_react19 = __toESM(require_react());
var __assign37 = function() {
  __assign37 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign37.apply(this, arguments);
};
var HistogramChart = (0, import_react19.forwardRef)(function(props, ref) {
  return import_react19.default.createElement(BaseChart, __assign37({}, props, { chartType: "Histogram", ref }));
});
var histogram_default = HistogramChart;

// node_modules/@ant-design/plots/es/components/heatmap/index.js
var import_react20 = __toESM(require_react());
var __assign38 = function() {
  __assign38 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign38.apply(this, arguments);
};
var HeatmapChart = (0, import_react20.forwardRef)(function(props, ref) {
  return import_react20.default.createElement(BaseChart, __assign38({}, props, { chartType: "Heatmap", ref }));
});
var heatmap_default = HeatmapChart;

// node_modules/@ant-design/plots/es/components/box/index.js
var import_react21 = __toESM(require_react());
var __assign39 = function() {
  __assign39 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign39.apply(this, arguments);
};
var BoxChart = (0, import_react21.forwardRef)(function(props, ref) {
  return import_react21.default.createElement(BaseChart, __assign39({}, props, { chartType: "Box", ref }));
});
var box_default = BoxChart;

// node_modules/@ant-design/plots/es/components/sankey/index.js
var import_react22 = __toESM(require_react());
var __assign40 = function() {
  __assign40 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign40.apply(this, arguments);
};
var SankeyChart = (0, import_react22.forwardRef)(function(props, ref) {
  return import_react22.default.createElement(BaseChart, __assign40({}, props, { chartType: "Sankey", ref }));
});
var sankey_default = SankeyChart;

// node_modules/@ant-design/plots/es/components/stock/index.js
var import_react23 = __toESM(require_react());
var __assign41 = function() {
  __assign41 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign41.apply(this, arguments);
};
var StockChart = (0, import_react23.forwardRef)(function(props, ref) {
  return import_react23.default.createElement(BaseChart, __assign41({}, props, { chartType: "Stock", ref }));
});
var stock_default = StockChart;

// node_modules/@ant-design/plots/es/components/bullet/index.js
var import_react24 = __toESM(require_react());
var __assign42 = function() {
  __assign42 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign42.apply(this, arguments);
};
var BulletChart = (0, import_react24.forwardRef)(function(props, ref) {
  return import_react24.default.createElement(BaseChart, __assign42({}, props, { chartType: "Bullet", ref }));
});
var bullet_default = BulletChart;

// node_modules/@ant-design/plots/es/components/gauge/index.js
var import_react25 = __toESM(require_react());
var __assign43 = function() {
  __assign43 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign43.apply(this, arguments);
};
var GaugeChart = (0, import_react25.forwardRef)(function(props, ref) {
  return import_react25.default.createElement(BaseChart, __assign43({}, props, { chartType: "Gauge", ref }));
});
var gauge_default = GaugeChart;

// node_modules/@ant-design/plots/es/components/liquid/index.js
var import_react26 = __toESM(require_react());
var __assign44 = function() {
  __assign44 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign44.apply(this, arguments);
};
var LiquidChart = (0, import_react26.forwardRef)(function(props, ref) {
  return import_react26.default.createElement(BaseChart, __assign44({}, props, { chartType: "Liquid", ref }));
});
var liquid_default = LiquidChart;

// node_modules/@ant-design/plots/es/components/wordCloud/index.js
var import_react27 = __toESM(require_react());
var __assign45 = function() {
  __assign45 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign45.apply(this, arguments);
};
var WordCloudChart = (0, import_react27.forwardRef)(function(props, ref) {
  return import_react27.default.createElement(BaseChart, __assign45({}, props, { chartType: "WordCloud", ref }));
});
var wordCloud_default = WordCloudChart;

// node_modules/@ant-design/plots/es/components/treemap/index.js
var import_react28 = __toESM(require_react());
var __assign46 = function() {
  __assign46 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign46.apply(this, arguments);
};
var TreemapChart = (0, import_react28.forwardRef)(function(props, ref) {
  return import_react28.default.createElement(BaseChart, __assign46({}, props, { chartType: "Treemap", ref }));
});
var treemap_default2 = TreemapChart;

// node_modules/@ant-design/plots/es/components/radial-bar/index.js
var import_react29 = __toESM(require_react());
var __assign47 = function() {
  __assign47 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign47.apply(this, arguments);
};
var RadialBar2 = (0, import_react29.forwardRef)(function(props, ref) {
  return import_react29.default.createElement(BaseChart, __assign47({}, props, { chartType: "RadialBar", ref }));
});
var radial_bar_default = RadialBar2;

// node_modules/@ant-design/plots/es/components/circlePacking/index.js
var import_react30 = __toESM(require_react());
var __assign48 = function() {
  __assign48 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign48.apply(this, arguments);
};
var CirclePackingChart = (0, import_react30.forwardRef)(function(props, ref) {
  return import_react30.default.createElement(BaseChart, __assign48({}, props, { chartType: "CirclePacking", ref }));
});
var circlePacking_default = CirclePackingChart;

// node_modules/@ant-design/plots/es/components/violin/index.js
var import_react31 = __toESM(require_react());
var __assign49 = function() {
  __assign49 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign49.apply(this, arguments);
};
var ViolinChart = (0, import_react31.forwardRef)(function(props, ref) {
  return import_react31.default.createElement(BaseChart, __assign49({}, props, { chartType: "Violin", ref }));
});
var violin_default = ViolinChart;

// node_modules/@ant-design/plots/es/components/bidirectional-bar/index.js
var import_react32 = __toESM(require_react());
var __assign50 = function() {
  __assign50 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign50.apply(this, arguments);
};
var BidirectionalBarChart = (0, import_react32.forwardRef)(function(props, ref) {
  return import_react32.default.createElement(BaseChart, __assign50({}, props, { chartType: "BidirectionalBar", ref }));
});
var bidirectional_bar_default = BidirectionalBarChart;

// node_modules/@ant-design/plots/es/components/venn/index.js
var import_react33 = __toESM(require_react());
var __assign51 = function() {
  __assign51 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign51.apply(this, arguments);
};
var VennChart = (0, import_react33.forwardRef)(function(props, ref) {
  return import_react33.default.createElement(BaseChart, __assign51({}, props, { chartType: "Venn", ref }));
});
var venn_default = VennChart;

// node_modules/@ant-design/plots/es/components/mix/index.js
var import_react34 = __toESM(require_react());
var __assign52 = function() {
  __assign52 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign52.apply(this, arguments);
};
var MixChart = (0, import_react34.forwardRef)(function(props, ref) {
  return import_react34.default.createElement(BaseChart, __assign52({}, props, { chartType: "Mix", ref }));
});
var mix_default = MixChart;

// node_modules/@ant-design/plots/es/components/sunburst/index.js
var import_react35 = __toESM(require_react());
var __assign53 = function() {
  __assign53 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign53.apply(this, arguments);
};
var SunburstChart = (0, import_react35.forwardRef)(function(props, ref) {
  return import_react35.default.createElement(BaseChart, __assign53({}, props, { chartType: "Sunburst", ref }));
});
var sunburst_default = SunburstChart;
export {
  area_default4 as Area,
  bar_default as Bar,
  BaseChart as Base,
  bidirectional_bar_default as BidirectionalBar,
  box_default as Box,
  bullet_default as Bullet,
  circlePacking_default as CirclePacking,
  column_default as Column,
  dual_axes_default as DualAxes,
  funnel_default as Funnel,
  esm_exports as G2,
  gauge_default as Gauge,
  heatmap_default as Heatmap,
  histogram_default as Histogram,
  line_default3 as Line,
  liquid_default as Liquid,
  mix_default as Mix,
  pie_default2 as Pie,
  radar_default as Radar,
  radial_bar_default as RadialBar,
  rose_default as Rose,
  sankey_default as Sankey,
  scatter_default as Scatter,
  stock_default as Stock,
  sunburst_default as Sunburst,
  Tiny,
  treemap_default2 as Treemap,
  venn_default as Venn,
  violin_default as Violin,
  waterfall_default as Waterfall,
  wordCloud_default as WordCloud,
  measureTextWidth
};
//# sourceMappingURL=@ant-design_plots.js.map
